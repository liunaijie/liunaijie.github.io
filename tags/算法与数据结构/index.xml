<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法与数据结构 on Jarvis`s library</title>
    <link>https://www.liunaijie.top/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 算法与数据结构 on Jarvis`s library</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 15 Oct 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.liunaijie.top/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法与数据结构</title>
      <link>https://www.liunaijie.top/coding/algorithm/algorithm/</link>
      <pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://www.liunaijie.top/coding/algorithm/algorithm/</guid>
      <description>&lt;p&gt;最近在看极客时间覃超的&lt;a href=&#34;https://time.geekbang.org/course/intro/100019701&#34;&gt;《算法面试通关 40 讲》&lt;/a&gt;，也一起看了一些数据结构，正好在这里进行一下整理。&lt;/p&gt;&#xA;&lt;p&gt;主要分为数据结构和算法两大章节，每个章节里面都会先结合自己的理解对它的定义进行一下解释，然后会拿出例题来进行实战。&lt;/p&gt;&#xA;&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;&#xA;&lt;h2 id=&#34;数组httpswwwliunaijietop20191015算法与数据结构数组&#34;&gt;&lt;a href=&#34;https://www.liunaijie.top/2019/10/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/&#34;&gt;数组&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;链表httpswwwliunaijietop20191015算法与数据结构链表&#34;&gt;&lt;a href=&#34;https://www.liunaijie.top/2019/10/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/&#34;&gt;链表&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;队列&#34;&gt;队列&lt;/h2&gt;&#xA;&lt;p&gt;先入先出（first in first out FIFO）&lt;/p&gt;&#xA;&lt;p&gt;习题：&lt;a href=&#34;https://www.liunaijie.top/2019/11/24/LeetCode/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-LeetCode232/&#34;&gt;用栈实现队列&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;普通队列&#34;&gt;普通队列&lt;/h3&gt;&#xA;&lt;h3 id=&#34;优先队列&#34;&gt;优先队列&lt;/h3&gt;&#xA;&lt;h2 id=&#34;堆栈&#34;&gt;堆栈&lt;/h2&gt;&#xA;&lt;p&gt;后入先出(last in first out LIFO)&lt;/p&gt;&#xA;&lt;p&gt;习题：&lt;a href=&#34;https://www.liunaijie.top/2019/11/24/LeetCode/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-LeetCode225/&#34;&gt;用队列实现栈&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;树&#34;&gt;树&lt;/h2&gt;&#xA;&lt;p&gt;链表是一种特殊的树，当每个链表节点的链表变成多个时就变成了树&lt;/p&gt;&#xA;&lt;h3 id=&#34;二叉搜索树binary-search-tree-bst&#34;&gt;二叉搜索树（binary search tree BST）&lt;/h3&gt;&#xA;&lt;p&gt;性质：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;左子树上所有节点的值均小于它的根节点的值&lt;/li&gt;&#xA;&lt;li&gt;右子树上所有节点的值均大于它的根节点的值；&lt;/li&gt;&#xA;&lt;li&gt;左，右子树也分别满足以上性质&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.liunaijie.top/2019/12/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%A6%E4%B9%A0&#34;&gt;AVL,红黑树学习&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;红黑树&#34;&gt;红黑树&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.liunaijie.top/2019/12/24/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%89%8B%E5%86%99%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0&#34;&gt;手写红黑树的简单实现&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;b-树&#34;&gt;B 树&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liunaijie/images/master/B%E6%A0%91.png&#34; alt=&#34;B树&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;b树&#34;&gt;B+树&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liunaijie/images/master/B%2B%E6%A0%91.png&#34; alt=&#34;B+树&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;MySQL 的 Innodb 中使用的索引就是采用的 B+树的数据结构进行存储的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Nim游戏—LeetCode292</title>
      <link>https://www.liunaijie.top/coding/algorithm/leetcode/nim%E6%B8%B8%E6%88%8Fleetcode292/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      <guid>https://www.liunaijie.top/coding/algorithm/leetcode/nim%E6%B8%B8%E6%88%8Fleetcode292/</guid>
      <description>&lt;h1 id=&#34;题目描述&#34;&gt;题目描述：&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。&#xA;你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。&#xA;示例:&#xA;输入: 4&#xA;输出: false&#xA;解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；&#xA;因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;思路&#34;&gt;思路：&lt;/h1&gt;&#xA;&lt;p&gt;先考虑一下什么情况会输呢，就是最后的石头被对手拿走，那么只要保证最后剩余1-3块石头我们即可获胜。如何能确保最后一定剩余1-3块呢，就要我们在每一步的时候跟对手拿的块数总和等于4。所以我们这道题就可以判断总块数是不是4的倍数，如果不是我们就可以赢。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
