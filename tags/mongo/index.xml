<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mongo on Jarvis`s library</title>
    <link>https://www.liunaijie.top/tags/mongo/</link>
    <description>Recent content in Mongo on Jarvis`s library</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 14 Apr 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.liunaijie.top/tags/mongo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>mongo-读操作事务</title>
      <link>https://www.liunaijie.top/coding/database/mongodb/%E8%AF%BB%E6%93%8D%E4%BD%9C%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://www.liunaijie.top/coding/database/mongodb/%E8%AF%BB%E6%93%8D%E4%BD%9C%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;p&gt;读取数据的过程需要关注以下两个问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从哪里读？关注数据节点位置&lt;/li&gt;&#xA;&lt;li&gt;什么样的数据可以读？关注数据的隔离性 第一个问题是由&lt;code&gt;readPreference&lt;/code&gt;来解决 第二个问是题由&lt;code&gt;readConcern&lt;/code&gt;来解决&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;什么是readpreference&#34;&gt;什么是readPreference&lt;/h1&gt;&#xA;&lt;p&gt;readPreference决定使用哪一个节点来满足正在发起的读请求。可选值包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;primary 主选择主节点&lt;/li&gt;&#xA;&lt;li&gt;primaryPreferred 优先选择主节点，如果不可用则选择从节点&lt;/li&gt;&#xA;&lt;li&gt;secondary 只选择从节点&lt;/li&gt;&#xA;&lt;li&gt;nearest 选择最近的节点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;readPreperfence使用场景举例&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户下订单后马上将用户转到订单详情页 primary/primaryPreferred。因为此时从节点可能还没复制到新订单&lt;/li&gt;&#xA;&lt;li&gt;用户查询自己下过的订单 secondary/secondaryPreferred。查询历史订单对时效性通常没有太高要求&lt;/li&gt;&#xA;&lt;li&gt;生成报表 secondary。报表对时效性要求不高，但要进行计算资源需求大，可以在从节点单独处理，避免对线上用户造成影响&lt;/li&gt;&#xA;&lt;li&gt;将用户上传的图片分发到全世界，让各地用户能够就近读取 nearest。每个地区的应用选择最近的节点读取时间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;readPreference与Tag&lt;/strong&gt; readPreference只能控制使用一类节点。Tag则可以将节点选择控制到一个或多个节点。 考虑以下场景： 一个5个节点的复制集，3个节点硬件较好，专用于服务线上客户，2个节点硬件较差，专用于生成报表。&lt;/p&gt;&#xA;&lt;p&gt;可以使用Tag来达到这样的控制目的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为3个较好的节点打上{purpose:&amp;ldquo;online&amp;rdquo;}&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为2个较差的节点打上{purpose:&amp;ldquo;analyse&amp;rdquo;}&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在线应用读取时指定&lt;code&gt;online&lt;/code&gt;，报表读取时指定&lt;code&gt;reporting&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liunaijie/images/master/20200329100110.png&#34; alt=&#34;https://raw.githubusercontent.com/liunaijie/images/master/20200329100110.png&#34;&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;readpreference配置&#34;&gt;readPreference配置&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过MongoDB的连接串参数&lt;code&gt;mongodb://host1:port,host2:port,host3:port/?replicaSet=rs&amp;amp;readPreperence=secondary&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;通过MongoDB驱动程序API &lt;code&gt;MongoCollection.withReadPreference(ReadPreference readPref)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Mongo Shell&lt;code&gt;db.collection.find({}).readPref(&amp;quot;secondary&amp;quot;)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;实验&#34;&gt;实验&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;锁定写入（同步）的命令&lt;/strong&gt;&lt;code&gt;db.fsyncLock()&lt;/code&gt;，解锁:&lt;code&gt;db.fsyncUnlock()&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;主节点写入{x:1},观察该条数据在各个节点均可见&lt;/li&gt;&#xA;&lt;li&gt;在两个从节点分别执行&lt;code&gt;db.fsyncLock()&lt;/code&gt;来锁定写入&lt;/li&gt;&#xA;&lt;li&gt;主节点写入{x:2}，在各个节点观察数据变化&lt;/li&gt;&#xA;&lt;li&gt;接触从节点锁定，观察各节点数据变化&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指定readPreference时也应注意高可用问题，利用将readPreference指定primary，则发生故障转移不存在primary期间将没有节点可读。所以如果业务允许，则应该选择primaryPreferred&lt;/li&gt;&#xA;&lt;li&gt;使用Tag时也会遇到同样的问题，如果只有一个节点拥有一个特定Tag，则在这个节点失效将无节点可读。这在有时候是期望的结果，有时候不是。例如&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果报表使用的节点失效，即使不生成报表，通常也不希望将报表负载转移到其他节点上，此时只有一个节点有报表Tag是合理的选择&lt;/li&gt;&#xA;&lt;li&gt;如果线上节点失效，通常希望有代替节点，所以应该保持多个节点有同样的Tag&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Tag有时需要与优先级，选举权综合考虑。例如做报表的节点通常不会希望它成为主节点，则优先级应为0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;什么是readconcern&#34;&gt;什么是readConcern&lt;/h1&gt;&#xA;&lt;p&gt;在readPreference选择了指定的节点后，readConcern决定这个节点上的数据哪些是可读的，类似于关系数据库的隔离级别。可选值包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;avaliable 读取所有可用的数据&lt;/li&gt;&#xA;&lt;li&gt;local 读取所有可用且属于当前分片的数据&lt;/li&gt;&#xA;&lt;li&gt;majority 读取在大多数节点上提交完成的数据&lt;/li&gt;&#xA;&lt;li&gt;linearizable 可线性化读取文档&lt;/li&gt;&#xA;&lt;li&gt;snapshot 读取最近快照中的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;readConcern:local和avaliable&lt;/strong&gt; 在复制集中local和avaliable是没有区别的。两者的区别主要是体现在分片集上考虑以下场景：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个chunk x正在从shard1向shard2迁移&lt;/li&gt;&#xA;&lt;li&gt;这个迁移过程中chunk x中的部分数据会在shard1和shard2中同时存在，但源分片shard1仍然是chunk 想的负责方&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有对chunk x的读写操作仍然进入shard1&lt;/li&gt;&#xA;&lt;li&gt;config中记录的信息chunk x仍然属于shard1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;此时如果读shard2，则会体现出local和avaliable的区别：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;local：只去应该有shard2负责的数据（不包括x）&lt;/li&gt;&#xA;&lt;li&gt;avaliable：shard2上有什么就读什么（包括xß）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;注意事项：&lt;/p&gt;</description>
    </item>
    <item>
      <title>mongo-复制集机制</title>
      <link>https://www.liunaijie.top/coding/database/mongodb/%E5%A4%8D%E5%88%B6%E9%9B%86%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://www.liunaijie.top/coding/database/mongodb/%E5%A4%8D%E5%88%B6%E9%9B%86%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E6%90%AD%E5%BB%BA/</guid>
      <description>&lt;h1 id=&#34;原理&#34;&gt;原理&lt;/h1&gt;&#xA;&lt;p&gt;MongoDB复制集的主要意义在于实现服务高可用 它的现实依赖于两个方面的功能：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据写入时将数据迅速的复制到另一个独立节点上&lt;/li&gt;&#xA;&lt;li&gt;在接受写入的节点发生故障时自动选举出一个新的替代节点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在实现高可用的同时，复制集实现了其他几个附加功能：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据分发：将数据从一个区域复制到另一个区域，减少另一个区域的读延迟&lt;/li&gt;&#xA;&lt;li&gt;读写分离：不同类型的压力分别在不同的节点上执行&lt;/li&gt;&#xA;&lt;li&gt;异地容灾：在数据中心故障时快速切换到异地&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;典型的复制集结构&#34;&gt;典型的复制集结构：&lt;/h2&gt;&#xA;&lt;p&gt;一个典型的复制集由3个以上具有投票权的节点组成，包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个主节点（PRIMARY） 接受写入操作和选举时投票&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;两个（或多个）从节点（SECONDARY） 复制主节点上的新数据和选举时投票 大部分分布式都需要奇数节点，因为投票时可以避免相同票数的情况&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liunaijie/images/master/20200327175458.png&#34; alt=&#34;https://raw.githubusercontent.com/liunaijie/images/master/20200327175458.png&#34;&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数据如何复制的&#34;&gt;数据如何复制的&lt;/h3&gt;&#xA;&lt;p&gt;当一个修改操作，无论是插入，更新或删除，到达主节点时，它对数据的操作将被记录下来（经过一些必要的转换），这些记录称为oplog。 当接到通过主节点上打开tailable游标不断获取新进入主节点的oplog，并在自己的数据上回放，依次保存跟主节点上的数据一致。&lt;/p&gt;&#xA;&lt;h3 id=&#34;通过选举完成故障恢复&#34;&gt;通过选举完成故障恢复&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具有投票权的节点之间两两互相发送心跳&lt;/li&gt;&#xA;&lt;li&gt;当5次心跳未收到时判断为节点失联&lt;/li&gt;&#xA;&lt;li&gt;如果失联的是主节点，从节点会发起选举，选出新的主节点&lt;/li&gt;&#xA;&lt;li&gt;如果失联的是从节点则不会产生新的选举&lt;/li&gt;&#xA;&lt;li&gt;选举基于 RAST一致性算法 实现，选举成功的必要条件是大多数投票节点存活&lt;/li&gt;&#xA;&lt;li&gt;复制集中最多可以有50个节点，但具有投票权的节点最多7个&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;影响选举的因素&#34;&gt;影响选举的因素&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;整个集群必须有大多数节点存活&lt;/li&gt;&#xA;&lt;li&gt;被选举为主节点的节点必须：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;能够与多数节点建立连接&lt;/li&gt;&#xA;&lt;li&gt;具有较新的oplog&lt;/li&gt;&#xA;&lt;li&gt;具有较高的优先级（优先级可以配置）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;复制集节点有以下常见的选配项&#34;&gt;复制集节点有以下常见的选配项：&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是否具有投票权（v参数） 有则参与投票&lt;/li&gt;&#xA;&lt;li&gt;优先级（priority参数） 优先级越高的节点的节点越优先成为主节点。优先级为0的节点无法成为主节点&lt;/li&gt;&#xA;&lt;li&gt;隐藏(hidden参数) 复制数据，但对应用不可见。隐藏节点可以拥有投票权，但优先级必须为0，即不能成为主节点。&lt;strong&gt;备份&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;延迟（slaveDelay参数） 复制n秒之前的数据，保存与主节点的时间差。&lt;strong&gt;容错&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;注意事项&#34;&gt;注意事项&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;增加节点不会增加系统写性能！ 因为写的操作都是在主节点完成，增加节点并不能改变主节点的性能，所以不会增加系统的写性能。甚至会降低性能，因为当写请求发送到从节点，从节点需要将请求发送给主节点来完成，完成后再通过oplog发送给所有从节点。 但增加节点可以增加系统读性能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;搭建&#34;&gt;搭建&lt;/h1&gt;&#xA;&lt;h2 id=&#34;准备配置文件&#34;&gt;准备配置文件&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;systemLog:&#xA;    destination: file&#xA;    path: /data/db1/mongod.log #日志存放位置&#xA;    logAppend: true&#xA;storage:&#xA;    db: /data/db1 #数据存储位置&#xA;net:&#xA;    bindIp: 0.0.0.0 #开启其他机器访问&#xA;    port: 28017 #端口&#xA;relication:&#xA;    replSetName: rs0 #集群名称&#xA;processManagement:&#xA;    fork: true #将进程作为后台进程&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;启动&#34;&gt;启动&lt;/h2&gt;&#xA;&lt;p&gt;指定配置文件启动：&lt;code&gt;mongod -f /data/db1/mongod.conf&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>mongo-基本命令</title>
      <link>https://www.liunaijie.top/coding/database/mongodb/%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://www.liunaijie.top/coding/database/mongodb/%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</guid>
      <description>&lt;p&gt;docker下载：&lt;code&gt;docker pull mongo&lt;/code&gt; 运行：&lt;code&gt;docker run -itd --name mongo -p 27017:27017 mongo&lt;/code&gt; 进入容器并运行mongo命令：&lt;code&gt;docker exec -it mongo mongo&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;基本操作命令：&lt;/p&gt;&#xA;&lt;h1 id=&#34;插入操作insert&#34;&gt;插入操作&lt;code&gt;insert&lt;/code&gt;&lt;/h1&gt;&#xA;&lt;p&gt;格式：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-   db.&amp;lt;集合&amp;gt;.insertOne(&amp;lt;JSON对象&amp;gt;)&#xA;-   db.&amp;lt;集合&amp;gt;.insertMany&amp;lt;[&amp;lt;JSON 1&amp;gt;,&amp;lt;JSON 2&amp;gt;, ...&amp;lt;JSON N&amp;gt;]&amp;gt; 示例：&#xA;-   `db.fruit.insertOne({name:&amp;#34;apple&amp;#34;})`&#xA;-   `db.fruit.insertMany([{name:&amp;#34;apple&amp;#34;},{name:&amp;#34;pear&amp;#34;}, {name:&amp;#34;orange&amp;#34;}])`&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;查询文档find&#34;&gt;查询文档find&lt;/h1&gt;&#xA;&lt;p&gt;find是MongoDB中查询数据的基本指令，相当于SQL中的SELECT find返回的是游标 示例：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;db.movies.find({&amp;ldquo;year&amp;rdquo;:1975}) 单条件查询&lt;/li&gt;&#xA;&lt;li&gt;db.movies.find({&amp;ldquo;year&amp;rdquo;:1989,&amp;ldquo;title&amp;rdquo;:&amp;ldquo;Batman&amp;rdquo;}) 多条件and查询&lt;/li&gt;&#xA;&lt;li&gt;db.movies.find({$and:[{&amp;ldquo;title&amp;rdquo;:&amp;ldquo;Batman&amp;rdquo;},{&amp;ldquo;category&amp;rdquo;:&amp;ldquo;action&amp;rdquo;}]}) and的另一种形式&lt;/li&gt;&#xA;&lt;li&gt;db.movies.find($or:[{&amp;ldquo;year&amp;rdquo;:1989},{&amp;ldquo;title&amp;rdquo;:&amp;ldquo;Batman&amp;rdquo;}]) 多条件or查询&lt;/li&gt;&#xA;&lt;li&gt;db.movies.find({&amp;ldquo;title&amp;rdquo;:&amp;quot;/^B/&amp;quot;}) 按正则表达式查找&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;查询条件对照表:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    SQL | MQL&#xA;    ---|---&#xA;    a = 1 | {a : 1}&#xA;    a &amp;lt;&amp;gt; 1 (a!=1) | {a: {$ne: 1}}&#xA;    a &amp;gt; 1 | {a: {$gt: 1}}&#xA;    a &amp;gt;= 1 | {a: {$gte: 1}}&#xA;    a &amp;lt; 1 | {a: {$lt: 1}}&#xA;    a &amp;lt;= 1 | {a: {$lte: 1}}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询逻辑对照表:&lt;/p&gt;</description>
    </item>
    <item>
      <title>mongo-索引</title>
      <link>https://www.liunaijie.top/coding/database/mongodb/%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://www.liunaijie.top/coding/database/mongodb/%E7%B4%A2%E5%BC%95/</guid>
      <description>&lt;p&gt;&lt;strong&gt;MongoDB的索引是基于B树的，B树也称为B-树。&lt;/strong&gt; 为什么MongoDB是B树，MySQL的B+树？ Mysql作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。 MongoDB使用B-树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql。&lt;/p&gt;&#xA;&lt;p&gt;Query Shape&amp;ndash;查询的形状 即查询语句中的条件，使用不同的条件会执行不同的索引。&lt;/p&gt;&#xA;&lt;p&gt;Index Prefix&amp;ndash;索引前缀 即最左前缀原则，创建(a,b)联合索引后，就无需创建(a)索引&lt;/p&gt;&#xA;&lt;p&gt;Selectivity&amp;ndash;过滤性 选择索引时会选择过滤性最强的一个，假设有这样的一个例子： 根据条件a=1查询后得到记录1000条 根据条件b=2查询后得到记录100条 根据条件c=3查询后得到记录10条 如果现在要执行查询条件为&lt;code&gt;a=1 and b=2 and c=3&lt;/code&gt;并且只能创建一个索引，就应该将索引创建在&lt;code&gt;c&lt;/code&gt;字段上&lt;/p&gt;&#xA;&lt;p&gt;查看执行计划：explain()&lt;code&gt;db.col.find({name:111}).explain(true)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;支持的索引类型&#34;&gt;支持的索引类型&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单键索引&lt;/li&gt;&#xA;&lt;li&gt;组合索引&lt;/li&gt;&#xA;&lt;li&gt;多值索引&lt;/li&gt;&#xA;&lt;li&gt;地理位置索引&lt;/li&gt;&#xA;&lt;li&gt;全文索引&lt;/li&gt;&#xA;&lt;li&gt;TTL索引&lt;/li&gt;&#xA;&lt;li&gt;部分索引&lt;/li&gt;&#xA;&lt;li&gt;哈希索引&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;组合索引&#34;&gt;组合索引&lt;/h3&gt;&#xA;&lt;p&gt;查询语句为&lt;code&gt;db.members.find({ gender : &amp;quot;F&amp;quot; , age : {$gte : 18}}).sort(&amp;quot;join_data&amp;quot;:1)&lt;/code&gt; 这个查询中有精确匹配，排序，范围查询这三个条件。&lt;/p&gt;&#xA;&lt;p&gt;组合索引的最佳方式：&lt;strong&gt;ESR&lt;/strong&gt;原则&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;精确（Equal）匹配的字段放在最前面&lt;/li&gt;&#xA;&lt;li&gt;排序（Sort）条件放中间&lt;/li&gt;&#xA;&lt;li&gt;范围（Range）匹配的字段放最后&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;同样适合:&lt;strong&gt;ES&lt;/strong&gt;,&lt;strong&gt;ER&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;创建索引：&lt;code&gt;db.col.createIndex({name:1})&lt;/code&gt; 后台创建索引：&lt;code&gt;db.member.createIndex({city:1},{background:true})&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>mongo-写操作事务</title>
      <link>https://www.liunaijie.top/coding/database/mongodb/%E5%86%99%E6%93%8D%E4%BD%9C%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://www.liunaijie.top/coding/database/mongodb/%E5%86%99%E6%93%8D%E4%BD%9C%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;h1 id=&#34;什么是writeconcern&#34;&gt;什么是writeConcern&lt;/h1&gt;&#xA;&lt;p&gt;writeConcern决定一个写操作落到多少个节点上才算成功。writeConcern的取值包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0：发起写操作，不关心是否成功；&lt;/li&gt;&#xA;&lt;li&gt;1~集群最大数据节点数，写操作需要被复制到指定节点数才算成功&lt;/li&gt;&#xA;&lt;li&gt;majority：写操作需要被复制到大多数节点才算成功。 发起写操作的程序将阻塞到写操作到达指定的节点数为止&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;默认行为&#34;&gt;默认行为：&lt;/h2&gt;&#xA;&lt;p&gt;3节点复制集不做任何特定设置（默认值）时的操作如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liunaijie/images/master/1585393042221.jpg&#34; alt=&#34;https://raw.githubusercontent.com/liunaijie/images/master/1585393042221.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;大多数节点确认模式&#34;&gt;大多数节点确认模式：&lt;/h2&gt;&#xA;&lt;p&gt;`w:&amp;ldquo;majority&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liunaijie/images/master/1585393318539.jpg&#34; alt=&#34;https://raw.githubusercontent.com/liunaijie/images/master/1585393318539.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当写的操作被大多数节点写入成功后才返回&lt;/p&gt;&#xA;&lt;h2 id=&#34;全部节点确认模式&#34;&gt;全部节点确认模式&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;w:&amp;quot;all&amp;quot;&lt;/code&gt;&#xA;设置后需要当所有的节点都将数据写入后才返回&lt;/p&gt;&#xA;&lt;h1 id=&#34;journal&#34;&gt;journal&lt;/h1&gt;&#xA;&lt;p&gt;writeConcern可以决定写操作到达多少个节点才算成功，journal则定义如何才算成功。取值包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;true:写操作落到journal文件中才算成功&lt;/li&gt;&#xA;&lt;li&gt;false：写操作到达内存即算作成功&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liunaijie/images/master/1585393755601.jpg&#34; alt=&#34;https://raw.githubusercontent.com/liunaijie/images/master/1585393755601.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;&#xA;&lt;p&gt;在复制集测试&lt;code&gt;writeConcern&lt;/code&gt;参数&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.test.insert({count:1,{writeConcern:{w:&amp;#34;majority&amp;#34;}}})&#xA;db.test.insert({count:1,{writeConcern:{w:&amp;#34;3&amp;#34;}}})&#xA;db.test.insert({count:1,{writeConcern:{w:&amp;#34;4&amp;#34;}}})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正常情况下，是可以正常返回的，可以手动修改配置，模拟延迟环境。 修改复制延迟参数：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;conf=rs.conf()&#xA;conf.members[i].slaveDelay=5 # 将第i个节点设置5秒的复制延迟&#xA;conf.members[i].priority=0 # 由于延迟所以不能设置为主节点&#xA;rs.reconfig(conf)  # 启用配置&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;设置超过延迟时间后失败：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.test.inser({count:3},{writeConcern:{w:&amp;#34;majority&amp;#34;,wtimeout:3000}}) #当大多数节点写入成功就算成功，超过3秒后如果未返回则失败&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意事项： 我们假设使用上面的配置，对节点启用5秒的延迟写入，并且等待超时时间为3秒，那么会返回下面的信息：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;WriteResult({&#xA;    &amp;#34;nInserted&amp;#34;:1,&#xA;    &amp;#34;writeConcernError&amp;#34; :{&#xA;        ...&#xA;    }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到上面有个属性&lt;code&gt;nInserted&lt;/code&gt;，这个属性表示已经成功写入了多个个节点，这里表示已经成功写入了1个节点，并不是全部的节点都没有这个数据。所以这是需要注意的地方&lt;/p&gt;&#xA;&lt;h1 id=&#34;注意事项&#34;&gt;注意事项&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;虽然多于办事的&lt;code&gt;writeConcern&lt;/code&gt;都是安全的，但通常只会设置&lt;code&gt;majority&lt;/code&gt;，这是因为等待写入延迟时间最短的选择&lt;/li&gt;&#xA;&lt;li&gt;不要将writeConcern等于总节点数，因为一旦有一个节点故障，所有写操作都将失败&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;writeConcern&lt;/code&gt;虽然会增加写操作延迟时间，但并不会显著增加集群压力，因此无论是否等待，写操作最终都会复制到所有节点上。设置&lt;code&gt;writeConcern&lt;/code&gt;只是让写操作复制后再返回而已&lt;/li&gt;&#xA;&lt;li&gt;应对重要数据应用&lt;code&gt;{w:&amp;quot;majority&amp;quot;}&lt;/code&gt;，普通数据可以应用&lt;code&gt;{w:1}&lt;/code&gt;以确保最佳性能&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
