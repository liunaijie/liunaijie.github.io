<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Class_loader on Jarvis`s library</title>
    <link>https://www.liunaijie.top/tags/class_loader/</link>
    <description>Recent content in Class_loader on Jarvis`s library</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 14 Oct 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.liunaijie.top/tags/class_loader/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java Class Loader</title>
      <link>https://www.liunaijie.top/coding/java/java-class-loader/</link>
      <pubDate>Thu, 14 Oct 2021 00:00:00 +0000</pubDate>
      <guid>https://www.liunaijie.top/coding/java/java-class-loader/</guid>
      <description>&lt;h1 id=&#34;class-loader&#34;&gt;Class Loader&lt;/h1&gt;&#xA;&lt;p&gt;站在Java虚拟机的角度来看，只存在两种不同的类加载器：&lt;/p&gt;&#xA;&lt;p&gt;一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；&lt;/p&gt;&#xA;&lt;p&gt;另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。&lt;/p&gt;&#xA;&lt;p&gt;站在Java开发人员的角度来看，类加载器就应当划分得更细致一些。自JDK 1.2以来，Java一直保&#xA;持着三层类加载器、双亲委派的类加载架构，尽管这套架构在Java模块化系统出现后有了一些调整变动，但依然未改变其主体结构。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java类加载机制</title>
      <link>https://www.liunaijie.top/coding/java/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      <guid>https://www.liunaijie.top/coding/java/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h1 id=&#34;类加载机制&#34;&gt;类加载机制&lt;/h1&gt;&#xA;&lt;h1 id=&#34;定义&#34;&gt;定义&lt;/h1&gt;&#xA;&lt;p&gt;Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最 终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。&lt;/p&gt;&#xA;&lt;h1 id=&#34;类的生命周期&#34;&gt;类的生命周期&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liunaijie/images/master/20211121102047.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按 照这种顺序按部就班地开始，而解析阶段则不一定:它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定特性(也称为动态绑定或晚期绑定)。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
