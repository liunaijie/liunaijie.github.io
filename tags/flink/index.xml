<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Flink on Jarvis`s library</title>
    <link>https://www.liunaijie.top/tags/flink/</link>
    <description>Recent content in Flink on Jarvis`s library</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 04 Dec 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.liunaijie.top/tags/flink/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Flink学习(一)</title>
      <link>https://www.liunaijie.top/publish/flink%E5%AD%A6%E4%B9%A0%E4%B8%80/</link>
      <pubDate>Sun, 04 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://www.liunaijie.top/publish/flink%E5%AD%A6%E4%B9%A0%E4%B8%80/</guid>
      <description>&lt;h1 id=&#34;时间语义&#34;&gt;时间语义&lt;/h1&gt;&#xA;&lt;p&gt;Flink中的时间有三种:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事件时间 Event Time.  事件真实发生的时间.&lt;/li&gt;&#xA;&lt;li&gt;摄入时间 Ingestion time. 事件接入到Flink系统的时间&lt;/li&gt;&#xA;&lt;li&gt;处理时间 Processing Time. 事件到到当前算子的时间&#xA;举一个夸张点的例子: 有一条记录, 它与&lt;code&gt;11:00:00&lt;/code&gt;这个时间点产生. 我们的Flink系统在&lt;code&gt;12:00:00&lt;/code&gt;这个时间点接入并进入第一个算子. 在Flink系统中又有很多个算子, 到达最后一个算子的时间为&lt;code&gt;13:00:00&lt;/code&gt;.&#xA;那么在这种情况下: 事件时间是&lt;code&gt;11:00:00&lt;/code&gt;. 这个是不会变的. 对于第一个算子而言, 这时的摄入时间和处理时间都为&lt;code&gt;12:00:00&lt;/code&gt;.  对于最后一个算子而言, 这时这条时间的摄入时间为&lt;code&gt;12:00:00&lt;/code&gt;. 处理时间为&lt;code&gt;13:00:00&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;设置时间语义&lt;/strong&gt;&#xA;我们需要在Job中设置执行时采用哪种时间语义.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setStreamTimeCharacteristic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TimeCharacteristic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;EventTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setStreamTimeCharacteristic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TimeCharacteristic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ProcessingTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setStreamTimeCharacteristic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TimeCharacteristic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;IngestionTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h2 id=&#34;processing-time--ingestion-time&#34;&gt;Processing Time &amp;amp; Ingestion Time&lt;/h2&gt;&#xA;&lt;p&gt;这两个时间都由Flink系统自己生成.&#xA;Processing Time是由每个算子自己生成, 实现起来非常简单, 延迟也是最小的. 但是由于每个时间都是获取的当前算子的时钟, 时钟可能不一致, 并且由于集群中不同机器的执行性能不同, 每个算子也有一定的耗时, 对于第N个算子来说的相同Processing Time, 可能到第N+1个算子上就会有改变. 因此Processing Time在时间窗口下的计算会有不确定性.&#xA;Ingestion Time是指事件到底Flink Source的时间. 一个事件在整个处理过程中都使用这个时间. 但是Ingestion Time也还是无法解决事件乱序问题.&lt;/p&gt;&#xA;&lt;p&gt;这两个时间语义如果对事件进行重新消费, 也不能保证幂等性.&lt;/p&gt;&#xA;&lt;h2 id=&#34;event-time&#34;&gt;Event Time&lt;/h2&gt;&#xA;&lt;p&gt;事件时间是这个事件真实产生的时间, 发生时伴随其他信息一起写入到时间中.&#xA;但是由于在网络中的传输或其他问题, 可能导致事件到底Flink系统时发生乱序、迟到等现象.&#xA;&lt;img src=&#34;https://raw.githubusercontent.com/liunaijie/images/master/20221204203917.svg&#34; alt=&#34;&#34;&gt;&#xA;真实情况中的数据大概如上图所示, 我们可以知道在Flink中进行处理的时间必然是大于等于事件发生的时间, 也就是事件都应该在这条红色虚线以下.&#xA;对于红色虚线上的点, 如上图的红色事件, 在12:10收到了12:20的事件, 这是一条未来的事件, 必须要对这条事件进行处理, 比如忽略或者对事件时间进行修改等, 不然会造成后续计算上的错误.&#xA;而对于蓝色的事件, 在12:10收到了11:50的事件, 这个事件是历史事件, 如果使用Flink作为批处理系统或者重置Offset后重刷历史, 这个都属于正常事件.&#xA;再来看一下事件时间发生在12:10的一系列事件, 它可以在12:10之后的任一时间到达Flink系统&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
