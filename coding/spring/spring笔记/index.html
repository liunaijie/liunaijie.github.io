<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta property="og:url" content="https://www.liunaijie.top/coding/spring/spring%E7%AC%94%E8%AE%B0/">
  <meta property="og:site_name" content="Jarvis`s library">
  <meta property="og:title" content="Spring笔记">
  <meta property="og:description" content="最近在阅读《Spring in action》这本书，也以此篇文章记录一下spring框架的相关内容。
那么既然聊spring了，一定会聊到的两个点就是ioc和aop。那就先来聊一下这两个东西。以下都是个人理解，如果有不对的地方，欢迎探讨指正。
ioc 和 aop 是编程思想，di 和 aspect 是他们的具体实现。
IOC IOC:控制反转，DI：依赖注入。
控制 在传统的 Java SE 程序中，我们在对象内部通过 new 的方法来创建对象实例，在这里是程序主动创建的依赖对象。而在 spring 中，它使用了专门的容器去控制对象。
控制的是对象的创建、初始化、销毁过程
在传统的 Java SE中，我们使用 new 进行创建。在构造器或者 setter 方法中给依赖对象赋值。给对象赋值 null 来销毁对象。
而在spring中一个bean的生命周期如下图所示：
反转 控制反转。我们之前是主动方，主动去控制对象的生命周期。现在变成了由 spring 去进行控制。我们由对象的控制者变成了被动控制者。
依赖注入 ioc 思想落实到代码上的具体实现。
在spring中，我们一般使用注解Component，Service，Repository，Controller，Autowired或Resource来进行注入。这个实例化出来的bean生命周期交给了spring来进行管理。我们将他们放在不同的类上表达不同的含义。
如果不进行主动声明，则默认的bean的名称为类名首字母小写，比如我对一个UserServiceImpl上添加@Service注解，spring则将这个类声明为userServiceImpl的bean。也可以这样进行主动声明@Service(&#34;beanName&#34;)。
如果我们对一个接口进入注入，这个接口下有多个实现类，这是spring就不知道我们要使用哪个实现类了，启动时会报错。
这时候有两种解决办法：
继续使用@Autowired注解
这个注解下也有两种解决方式：
对实现类进行修改，添加@Primary首选项注解
我们对其中一个实现类添加这个注解，那么在注入时会首先注入这个实现类
对引入类添加@Qualifier限定符注解
我们在@Autowired下添加这个注解，注解里面的内容为我们要注入实现类bean的id。这时候如果实现类的类名修改了也就是bean的id修改了，就又有问题了。这种情况下可以自定义限定符来实现。
使用@Resource注解
使用这个注解，即可在里面直接加参数，指定要注入实现类bean的id。
AOP 面向切面编程：
在软件开发中，散布于应用中多处的功能被称为横切关注点。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把这些横切关注点与业务逻辑相分离正是面向切面（AOP）所要解决的问题。
比如说我们现在有一个业务系统，有学生，教师，课程几个业务模块，我们现在需要一些功能，比如说日志，事务等功能，这些功能实际上并不是我们的业务模块，但是又需要在系统中添加，这就可以利用面向切面来解决这个问题。
在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称作切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（业务功能）的代码，而次要关注点的代码被转移到切面中了。
AOP术语 描述切面的常用术语有通知(advice)，切点(pointcut)和连接点(joinpoint)。
通知（Advice） 通知定义了切面是什么以及何时使用。
spring切面可以应用5种类型的通知
前置通知（Before）：在目标方法被调用之前调用通知功能； 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么； 返回通知（After-returning）：在目标方法成功执行之后调用通知； 异常通知（After-throwing）：在目标方法抛出异常后调用通知； 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。 连接点(JoinPoint) 连接点是在应用执行过程中能够插入切面的一个点。（被切入的地方）">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="coding">
    <meta property="article:published_time" content="2019-09-04T00:00:00+00:00">
    <meta property="article:modified_time" content="2019-09-04T00:00:00+00:00">
    <meta property="article:tag" content="Spring">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Spring笔记">
  <meta name="twitter:description" content="最近在阅读《Spring in action》这本书，也以此篇文章记录一下spring框架的相关内容。
那么既然聊spring了，一定会聊到的两个点就是ioc和aop。那就先来聊一下这两个东西。以下都是个人理解，如果有不对的地方，欢迎探讨指正。
ioc 和 aop 是编程思想，di 和 aspect 是他们的具体实现。
IOC IOC:控制反转，DI：依赖注入。
控制 在传统的 Java SE 程序中，我们在对象内部通过 new 的方法来创建对象实例，在这里是程序主动创建的依赖对象。而在 spring 中，它使用了专门的容器去控制对象。
控制的是对象的创建、初始化、销毁过程
在传统的 Java SE中，我们使用 new 进行创建。在构造器或者 setter 方法中给依赖对象赋值。给对象赋值 null 来销毁对象。
而在spring中一个bean的生命周期如下图所示：
反转 控制反转。我们之前是主动方，主动去控制对象的生命周期。现在变成了由 spring 去进行控制。我们由对象的控制者变成了被动控制者。
依赖注入 ioc 思想落实到代码上的具体实现。
在spring中，我们一般使用注解Component，Service，Repository，Controller，Autowired或Resource来进行注入。这个实例化出来的bean生命周期交给了spring来进行管理。我们将他们放在不同的类上表达不同的含义。
如果不进行主动声明，则默认的bean的名称为类名首字母小写，比如我对一个UserServiceImpl上添加@Service注解，spring则将这个类声明为userServiceImpl的bean。也可以这样进行主动声明@Service(&#34;beanName&#34;)。
如果我们对一个接口进入注入，这个接口下有多个实现类，这是spring就不知道我们要使用哪个实现类了，启动时会报错。
这时候有两种解决办法：
继续使用@Autowired注解
这个注解下也有两种解决方式：
对实现类进行修改，添加@Primary首选项注解
我们对其中一个实现类添加这个注解，那么在注入时会首先注入这个实现类
对引入类添加@Qualifier限定符注解
我们在@Autowired下添加这个注解，注解里面的内容为我们要注入实现类bean的id。这时候如果实现类的类名修改了也就是bean的id修改了，就又有问题了。这种情况下可以自定义限定符来实现。
使用@Resource注解
使用这个注解，即可在里面直接加参数，指定要注入实现类bean的id。
AOP 面向切面编程：
在软件开发中，散布于应用中多处的功能被称为横切关注点。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把这些横切关注点与业务逻辑相分离正是面向切面（AOP）所要解决的问题。
比如说我们现在有一个业务系统，有学生，教师，课程几个业务模块，我们现在需要一些功能，比如说日志，事务等功能，这些功能实际上并不是我们的业务模块，但是又需要在系统中添加，这就可以利用面向切面来解决这个问题。
在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称作切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（业务功能）的代码，而次要关注点的代码被转移到切面中了。
AOP术语 描述切面的常用术语有通知(advice)，切点(pointcut)和连接点(joinpoint)。
通知（Advice） 通知定义了切面是什么以及何时使用。
spring切面可以应用5种类型的通知
前置通知（Before）：在目标方法被调用之前调用通知功能； 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么； 返回通知（After-returning）：在目标方法成功执行之后调用通知； 异常通知（After-throwing）：在目标方法抛出异常后调用通知； 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。 连接点(JoinPoint) 连接点是在应用执行过程中能够插入切面的一个点。（被切入的地方）">

  
  
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#181818">
  <title>
    
    Jarvis`s library - Spring笔记
    
  </title>
  
  
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  
  
  
  <link rel="stylesheet" href="/minima.54cfcb44e10b4015b41a13771763013b79bdba6a92e49ea4a77bb44db465e761.css" integrity="sha256-VM/LROELQBW0GhN3F2MBO3m9umqS5J6kp3u0TbRl52E=">
  
  
  
  <script defer type="text/javascript" src="/minima.b4da24217e147f536fc7dc225886a1ea20bedabe7aed49e546a5d97cc34e4555.js" integrity="sha256-tNokIX4Uf1Nvx9wiWIah6iC&#43;2r567UnlRqXZfMNORVU="></script>
  
  
  
</head>
<script>
  const theme_config = 'system'
  const theme_light = theme_config === 'system' ? 'light' : theme_config;
  let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : theme_light;
  console.debug(theme);

  try {
    localStorage.setItem('theme', theme);
    window.minima_theme = theme;
    document.querySelector('html').classList.add(theme);
  } catch (e) {
    console.error(e);
  }
</script>



<body>
  <header class="mt-3 mb-8">
  <div class="container mx-auto">
    <nav class="flex justify-between items-center">
      <div class="flex items-center">
        
        <div id="theme-switch" class="text-2xl cursor-pointer"></div>
      </div>
      <ul class="flex items-center text-base font-semibold
        whitespace-nowrap overflow-x-auto overflow-y-hidden">
        
        <li class="ml-2 mr-2">
          
          <a href='/'>首页</a>
          
        </li>
        
        <li class="ml-2 mr-2">
          
          <a href="/tags">标签</a>
          
        </li>
        
        <li class="ml-2 mr-2">
          
          <a href="/search">搜索</a>
          
        </li>
        
        <li class="ml-2 mr-2">
          
          <a href="/about">关于</a>
          
        </li>
        
      </ul>
      <ul class="flex item-center text-sm font-semibold">
        
        <li class="ml-2"><a href="https://www.liunaijie.top/"></a></li>
        
      </ul>
    </nav>
  </div>
</header>

  
<div class="container mx-auto">
  <h1 class="text-4xl font-extrabold mt-6 mb-6">Spring笔记</h1>
  <div class="mb-3 text-sm flex justify-between ">
    <div>
      
      发布于 &mdash; 2019 年 09 月 04 日
      
      
    </div>
    
    <div>
      
      
      <a class="ml-1" href="/tags/Spring">#Spring</a>
      
    </div>
    
  </div>
  <main class="mb-8">
    <p></p>
    <article class="md">
      <p>最近在阅读《Spring in action》这本书，也以此篇文章记录一下<code>spring</code>框架的相关内容。</p>
<p>那么既然聊<code>spring</code>了，一定会聊到的两个点就是<code>ioc</code>和<code>aop</code>。那就先来聊一下这两个东西。以下都是个人理解，如果有不对的地方，欢迎探讨指正。</p>
<p>ioc 和 aop 是编程思想，di 和 aspect 是他们的具体实现。</p>
<h1 id="ioc">IOC</h1>
<p>IOC:控制反转，DI：依赖注入。</p>
<h2 id="控制">控制</h2>
<p>在传统的 Java SE 程序中，我们在对象内部通过 new 的方法来创建对象实例，在这里是程序主动创建的依赖对象。而在 spring 中，它使用了专门的容器去控制对象。</p>
<p>控制的是对象的<strong>创建、初始化、销毁</strong>过程</p>
<p>在传统的 Java SE中，我们使用 new 进行创建。在构造器或者 setter 方法中给依赖对象赋值。给对象赋值 null 来销毁对象。</p>
<p>而在spring中一个bean的生命周期如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/spring%E7%9A%84bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="bean的生命周期"></p>
<h2 id="反转">反转</h2>
<p>控制反转。我们之前是主动方，主动去控制对象的生命周期。现在变成了由 spring 去进行控制。我们由对象的控制者变成了被动控制者。</p>
<h2 id="依赖注入">依赖注入</h2>
<p>ioc 思想落实到代码上的具体实现。</p>
<p>在spring中，我们一般使用注解<code>Component</code>，<code>Service</code>，<code>Repository</code>，<code>Controller</code>，<code>Autowired</code>或<code>Resource</code>来进行注入。这个实例化出来的bean生命周期交给了spring来进行管理。我们将他们放在不同的类上表达不同的含义。</p>
<p>如果不进行主动声明，则默认的bean的名称为类名首字母小写，比如我对一个<code>UserServiceImpl</code>上添加<code>@Service</code>注解，spring则将这个类声明为<code>userServiceImpl</code>的bean。也可以这样进行主动声明<code>@Service(&quot;beanName&quot;)</code>。</p>
<p>如果我们对一个接口进入注入，这个接口下有多个实现类，这是spring就不知道我们要使用哪个实现类了，启动时会报错。</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/20190919083201.png" alt=""></p>
<p>这时候有两种解决办法：</p>
<ul>
<li>
<p>继续使用<code>@Autowired</code>注解</p>
<p>这个注解下也有两种解决方式：</p>
<ul>
<li>
<p>对实现类进行修改，添加<code>@Primary</code>首选项注解</p>
<p>我们对其中一个实现类添加这个注解，那么在注入时会首先注入这个实现类</p>
</li>
<li>
<p>对引入类添加<code>@Qualifier</code>限定符注解</p>
<p>我们在<code>@Autowired</code>下添加这个注解，注解里面的内容为我们要注入实现类bean的id。这时候如果实现类的类名修改了也就是bean的id修改了，就又有问题了。这种情况下可以自定义限定符来实现。</p>
</li>
</ul>
</li>
<li>
<p>使用<code>@Resource</code>注解</p>
<p>使用这个注解，即可在里面直接加参数，指定要注入实现类bean的id。</p>
</li>
</ul>
<h1 id="aop">AOP</h1>
<p>面向切面编程：</p>
<blockquote>
<p>在软件开发中，散布于应用中多处的功能被称为横切关注点。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把这些横切关注点与业务逻辑相分离正是面向切面（AOP）所要解决的问题。</p></blockquote>
<p>比如说我们现在有一个业务系统，有学生，教师，课程几个业务模块，我们现在需要一些功能，比如说日志，事务等功能，这些功能实际上并不是我们的业务模块，但是又需要在系统中添加，这就可以利用面向切面来解决这个问题。</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/a4.1.png" alt=""></p>
<blockquote>
<p>在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称作切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（业务功能）的代码，而次要关注点的代码被转移到切面中了。</p></blockquote>
<h2 id="aop术语">AOP术语</h2>
<p>描述切面的常用术语有通知(advice)，切点(pointcut)和连接点(joinpoint)。</p>
<h3 id="通知advice">通知（Advice）</h3>
<p>通知定义了切面是什么以及何时使用。</p>
<p>spring切面可以应用5种类型的通知</p>
<ul>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ul>
<h3 id="连接点joinpoint">连接点(JoinPoint)</h3>
<p>连接点是在应用执行过程中能够插入切面的一个点。（被切入的地方）</p>
<h3 id="切点pointcut">切点(PointCut)</h3>
<p>切点定义了&quot;何处&quot;。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来制定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。（定义的包，类，方法，注解等）</p>
<h3 id="切面aspect">切面(Aspect)</h3>
<p>切面是通知和切点的结合，通知和切点共同定义了切面的全部内容&ndash;它是什么，在何时和何处完成其功能。</p>
<h3 id="引入">引入</h3>
<p>引入允许我们向现有的类添加新方法或属性。</p>
<h3 id="织入">织入</h3>
<p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p>
<ul>
<li>编译期：切面在目标类编译时被织入，这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader)，它可以在目标被引入应用之前增强该目标类的字节码，AspectJ5的加载时织入就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>
</ul>
<h2 id="实现">实现</h2>
<h4 id="代码">代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 添加 @Aspect注解声明这是一个切面类</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Aspect</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 添加 @Component注解声明这是一个javabean，不然spring扫描不到这个类，我们在这里写的东西就没有用</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestAspect</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 使用@Pointcut注解定义可重用的切点，这样在下面就可以直接调用这个切点的方法名即可</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Pointcut</span><span class="p">(</span><span class="s">&#34;execution(* com.test..*.*(..))&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">testPointcut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Before</span><span class="p">(</span><span class="s">&#34;testPointcut()&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doBefore</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;method before...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@After</span><span class="p">(</span><span class="s">&#34;testPointcut()&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doAfter</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;method after...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">	
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我先声明了利用<code>@Pointcut</code>声明了一个切点，里面使用了<code>execution</code>关键字，这个关键字里面的内容就描述了我要对哪个地方进行切入。</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/execution%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90.png" alt="execution表达式解析"></p>
<p>在我刚才写的代码里面我是对<code>com.test</code>包下的所有的类，所有的方法，不管其参数类型，返回结果类型都进行切入，当<code>com.test</code>包下的方法被调用时，调用前会打印<code>doBefore()</code>方法中的内容，调用完成后会打印<code>doAfter()</code>方法中的内容。</p>
<p>我们只需要调整表达式里面的内容就可以自定义实现要切入的点。</p>
<p>然后再说一下对<strong>注解</strong>的切入</p>
<p>如果我们自定义了一个注解，然后需要对这个注解实现切入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Aspect</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestAspect</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Around</span><span class="p">(</span><span class="s">&#34;@annotation(testAnnotation)&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">around</span><span class="p">(</span><span class="n">ProceedingJoinPoint</span><span class="w"> </span><span class="n">proceedingJoinPoint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">try</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;before method proceed...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">proceedingJoinPoint</span><span class="p">.</span><span class="na">proceed</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;after method proceed...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">           </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;method error...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对添加了<code>testAnnotation</code>注解的方法会执行这个切入，并且我使用了环绕通知。这里多了一个<code>ProceedingJoinPoint</code>参数，这个对象是必须要有的，需要调用<code>proceed()</code>方法才会实际调用被切入点执行的方法，而有意思的地方是<strong>这个方法我们可以不调用(不会执行被切入点的逻辑)，也可调用一至多次</strong>。</p>
<p>之前说的通知也有相应的注解</p>
<table>
  <thead>
      <tr>
          <th>注解</th>
          <th>通知</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>@Before</td>
          <td>通知方法会在目标方法调用之前执行</td>
      </tr>
      <tr>
          <td>@After</td>
          <td>通知方法会在目标方法返回或抛出异常后调用</td>
      </tr>
      <tr>
          <td>@AfterReturning</td>
          <td>通知方法会在目标方法返回后调用</td>
      </tr>
      <tr>
          <td>@AfterThrowing</td>
          <td>通知方法会在目标方法抛出异常后调用</td>
      </tr>
      <tr>
          <td>@Around</td>
          <td>通知方法会将目标方法封装起来</td>
      </tr>
  </tbody>
</table>
<h4 id="进阶">进阶</h4>
<ol>
<li>
<p>多个切面时执行顺序</p>
<p>当一个类被多个切面切入时，如何控制多个切面的顺序呢？这时需要使用<code>@Order()</code>注解。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Aspect</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Order</span><span class="p">(</span><span class="n">1</span><span class="p">)</span><span class="w">  </span><span class="c1">//数值越小，优先级越高</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestAspect</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>设置在特定环境中使用 aop</p>
<p>有一些通过 aop 实现的功能我们可能只想在开发、测试环境中进行使用。在生成环境中进行关闭。这时我们可以添加<code>@Profile</code>注解即可</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Aspect</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Profile</span><span class="p">({</span><span class="s">&#34;dev&#34;</span><span class="p">,</span><span class="s">&#34;test&#34;</span><span class="p">})</span><span class="w">  </span><span class="c1">//添加这个注解即可在开发，测试环境中使用这个切面</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestAspect</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>添加这个注解后，需要在配置文件的<code>spring.profiles.active</code>属性设置为<code>dev</code>或<code>test</code>并添加相应的配置文件即可。</p>
</li>
</ol>
<p>通过一张图来说明 aop 的执行顺序。</p>
<p>![aop流程](<a href="https://raw.githubusercontent.com/liunaijie/images/master/aop">https://raw.githubusercontent.com/liunaijie/images/master/aop</a> 流程.png)</p>
<h4 id="通过注解引入新功能">通过注解引入新功能</h4>
<p>我们知道，切面只是实现了它们所包装的bean相同接口的代理。所以我们可以让接口暴露新的接口来实现添加新功能，比如现在我们需要对源码中的方法进行增强，需要添加一个方法，那么这个方式就很好的实现。</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/aop%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%8A%9F%E8%83%BD.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Aspect</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AddMethodAspect</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@DeclareParents</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s">&#34;com.test.ClassA+&#34;</span><span class="p">,</span><span class="n">defaultImpl</span><span class="o">=</span><span class="n">DefaultEncoreable</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Encoreable</span><span class="w"> </span><span class="n">encoreable</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 新增加的接口，对切面新增加了一个方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">Encoreable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">performEncore</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">DefaultEncoreable</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Encoreable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">performEncore</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;this is a new method&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里也是定义了一个切面，但是这个切面有之前定义的有所不同，它并没有定义切点，通知方法。而是通过<code>@DeclareParents</code>注解，将<code>Encoreable</code>接口引入到<code>ClassA</code><strong>bean</strong>中。</p>
<p><code>@DeclareParents</code>注解主要由三部分组成</p>
<ul>
<li>value属性指定了哪种类型的bean要引入该接口，在本例中，也就是所有实现<code> ClassA</code>的类型。（标记符后面的加号表示所有子类型，而不是本身）</li>
<li>defaultImpl属性指定了为引入功能提供实现的类，这里指定了<code>DefaultEncoreable</code>提供实现</li>
<li><code>@DeclareParents</code>注解所标记的静态属性指明了要引入的接口。</li>
</ul>
<p>这样在调用所有实现<code>ClassA</code>类型的bean时，都可以进行调用<code>performEncore</code>方法。</p>
<p><strong>spring会创建一个代理，然后将调用委托给被代理的bean或被引入的实现，这取决于调用的方法属于被代理的bean还是属于被引入的接口。</strong></p>
<h2 id="aop-使用场景">AOP 使用场景</h2>
<ul>
<li>权限控制</li>
<li>日志存储</li>
<li>统一异常处理</li>
<li>缓存处理</li>
<li>事务处理</li>
<li>……</li>
</ul>
<h1 id="事务">事务</h1>
<h2 id="事务隔离级别">事务隔离级别</h2>
<p>在spring中，事务的隔离级别有五种，分别为</p>
<ul>
<li>
<p>DEFAULT(默认)</p>
<p>使用数据库的隔离级别</p>
</li>
<li>
<p>READ_UNCOMMITTED(读未提交)</p>
</li>
<li>
<p>READ_COMMITTED(读已提交)</p>
</li>
<li>
<p>SERIALIZABLE(串行化)</p>
</li>
</ul>
<p>就是数据库的四种事务隔离级别再加上一个<code>default</code>，其他四种事务隔离级别在[MySQL知识整理这篇文章中进行了记录</p>
<h2 id="事务传播级别">事务传播级别</h2>
<p>一共有7种</p>
<ul>
<li>
<p>Required</p>
<p>当前方法必须运行在事务中，如果当前事务存在，方法就在该事务中运行，否则会启动一个新的事务</p>
</li>
<li>
<p>Supports</p>
<p>不需要事务，但是如果存在事务就在事务中运行</p>
</li>
<li>
<p>Mandatory</p>
<p>方法必须在事务中运行，如果不存在事务就抛出一个异常</p>
</li>
<li>
<p>REQUIRES_NEW</p>
<p>当前方法必须运行在自己的事务中，新启动一个事务，如果当时有事务则将当前事务挂起</p>
</li>
<li>
<p>Not_Supported</p>
<p>当前方法不运行在事务中，如果存在事务，则在方法运行期间将事务挂起</p>
</li>
<li>
<p>Never</p>
<p>当前方法不应该运行在事务中，如果有事务，就抛出异常</p>
</li>
<li>
<p>Nested</p>
<p>如果当前存在事务，则会嵌套事务运行，嵌套的事务可以独立的提交和回滚，不会对嵌套外部的事务有影响。如果当前不存在事务，则和Required一样</p>
</li>
</ul>
<h2 id="spring-中事务无效的情况transactional">Spring 中事务无效的情况（@Transactional）</h2>
<ol>
<li>
<p>数据库是否支持事务</p>
</li>
<li>
<p>注解添加在私有方法上<code>private</code>无效</p>
</li>
<li>
<p>拦截的异常小于抛出的异常，注解里面的参数<code>rollbackFor</code>执行回滚的异常类型，如果这个异常类型比抛出的异常类型小就无法回滚。</p>
</li>
<li>
<p>加入在未加入接口的public 方法，再通过普通接口方法调用，无效</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">UserServiceImpl</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">UserService</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">implementsMethod</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 实现的接口方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 此时事务无效</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">selfMethod</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Transactional</span><span class="p">(</span><span class="n">propagation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Propagation</span><span class="p">.</span><span class="na">REQUIRED</span><span class="p">,</span><span class="w"> </span><span class="n">rollbackFor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Exception</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">selfMethod</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//自己新增的方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//数据库操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="n">userDao</span><span class="p">.</span><span class="na">insert</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">User</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="c1">// 我们知道 0 不能作为除数，所以会报错，然后通过异常拦截回滚</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>在没有事务的方法中调用有事务的方法，如果在有事务的方法中抛出异常事务也是无效的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">UserServiceImpl</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">UserService</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">noTransactional</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 此时事务无效</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="n">hasTransactional</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nd">@Transactional</span><span class="p">(</span><span class="n">propagation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Propagation</span><span class="p">.</span><span class="na">REQUIRED</span><span class="p">,</span><span class="w"> </span><span class="n">rollbackFor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Exception</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hasTransactional</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="c1">//数据库操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="n">userDao</span><span class="p">.</span><span class="na">insert</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">User</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="c1">// 我们知道 0 不能作为除数，所以会报错，然后通过异常拦截回滚</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果要对这种情况进行改进，可以使用两种方式</p>
<ol>
<li>
<p>对调用方法添加事务注解</p>
</li>
<li>
<p>调用时通过实例调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">UserServiceImpl</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">UserService</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="kd">private</span><span class="w"> </span><span class="n">UserService</span><span class="w"> </span><span class="n">userService</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">noTransactional</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 此时事务有效</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="n">userService</span><span class="p">.</span><span class="na">hasTransactional</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nd">@Transactional</span><span class="p">(</span><span class="n">propagation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Propagation</span><span class="p">.</span><span class="na">REQUIRED</span><span class="p">,</span><span class="w"> </span><span class="n">rollbackFor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Exception</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hasTransactional</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="c1">//数据库操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="n">userDao</span><span class="p">.</span><span class="na">insert</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">User</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="c1">// 我们知道 0 不能作为除数，所以会报错，然后通过异常拦截回滚</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
</ol>
<h1 id="配置文件加载顺序">配置文件加载顺序</h1>
<p>几个常用的方式顺序，优先级高的会覆盖优先级低的。</p>
<ol>
<li>命令行参数</li>
<li>jar包同级的目录中的配置文件</li>
<li>源码resources中的配置文件</li>
</ol>
<p>我们用几个例子来说明，一个项目的结构如下：</p>
<ol>
<li>
<blockquote>
<p>&ndash; application.properties</p>
<p>|&ndash; demo.jar</p>
<p>​		|&ndash; application.properties</p></blockquote>
</li>
</ol>
<p>那么这个在目录外的配置文件会比源码里面的配置文件优先级高</p>
<ol start="2">
<li>当我们设置了<code>spring.profile.active</code>这个属性后，会根据不同环境选择不同的配置文件</li>
</ol>
<blockquote>
<p>&ndash; applitaion.properties</p>
<p>​	|&ndash; spring.profile.active=dev</p>
<p>​	|&ndash; server.port=8080</p>
<p>&ndash; applicaton-dev.properties</p>
<p>​	|&ndash; server.port=8081</p></blockquote>
<p>当在主配置文件中设置<code>spring.profile.active</code>属性为<code>dev</code>时，<code>-dev</code>的配置文件就会生效，像上面的配置则会以8081端口启动，即带<code>{profile}</code>的配置文件优先级高</p>
<ol start="3">
<li>在上面的情况下在进行扩展，当jar包外部也有一个<code>-dev</code>的配置文件时，在外部的优先级会更高。</li>
</ol>

    </article>
  </main>
  

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css"
    integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"
    integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp"
    crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"
    integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"
    crossorigin="anonymous"></script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    });
</script>





<script 
  src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"
  crossorigin="anonymous">
</script>
<script>
  mermaid.init(undefined, 'code.language-mermaid')
</script>




</div>


  <footer class="mt-8 mb-8">
  <div class="container mx-auto">
    <div class="mt-8 flex flex-col-reverse sm:flex-row sm:justify-between items-center">
      <div class="text-center sm:text-left">
        <p class="mt-0 text-sm"></p>
        <p class="mt-0 text-xs">
          Built with <a href="https://gohugo.io" target="_blank" rel="noopener noreferrer">Hugo</a> v0.143.1
          and <a href="https://github.com/mivinci/hugo-theme-minima" target="_blank" rel="noopener noreferrer">Minima</a>
        </p>
      </div>
      
      <p class="flex items-center mt-0">
        
          <a class="icon ml-1 mr-1" href="mailto:jarvis@apache.org" title="email">
          
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 21" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><path d="M22 6l-10 7L2 6"/></svg>
          
          </a>
        
          <a class="icon ml-1 mr-1" href="https://github.com/liunaijie" title="github">
          
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/></svg>
          
          </a>
        
          <a class="icon ml-1 mr-1" href="/index.xml" title="rss">
          
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 0 1 9 9M4 4a16 16 0 0 1 16 16"/><circle cx="5" cy="19" r="1"/></svg>
          
          </a>
        
      </p>
    </div>
  </div>
</footer>
</body>

</html>