<!DOCTYPE html>
<html lang="zh-CN">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>Flink学习(一)</title>
  
  <link rel="canonical" href="https://www.liunaijie.top/2022/12/03/Blog-Posts/publish/Flink%E5%AD%A6%E4%B9%A0(%E4%B8%80)/">
  
  <meta name="description" content="时间语义Flink中的时间有三种:  事件时间 Event Time.  事件真实发生的时间.  摄入时间 Ingestion time. 事件接入到Flink系统的时间 处理时间 Processing Time. 事件到到当前算子的时间举一个夸张点的例子: 有一条记录, 它与11:00:00这个时">
  
  
  <meta name="keywords" content="blog">
  
  <meta name="author" content="Jarvis">
  
  
  
  <meta property="og:site_name" content="J.A.R.V.I.S" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Flink学习(一)" />
  
  <meta property="og:description" content="时间语义Flink中的时间有三种:  事件时间 Event Time.  事件真实发生的时间.  摄入时间 Ingestion time. 事件接入到Flink系统的时间 处理时间 Processing Time. 事件到到当前算子的时间举一个夸张点的例子: 有一条记录, 它与11:00:00这个时">
  
  <meta property="og:url" content="https://www.liunaijie.top/2022/12/03/Blog-Posts/publish/Flink%E5%AD%A6%E4%B9%A0(%E4%B8%80)/" />

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Flink学习(一)">
  
  <meta name="twitter:description" content="时间语义Flink中的时间有三种:  事件时间 Event Time.  事件真实发生的时间.  摄入时间 Ingestion time. 事件接入到Flink系统的时间 处理时间 Processing Time. 事件到到当前算子的时间举一个夸张点的例子: 有一条记录, 它与11:00:00这个时">
  
  
  
  
  <meta name="twitter:url" content="https://www.liunaijie.top/2022/12/03/Blog-Posts/publish/Flink%E5%AD%A6%E4%B9%A0(%E4%B8%80)/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="/fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/jarvis.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

  
  <script src="/js/pic.min.js" defer></script>
  

  

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="J.A.R.V.I.S" type="application/atom+xml">
</head>

<body>
  <div class="container">
    <div class="row">
      <div>

        <div class="row">
  <div class="two columns" style="max-width: 50px">
    <h1 class="mt-2 mode">
      <div onclick=setDarkMode(true) id="darkBtn"></div>
      <div onclick=setDarkMode(false) id="lightBtn" class=hidden></div>
      <script >
        if (localStorage.getItem('preferredTheme') == 'dark') {
          setDarkMode(true)
        }
        function setDarkMode(isDark) {
          var darkBtn = document.getElementById('darkBtn')
          var lightBtn = document.getElementById('lightBtn')
          if (isDark) {
            lightBtn.style.display = "block"
            darkBtn.style.display = "none"
            localStorage.setItem('preferredTheme', 'dark');
          } else {
            lightBtn.style.display = "none"
            darkBtn.style.display = "block"
            localStorage.removeItem('preferredTheme');
          }
          document.body.classList.toggle("darkmode");
        }
      </script>
    </h1>
  </div>

  <div class="six columns ml-1">
    <h1 class="mt-2">
      Jarvis&#39;s Blog
    </h1>
  </div>

  <div class="twelve columns">
    <div class="row">
      <div class="nine columns left">
        
          
          <a href="/" class="ml">Home</a>
          
        
          
          <a href="/categories/publish/" class="ml">Publish</a>
          
        
          
          <a href="/about" class="ml">About</a>
          
        
          
          <a href="/atom.xml" class="ml">Rss</a>
          
        
      </div>
    </div>
    <hr style="margin-bottom: 2.6rem">
  </div>
</div>

        <div class="trans">
            <h2>Flink学习(一)</h2>

  <h1 id="时间语义"><a href="#时间语义" class="headerlink" title="时间语义"></a>时间语义</h1><p>Flink中的时间有三种:</p>
<ul>
<li>事件时间 Event Time.  事件真实发生的时间. </li>
<li>摄入时间 Ingestion time. 事件接入到Flink系统的时间</li>
<li>处理时间 Processing Time. 事件到到当前算子的时间<br>举一个夸张点的例子: 有一条记录, 它与<code>11:00:00</code>这个时间点产生. 我们的Flink系统在<code>12:00:00</code>这个时间点接入并进入第一个算子. 在Flink系统中又有很多个算子, 到达最后一个算子的时间为<code>13:00:00</code>.<br>那么在这种情况下: 事件时间是<code>11:00:00</code>. 这个是不会变的. 对于第一个算子而言, 这时的摄入时间和处理时间都为<code>12:00:00</code>.  对于最后一个算子而言, 这时这条时间的摄入时间为<code>12:00:00</code>. 处理时间为<code>13:00:00</code></li>
</ul>
<p><strong>设置时间语义</strong><br>我们需要在Job中设置执行时采用哪种时间语义. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime);</span><br><span class="line"></span><br><span class="line">env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime);</span><br></pre></td></tr></table></figure>


<h2 id="Processing-Time-Ingestion-Time"><a href="#Processing-Time-Ingestion-Time" class="headerlink" title="Processing Time &amp; Ingestion Time"></a>Processing Time &amp; Ingestion Time</h2><p>这两个时间都由Flink系统自己生成.<br>Processing Time是由每个算子自己生成, 实现起来非常简单, 延迟也是最小的. 但是由于每个时间都是获取的当前算子的时钟, 时钟可能不一致, 并且由于集群中不同机器的执行性能不同, 每个算子也有一定的耗时, 对于第N个算子来说的相同Processing Time, 可能到第N+1个算子上就会有改变. 因此Processing Time在时间窗口下的计算会有不确定性.<br>Ingestion Time是指事件到底Flink Source的时间. 一个事件在整个处理过程中都使用这个时间. 但是Ingestion Time也还是无法解决事件乱序问题.</p>
<p>这两个时间语义如果对事件进行重新消费, 也不能保证幂等性.</p>
<h2 id="Event-Time"><a href="#Event-Time" class="headerlink" title="Event Time"></a>Event Time</h2><p>事件时间是这个事件真实产生的时间, 发生时伴随其他信息一起写入到时间中.<br>但是由于在网络中的传输或其他问题, 可能导致事件到底Flink系统时发生乱序、迟到等现象.<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/20221204203917.svg"><br>真实情况中的数据大概如上图所示, 我们可以知道在Flink中进行处理的时间必然是大于等于事件发生的时间, 也就是事件都应该在这条红色虚线以下.<br>对于红色虚线上的点, 如上图的红色事件, 在12:10收到了12:20的事件, 这是一条未来的事件, 必须要对这条事件进行处理, 比如忽略或者对事件时间进行修改等, 不然会造成后续计算上的错误.<br>而对于蓝色的事件, 在12:10收到了11:50的事件, 这个事件是历史事件, 如果使用Flink作为批处理系统或者重置Offset后重刷历史, 这个都属于正常事件.<br>再来看一下事件时间发生在12:10的一系列事件, 它可以在12:10之后的任一时间到达Flink系统</p>
<h3 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h3><p>当使用Event Time来进行处理时, 通过上图可知某个时间点的数据会在未来的任意时间到达, 我们需要设置一个界限从而避免无限制的等待, 也就是需要知道我们接入的数据需要何时去触发计算.<br>watermark是一条特殊的记录, 从代码中可以看到它继承自<code>StreamElement</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Watermark</span> <span class="keyword">extends</span> <span class="title class_">StreamElement</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何生成Watermark"><a href="#如何生成Watermark" class="headerlink" title="如何生成Watermark:"></a>如何生成Watermark:</h4><p>在Flink中, 可以直接在Source算子上生成Watermark, 也可以在其他算子上生成. 推荐是在Source算子上直接生成, 因为这样可以更加准确.<br>在Source算子中可以调用SourceContext中的方法直接生成Watermark.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SourceFunction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Function</span>, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">run</span><span class="params">(SourceContext&lt;T&gt; ctx)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">interface</span> <span class="title class_">SourceContext</span>&lt;T&gt; &#123;  </span><br><span class="line">	  </span><br><span class="line">	    <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(T element)</span>;  </span><br><span class="line">	  </span><br><span class="line">	    <span class="keyword">void</span> <span class="title function_">collectWithTimestamp</span><span class="params">(T element, <span class="type">long</span> timestamp)</span>;  </span><br><span class="line">	  </span><br><span class="line">	    <span class="keyword">void</span> <span class="title function_">emitWatermark</span><span class="params">(Watermark mark)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>亦可在其他算子上调用<code>assignTimestampsAndWatermarks(watermarkStrategy)</code>生成, <code>watermarkStrategy</code>中接口中包含了很多的默认方法, 其中只有一个方法需要实现即<br><code>WatermarkGenerator&lt;T&gt; createWatermarkGenerator(WatermarkGeneratorSupplier.Context context);</code><br><code>WaermarkGenerator</code>的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WatermarkGenerator</span>&lt;T&gt; &#123;  </span><br><span class="line">	<span class="comment">// 每条事件调用一次</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(T event, <span class="type">long</span> eventTimestamp, WatermarkOutput output)</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 间隔ExecutionConfig setAutoWatermarkInterval(long interval)调用一次该方法</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可以看出, 这两个方法都可以实现watermark的生成. 但是watermark如果太多也不是一件很好的事情, 很用可能造成下游算子压力过大. 影响整体性能.</p>
<p>看一个Flink内部的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedOutOfOrdernessWatermarks</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">WatermarkGenerator</span>&lt;T&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The maximum timestamp encountered so far. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> maxTimestamp;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The maximum out-of-orderness that this watermark generator assumes. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> outOfOrdernessMillis;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">BoundedOutOfOrdernessWatermarks</span><span class="params">(Duration maxOutOfOrderness)</span> &#123;  </span><br><span class="line">        ... </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(T event, <span class="type">long</span> eventTimestamp, WatermarkOutput output)</span> &#123;  </span><br><span class="line">        maxTimestamp = Math.max(maxTimestamp, eventTimestamp);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> &#123;  </span><br><span class="line">        output.emitWatermark(<span class="keyword">new</span> <span class="title class_">Watermark</span>(maxTimestamp - outOfOrdernessMillis - <span class="number">1</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该实现中, 定义了一个超时时间, 在<code>onEvent</code>中并没有生成Watermark, 只是进行了内部的计算保存了一个当前时刻的最大事件时间, 而在<code>onPeriodicEmit</code>方法中才真正的生成Watermark<br>从该实现中, 我们可以看到Flink会定时得到一个Watermark, 这个Watermark的时间是当前最大事件时间减去一个容忍时间.<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/20221204203613.svg"><br>如果我们设置<code>maxOutOfOrderness</code>为10分钟, 在橙色事件(eventTime为12:10)到来时, 就会生成一个12:00的Watermark, 后续再接收到的紫色事件(12:00)则被认为是迟到事件, 不会参与到后续的计算中. 同样在黄色事件(eventTime为12:20)的事件到来时会生成一个12:10的Watermark, 后续再收到的小于12:10的事件都会被认为是迟到事件</p>
<p>当我们设置的窗口为滚动窗口, 时间大小为10分钟, 容忍时间为10分钟, 时间语义为事件时间时<br>当黄色事件(eventTime&#x3D;12:20)的事件到达时会生成一个12:10的Watermark, 这时会触发(12:00-12:10)窗口的计算(因为窗口大小为10分钟), 即计算图中黄色框中部分<br>当蓝色事件(eventTime&#x3D;12:30)的事件到达时会生成一个12:20的Watermark, 这时会计算图中蓝色框中的数据, 这部分的数据事件时间都是12:10~12:20.<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/20221204204255.svg"></p>
<h1 id="WindowAssigner"><a href="#WindowAssigner" class="headerlink" title="WindowAssigner"></a>WindowAssigner</h1><p>WindowAssigner的作用是对数据进行窗口的划分<br>来看下这个抽象类的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Collection&lt;W&gt; <span class="title function_">assignWindows</span><span class="params">(  </span></span><br><span class="line"><span class="params">        T element, <span class="type">long</span> timestamp, WindowAssignerContext context)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isEventTime</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Trigger&lt;T, W&gt; <span class="title function_">getDefaultTrigger</span><span class="params">(StreamExecutionEnvironment env)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> TypeSerializer&lt;W&gt; <span class="title function_">getWindowSerializer</span><span class="params">(ExecutionConfig executionConfig)</span>;    </span><br></pre></td></tr></table></figure>
<p>主要的方法为<code>assignWindow</code>, 对传入的element划分到一个或多个窗口内.<br>看几个主要的实现类:</p>
<ul>
<li><p>TumblingProcessingTimeWindows</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;TimeWindow&gt; <span class="title function_">assignWindows</span><span class="params">(  </span></span><br><span class="line"><span class="params">        Object element, <span class="type">long</span> timestamp, WindowAssignerContext context)</span> &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> context.getCurrentProcessingTime();  </span><br><span class="line">    <span class="keyword">if</span> (staggerOffset == <span class="literal">null</span>) &#123;  </span><br><span class="line">        staggerOffset =  </span><br><span class="line">                windowStagger.getStaggerOffset(context.getCurrentProcessingTime(), size);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span>  </span><br><span class="line">            TimeWindow.getWindowStartWithOffset(  </span><br><span class="line">                    now, (globalOffset + staggerOffset) % size, size);  </span><br><span class="line">    <span class="keyword">return</span> Collections.singletonList(<span class="keyword">new</span> <span class="title class_">TimeWindow</span>(start, start + size));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取当前的处理时间, 然后计算出当前窗口的开始时间start, 返回一个时间窗口</p>
</li>
<li><p>SlidingProcessingTimeWindows</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;TimeWindow&gt; <span class="title function_">assignWindows</span><span class="params">(  </span></span><br><span class="line"><span class="params">        Object element, <span class="type">long</span> timestamp, WindowAssignerContext context)</span> &#123;  </span><br><span class="line">    timestamp = context.getCurrentProcessingTime();  </span><br><span class="line">    List&lt;TimeWindow&gt; windows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;((<span class="type">int</span>) (size / slide));  </span><br><span class="line">    <span class="type">long</span> <span class="variable">lastStart</span> <span class="operator">=</span> TimeWindow.getWindowStartWithOffset(timestamp, offset, slide);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> lastStart; start &gt; timestamp - size; start -= slide) &#123;  </span><br><span class="line">        windows.add(<span class="keyword">new</span> <span class="title class_">TimeWindow</span>(start, start + size));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> windows;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取当前的处理时间, 然后根据size和slide计算出一个元素会处于多少个窗口, 然后计算并设置每个窗口的起止时间.</p>
</li>
</ul>
<h2 id="Flink中内置的一些窗口类型"><a href="#Flink中内置的一些窗口类型" class="headerlink" title="Flink中内置的一些窗口类型:"></a>Flink中内置的一些窗口类型:</h2><p>Flink里面的时间默认从1970年1月1日0点0分开始计算，可以手动指定offset</p>
<h3 id="滑动窗口（Sliding-Windows）"><a href="#滑动窗口（Sliding-Windows）" class="headerlink" title="滑动窗口（Sliding Windows）"></a>滑动窗口（Sliding Windows）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line"></span><br><span class="line">-- 手动指定offset</span><br><span class="line">.window(SlidingProcessingTimeWindows.of(Time.hours(<span class="number">12</span>), Time.hours(<span class="number">1</span>), Time.hours(-<span class="number">8</span>)))</span><br></pre></td></tr></table></figure>

<p>每5秒计算一次，每次计算的窗口大小为10秒</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/sliding-windows.svg"></p>
<h3 id="滚动窗口（Tumbling-Windows）"><a href="#滚动窗口（Tumbling-Windows）" class="headerlink" title="滚动窗口（Tumbling Windows）"></a>滚动窗口（Tumbling Windows）</h3><p>滚动窗口是一种特殊的滑动窗口，步长跟窗口大小一致</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">window</span>(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br></pre></td></tr></table></figure>

<p>每5秒计算一次，每次窗口大小为5秒<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/tumbling-windows.svg"></p>
<h3 id="会话窗口（Session-Windows）"><a href="#会话窗口（Session-Windows）" class="headerlink" title="会话窗口（Session Windows）"></a>会话窗口（Session Windows）</h3><p>进行keyBy之后，这组数据如果超过一定时长后没有新的数据产生则会触发窗口计算，这个窗口内的时间长度无法确定，数据数量也无法确定</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.keyBy(<span class="operator">&lt;</span>key selector<span class="operator">&gt;</span>)</span><br><span class="line">.<span class="keyword">window</span>(EventTimeSessionWindows.withGap(Time.minutes(<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>

<p>一个user如果超过1分钟没有数据则触发计算</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/session-windows.svg"></p>
<h1 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h1><p>Trigger的作用是来计算窗口内的元素是否需要被计算.<br>首先来看一下Trigger类的几个主要方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title function_">onElement</span><span class="params">(T element, <span class="type">long</span> timestamp, W window, TriggerContext ctx)</span>  </span><br><span class="line">        <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title function_">onProcessingTime</span><span class="params">(<span class="type">long</span> time, W window, TriggerContext ctx)</span>  </span><br><span class="line">        <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title function_">onEventTime</span><span class="params">(<span class="type">long</span> time, W window, TriggerContext ctx)</span>  </span><br><span class="line">        <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>
<p>这三个方法的作用从名称就可以看出来, 分别是当一条数据到来时调用, 当Processing Time触发时调用, 当Event Time触发时调用.<br>先看一下返回结果, 返回结果都是<code>TriggerResult</code>这个类. 这个类是一个枚举类, 包含了以下几个值:</p>
<ul>
<li>CONTINUE</li>
<li>FIRE</li>
<li>PURGE</li>
<li>FIRE_AND_PURGE<br>这几个枚举的作用表明了后续的计算方式.<br>如果是CONTINUE, 则表示不进行处理.<br>如果是FIRE, 则表示需要进行计算<br>如果是PURGE, 则表示需要清空当前窗口内的元素. <strong>不会触发计算</strong><br>如果是FIRE_AND_PURGE, 则表示计算的同时也清空窗口内的元素.</li>
</ul>
<p>Flink内置了以下几个内置的触发器:</p>
<ul>
<li>CountTrigger<br>当事件条数达到设定的阈值后触发</li>
<li>DeltaTrigger<br>预先给定一个DeltaFunction和阈值, 每条事件到达后都会根据DeltaFunction进行计算, 如果计算结果超过阈值, 则触发计算</li>
<li>ProcessingTimeTrigger<br>当处理时间超过窗口结束时间时触发</li>
<li>EventTimeTrigger<br>当事件事件(Watermark)超过窗口结束时间时触发</li>
<li>ContinuousProcessingTimeTrigger<br>给定一个时间间隔, 按照处理时间连续触发</li>
<li>ContinuousEventTimeTrigger<br>给定一个时间间隔, 按照事件事件连续触发</li>
<li>PurgingTrigger<br>包装其他的触发器, 使其触发之后, 清除窗口内的数据和状态</li>
</ul>
<p>通过代码来看一下具体的实现:<br>先来看一下CountTrigger的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> TriggerResult <span class="title function_">onEventTime</span><span class="params">(<span class="type">long</span> time, W window, TriggerContext ctx)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> TriggerResult.CONTINUE;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> TriggerResult <span class="title function_">onProcessingTime</span><span class="params">(<span class="type">long</span> time, W window, TriggerContext ctx)</span>  </span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">return</span> TriggerResult.CONTINUE;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> maxCount;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReducingStateDescriptor&lt;Long&gt; stateDesc =  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReducingStateDescriptor</span>&lt;&gt;(<span class="string">&quot;count&quot;</span>, <span class="keyword">new</span> <span class="title class_">Sum</span>(), LongSerializer.INSTANCE);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">CountTrigger</span><span class="params">(<span class="type">long</span> maxCount)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.maxCount = maxCount;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> TriggerResult <span class="title function_">onElement</span><span class="params">(Object element, <span class="type">long</span> timestamp, W window, TriggerContext ctx)</span>  </span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    ReducingState&lt;Long&gt; count = ctx.getPartitionedState(stateDesc);  </span><br><span class="line">    count.add(<span class="number">1L</span>);  </span><br><span class="line">    <span class="keyword">if</span> (count.get() &gt;= maxCount) &#123;  </span><br><span class="line">        count.clear();  </span><br><span class="line">        <span class="keyword">return</span> TriggerResult.FIRE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> TriggerResult.CONTINUE;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到在CountTrigger的<code>onEventTime</code>和<code>onProcessingTime</code>方法中都没有做任何逻辑处理, 直接返回CONTINUE.<br>在<code>onElement</code>方法中, 做了一个计数器, 当条数超过阈值后, 首先将计数器进行清零, 然后触发计算.<br>再看一下<code>ProcessingTimeTrigger</code>的代码具体实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TriggerResult <span class="title function_">onEventTime</span><span class="params">(<span class="type">long</span> time, TimeWindow window, TriggerContext ctx)</span>  </span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">return</span> TriggerResult.CONTINUE;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TriggerResult <span class="title function_">onElement</span><span class="params">(  </span></span><br><span class="line"><span class="params">        Object element, <span class="type">long</span> timestamp, TimeWindow window, TriggerContext ctx)</span> &#123;  </span><br><span class="line">    ctx.registerProcessingTimeTimer(window.maxTimestamp());  </span><br><span class="line">    <span class="keyword">return</span> TriggerResult.CONTINUE;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> TriggerResult <span class="title function_">onProcessingTime</span><span class="params">(<span class="type">long</span> time, TimeWindow window, TriggerContext ctx)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> TriggerResult.FIRE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>onEventTime</code>方法中不做任何处理, 直接返回<code>CONTINUE</code><br>在<code>onElement</code>中向context中注册一个<code>ProcessingTimeTimer</code>, 触发的事件为当前window的最大时间<br>当context中注册的ProcessingTimeTimer到时后, 会调用<code>onProcessingTime</code>方法, 这个方法直接返回<code>FIRE</code></p>
<h2 id="自定义触发器"><a href="#自定义触发器" class="headerlink" title="自定义触发器"></a>自定义触发器</h2><p>有时官方提供的这些触发器可能无法满足我们的需求, 我们可以自己来实现一些自定义的触发器, 从上面的几个源码中, 我们可以看到主要需要实现的三个方法.<code>onElement</code>, <code>onProcessingTime</code>,<code>onEventTime</code>.<br>假如我们需要实现一个如下的触发器: <em>每10s触发一次, 并且如果10s内的数据量超过100条,则进行触发, 触发后重新计时, 按照ProcessingTime处理</em><br>这个类似于上面两个<code>CountTrigger</code>与<code>ProcessingTimeTrigger</code>的结合. 可以写出如下的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomTrigger</span>&lt;W <span class="keyword">extends</span> <span class="title class_">Window</span>&gt; <span class="keyword">extends</span> <span class="title class_">Trigger</span>&lt;Object, W&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 触发的条数  </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> size;  </span><br><span class="line">   <span class="comment">// 触发的间隔时长  </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> interval;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;  </span><br><span class="line">   <span class="comment">// 条数计数器  </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReducingStateDescriptor&lt;Long&gt; countStateDesc = <span class="keyword">new</span> <span class="title class_">ReducingStateDescriptor</span>&lt;&gt;(<span class="string">&quot;count&quot;</span>, <span class="keyword">new</span> <span class="title class_">ReduceSum</span>(), LongSerializer.INSTANCE);  </span><br><span class="line">   <span class="comment">// 时间计数器，保存下一次触发的时间  </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReducingStateDescriptor&lt;Long&gt; timeStateDesc = <span class="keyword">new</span> <span class="title class_">ReducingStateDescriptor</span>&lt;&gt;(<span class="string">&quot;fire-interval&quot;</span>, <span class="keyword">new</span> <span class="title class_">ReduceMin</span>(), LongSerializer.INSTANCE);  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">CustomTrigger</span><span class="params">(<span class="type">long</span> size, <span class="type">long</span> interval)</span> &#123;  </span><br><span class="line">      <span class="built_in">this</span>.size = size;  </span><br><span class="line">      <span class="built_in">this</span>.interval = interval;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="keyword">public</span> TriggerResult <span class="title function_">onElement</span><span class="params">(Object element, <span class="type">long</span> timestamp, W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">      <span class="comment">// 获取当前的条数  </span></span><br><span class="line">      ReducingState&lt;Long&gt; count = ctx.getPartitionedState(countStateDesc);  </span><br><span class="line">      <span class="comment">// 获取下次的触发时间  </span></span><br><span class="line">      ReducingState&lt;Long&gt; fireTimestamp = ctx.getPartitionedState(timeStateDesc);  </span><br><span class="line">      <span class="comment">// 每条数据 counter + 1  </span></span><br><span class="line">      count.add(<span class="number">1L</span>);  </span><br><span class="line">      <span class="keyword">if</span> (count.get() &gt;= size) &#123;  </span><br><span class="line">         <span class="comment">// 满足条数的触发条件，先清零条数计数器  </span></span><br><span class="line">         count.clear();  </span><br><span class="line">         <span class="comment">// 满足条数时也需要清除时间的触发器  </span></span><br><span class="line">         ctx.deleteProcessingTimeTimer(fireTimestamp.get());  </span><br><span class="line">         fireTimestamp.clear();  </span><br><span class="line">         <span class="comment">// fire 触发计算  </span></span><br><span class="line">         <span class="keyword">return</span> TriggerResult.FIRE;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 如果条数没有达到阈值，并且下次触发时间为空，则注册下次的触发时间  </span></span><br><span class="line">      timestamp = ctx.getCurrentProcessingTime();  </span><br><span class="line">      <span class="keyword">if</span> (fireTimestamp.get() == <span class="literal">null</span>) &#123;  </span><br><span class="line">         <span class="type">long</span> <span class="variable">nextFireTimestamp</span> <span class="operator">=</span> timestamp + interval;  </span><br><span class="line">         ctx.registerProcessingTimeTimer(nextFireTimestamp);  </span><br><span class="line">         fireTimestamp.add(nextFireTimestamp);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> TriggerResult.CONTINUE;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="meta">@Override</span>  </span><br><span class="line">	<span class="keyword">public</span> TriggerResult <span class="title function_">onProcessingTime</span><span class="params">(<span class="type">long</span> time, W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">	   <span class="comment">// 获取当前的条数  </span></span><br><span class="line">	   ReducingState&lt;Long&gt; count = ctx.getPartitionedState(countStateDesc);  </span><br><span class="line">	   <span class="comment">// 获取设置的触发时间  </span></span><br><span class="line">	   ReducingState&lt;Long&gt; fireTimestamp = ctx.getPartitionedState(timeStateDesc);  </span><br><span class="line">	   count.clear();  </span><br><span class="line">	   fireTimestamp.clear();  </span><br><span class="line">	   <span class="keyword">return</span> TriggerResult.FIRE;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="keyword">public</span> TriggerResult <span class="title function_">onEventTime</span><span class="params">(<span class="type">long</span> time, W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">      <span class="keyword">return</span> TriggerResult.CONTINUE;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">(W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">      ReducingState&lt;Long&gt; fireTimestamp = ctx.getPartitionedState(timeStateDesc);  </span><br><span class="line">      ReducingState&lt;Long&gt; count = ctx.getPartitionedState(countStateDesc);  </span><br><span class="line">      <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> fireTimestamp.get();  </span><br><span class="line">      ctx.deleteProcessingTimeTimer(timestamp);  </span><br><span class="line">      fireTimestamp.clear();  </span><br><span class="line">      count.clear();  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canMerge</span><span class="params">()</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMerge</span><span class="params">(W window,  </span></span><br><span class="line"><span class="params">                  OnMergeContext ctx)</span> &#123;  </span><br><span class="line">      ctx.mergePartitionedState(timeStateDesc);  </span><br><span class="line">      ctx.mergePartitionedState(countStateDesc);  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReduceSum</span> <span class="keyword">implements</span> <span class="title class_">ReduceFunction</span>&lt;Long&gt; &#123;  </span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="keyword">public</span> Long <span class="title function_">reduce</span><span class="params">(Long value1, Long value2)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">      <span class="keyword">return</span> value1 + value2;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReduceMin</span> <span class="keyword">implements</span> <span class="title class_">ReduceFunction</span>&lt;Long&gt; &#123;  </span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="keyword">public</span> Long <span class="title function_">reduce</span><span class="params">(Long value1, Long value2)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">      <span class="keyword">return</span> Math.min(value1, value2);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的实现的两个方法:<code>onElement</code>, <code>onProcessingTime</code>.<br>在<code>onElement</code>方法中, 每一条记录进入条数计数器加一, 当超过阈值时清空两个状态变量, 同时取消下次的ProcessingTime触发时间. 如果没有达到阈值, 并且下次下次触发时间还未设置时, 计算得到下次触发时间注册到context中.<br>在<code>onProcessingTime</code>方法中, 清空两个状态变量后进行触发.</p>
<p>这里的返回结果都是FIRE, 不会清空窗口内的元素, 如果需要清空可以修改为<code>FIRE_AND_PURGE</code> 或者使用<code>PurgingTrigger</code>类来进行封装.<br>看一下<code>PurgingTrigger</code>的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Trigger&lt;T, W&gt; nestedTrigger;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">PurgingTrigger</span><span class="params">(Trigger&lt;T, W&gt; nestedTrigger)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.nestedTrigger = nestedTrigger;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> TriggerResult <span class="title function_">onElement</span><span class="params">(T element, <span class="type">long</span> timestamp, W window, TriggerContext ctx)</span>  </span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">TriggerResult</span> <span class="variable">triggerResult</span> <span class="operator">=</span> nestedTrigger.onElement(element, timestamp, window, ctx);  </span><br><span class="line">    <span class="keyword">return</span> triggerResult.isFire() ? TriggerResult.FIRE_AND_PURGE : triggerResult;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用包装的其他触发器, 如果是结果<code>FIRE</code>则返回<code>FIRE_AND_PURGE</code></p>
<h1 id="WindowOperator"><a href="#WindowOperator" class="headerlink" title="WindowOperator"></a>WindowOperator</h1><p>触发器Trigger只是返回了一个是否要触发计算的结果, 谁来调用了触发器以及进行后续的计算呢? 就是WindowOperator.<br>在<code>WindowedStream</code>中, 会进行WindowOperator的构建.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">WindowOperator</span><span class="params">(  </span></span><br><span class="line"><span class="params">        WindowAssigner&lt;? <span class="built_in">super</span> IN, W&gt; windowAssigner,  </span></span><br><span class="line"><span class="params">        TypeSerializer&lt;W&gt; windowSerializer,  </span></span><br><span class="line"><span class="params">        KeySelector&lt;IN, K&gt; keySelector,  </span></span><br><span class="line"><span class="params">        TypeSerializer&lt;K&gt; keySerializer,  </span></span><br><span class="line"><span class="params">        StateDescriptor&lt;? extends AppendingState&lt;IN, ACC&gt;, ?&gt; windowStateDescriptor,  </span></span><br><span class="line"><span class="params">        InternalWindowFunction&lt;ACC, OUT, K, W&gt; windowFunction,  </span></span><br><span class="line"><span class="params">        Trigger&lt;? <span class="built_in">super</span> IN, ? <span class="built_in">super</span> W&gt; trigger,  </span></span><br><span class="line"><span class="params">        <span class="type">long</span> allowedLateness,  </span></span><br><span class="line"><span class="params">        OutputTag&lt;IN&gt; lateDataOutputTag)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在WindowOperator类中, 可以看到包含了计算所需要的信息, 窗口如何进行划分, key的选择器, 窗口的计算函数, 触发器等.<br>在这个类中, 也有三个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(StreamRecord&lt;IN&gt; element)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEventTime</span><span class="params">(InternalTimer&lt;K, W&gt; timer)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProcessingTime</span><span class="params">(InternalTimer&lt;K, W&gt; timer)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>先来看一下<code>processElement</code>方法, 我们将源码简化一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(StreamRecord&lt;IN&gt; element)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="comment">// 先调用窗口划分器, 进行窗口的划分</span></span><br><span class="line">    <span class="keyword">final</span> Collection&lt;W&gt; elementWindows =  </span><br><span class="line">            windowAssigner.assignWindows(  </span><br><span class="line">                    element.getValue(), element.getTimestamp(), windowAssignerContext);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// if element is handled by none of assigned elementWindows  </span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSkippedElement</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> <span class="built_in">this</span>.&lt;K&gt;getKeyedStateBackend().getCurrentKey();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (windowAssigner <span class="keyword">instanceof</span> MergingWindowAssigner) &#123;  </span><br><span class="line">	      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (W window : elementWindows) &#123;  </span><br><span class="line">			<span class="comment">// 先判断窗口是否已经过期, 如果过期则不进行后续的处理</span></span><br><span class="line">            <span class="keyword">if</span> (isWindowLate(window)) &#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">		    ... </span><br><span class="line">			<span class="comment">// 调用触发器, 得到是否要计算的结果</span></span><br><span class="line">            <span class="type">TriggerResult</span> <span class="variable">triggerResult</span> <span class="operator">=</span> triggerContext.onElement(element);  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (triggerResult.isFire()) &#123;  </span><br><span class="line">	            <span class="comment">// 获取窗口的元素</span></span><br><span class="line">                <span class="type">ACC</span> <span class="variable">contents</span> <span class="operator">=</span> windowState.get();  </span><br><span class="line">                <span class="keyword">if</span> (contents == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// 进行计算</span></span><br><span class="line">                emitWindowContents(window, contents);  </span><br><span class="line">            &#125;  </span><br><span class="line">			  </span><br><span class="line">            <span class="keyword">if</span> (triggerResult.isPurge()) &#123;  </span><br><span class="line">                windowState.clear();  </span><br><span class="line">            &#125;  </span><br><span class="line">            registerCleanupTimer(window);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">	...  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isWindowLate</span><span class="params">(W window)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (windowAssigner.isEventTime()  </span><br><span class="line">            &amp;&amp; (cleanupTime(window) &lt;= internalTimerService.currentWatermark()));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">emitWindowContents</span><span class="params">(W window, ACC contents)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    timestampedCollector.setAbsoluteTimestamp(window.maxTimestamp());  </span><br><span class="line">    processContext.window = window;  </span><br><span class="line">    <span class="comment">// 调用函数进行计算</span></span><br><span class="line">    userFunction.process(  </span><br><span class="line">            triggerContext.key, window, processContext, contents, timestampedCollector);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<h2>Tags: </h2>
  <p><a class="classtest-link" href="/tags/flink/" rel="tag">flink</a> — 2022年12月4日</p>
  

  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>

        </div>
        <!-- <div class="row mt-2">
  <h3>Search</h3>
  <div><input id="search-text" title="search" class="search-text" type="text" placeholder="search......"></div>
  <div style="margin-top: 1.5rem;">
    <ul id="result"></ul>
  </div>
</div> -->
        <div class="row mt-2">
  
    <div class="eight columns">
      <p id="madewith">Made with ❤ and
        <a class="footer-link icon" href="https://hexo.io" target="_blank" style="text-decoration: none;" rel="noreferrer" aria-label="Hexo.io">
        <svg class="hexo svg-hov" width="14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Hexo.js</title><path d="M12 .007L1.57 6.056V18.05L12 23.995l10.43-6.049V5.952L12 .007zm4.798 17.105l-.939.521-.939-.521V12.94H9.08v4.172l-.94.521-.938-.521V6.89l.939-.521.939.521v4.172h5.84V6.89l.94-.521.938.521v10.222z"/></svg>
        </a>
        
    </div>

    <!-- Sepcial thanks to https://simpleicons.org/ for the icons -->
    <div class="four columns mb-3 posisi" >
      
      <a class="ml-0 footer-link icon" href="https://github.com/liunaijie" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="GitHub">
        <svg class="github svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      </a>
      

      

      

      

      
      
        <a class="ml-0 footer-link icon" href="mailto:jarvis@apache.org" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="Email">
          <svg class="email svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Email</title><path d="M12 12.713l11.985-7.99c-.01-.01-11.985-7.723-11.985-7.723s-11.975 7.713-11.985 7.723l11.985 7.99zm0 2.287l-12-8v14h24v-14l-12 8z"/></svg>
        </a>
        
    </div>
  
</div>

      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>

  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>