<!DOCTYPE html>
<html lang="zh-CN">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>SeaTunnel源码解析-(二)Zeta引擎源码讲解</title>
  
  <link rel="canonical" href="https://www.liunaijie.top/2024/11/24/Blog-Posts/publish/SeaTunnel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-(%E4%BA%8C)Zeta%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/">
  
  <meta name="description" content="省流这篇文章以seatunnel 2.3.6版本，讲解了一个zeta引擎的一个任务是如何从提交到运行的全流程，希望通过这篇文档，对刚刚上手seatunnel的朋友提供一些帮助。 这篇文章将从  seatunnel server端的初始化 client端的任务提交流程 server端的接收到任务的执行">
  
  
  <meta name="keywords" content="blog">
  
  <meta name="author" content="Jarvis">
  
  
  
  <meta property="og:site_name" content="J.A.R.V.I.S" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="SeaTunnel源码解析-(二)Zeta引擎源码讲解" />
  
  <meta property="og:description" content="省流这篇文章以seatunnel 2.3.6版本，讲解了一个zeta引擎的一个任务是如何从提交到运行的全流程，希望通过这篇文档，对刚刚上手seatunnel的朋友提供一些帮助。 这篇文章将从  seatunnel server端的初始化 client端的任务提交流程 server端的接收到任务的执行">
  
  <meta property="og:url" content="https://www.liunaijie.top/2024/11/24/Blog-Posts/publish/SeaTunnel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-(%E4%BA%8C)Zeta%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/" />

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="SeaTunnel源码解析-(二)Zeta引擎源码讲解">
  
  <meta name="twitter:description" content="省流这篇文章以seatunnel 2.3.6版本，讲解了一个zeta引擎的一个任务是如何从提交到运行的全流程，希望通过这篇文档，对刚刚上手seatunnel的朋友提供一些帮助。 这篇文章将从  seatunnel server端的初始化 client端的任务提交流程 server端的接收到任务的执行">
  
  
  
  
  <meta name="twitter:url" content="https://www.liunaijie.top/2024/11/24/Blog-Posts/publish/SeaTunnel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-(%E4%BA%8C)Zeta%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="/fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/jarvis.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

  
  <script src="/js/pic.min.js" defer></script>
  

  

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="J.A.R.V.I.S" type="application/atom+xml">
</head>

<body>
  <div class="container">
    <div class="row">
      <div>

        <div class="row">
  <div class="two columns" style="max-width: 50px">
    <h1 class="mt-2 mode">
      <div onclick=setDarkMode(true) id="darkBtn"></div>
      <div onclick=setDarkMode(false) id="lightBtn" class=hidden></div>
      <script >
        if (localStorage.getItem('preferredTheme') == 'dark') {
          setDarkMode(true)
        }
        function setDarkMode(isDark) {
          var darkBtn = document.getElementById('darkBtn')
          var lightBtn = document.getElementById('lightBtn')
          if (isDark) {
            lightBtn.style.display = "block"
            darkBtn.style.display = "none"
            localStorage.setItem('preferredTheme', 'dark');
          } else {
            lightBtn.style.display = "none"
            darkBtn.style.display = "block"
            localStorage.removeItem('preferredTheme');
          }
          document.body.classList.toggle("darkmode");
        }
      </script>
    </h1>
  </div>

  <div class="six columns ml-1">
    <h1 class="mt-2">
      Jarvis&#39;s Blog
    </h1>
  </div>

  <div class="twelve columns">
    <div class="row">
      <div class="nine columns left">
        
          
          <a href="/" class="ml">Home</a>
          
        
          
          <a href="/categories/publish/" class="ml">Publish</a>
          
        
          
          <a href="/about" class="ml">About</a>
          
        
          
          <a href="/atom.xml" class="ml">Rss</a>
          
        
      </div>
    </div>
    <hr style="margin-bottom: 2.6rem">
  </div>
</div>

        <div class="trans">
            <h2>SeaTunnel源码解析-(二)Zeta引擎源码讲解</h2>

  <h1 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h1><p>这篇文章以seatunnel 2.3.6版本，讲解了一个zeta引擎的一个任务是如何从提交到运行的全流程，希望通过这篇文档，对刚刚上手seatunnel的朋友提供一些帮助。</p>
<p>这篇文章将从</p>
<ol>
<li>seatunnel server端的初始化</li>
<li>client端的任务提交流程</li>
<li>server端的接收到任务的执行流程<br>三部分来记录下一个任务的整体流程</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/seatunnel/issues/2269">[ST-Engine][Design] The Design of LogicalPlan to PhysicalPlan</a></li>
</ul>
<h1 id="集群拓扑"><a href="#集群拓扑" class="headerlink" title="集群拓扑"></a>集群拓扑</h1><p>首先从整体了解下SeaTunnel的Zeta引擎架构， SeaTunnel是基于<a target="_blank" rel="noopener" href="https://hazelcast.com/">hazelcast</a>来实现的分布式集群通信</p>
<p>在2.3.6版本之后， 集群中的节点可以被分配为master或worker节点， 从而将调度与执行分开， 避免master节点的负载过高从而出现问题。</p>
<p>并且2.3.6版本还添加了一个功能是， 可以对每个节点添加<code>tag</code>属性， 当提交任务时可以通过<code>tag</code>来选择任务将要运行的节点， 从而达到资源隔离的目的（2.3.6版本有问题，2.3.8版本中进行了修复，如果需要使用此功能请使用2.3.8版本）。</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/34e19e5696c8ac0e639fc9350b58662afdca222d/Pasted%20image%2020240821105221.png"></p>
<p>集群的服务端分为master和worker节点， master节点负责接收请求， 逻辑计划生成， 分配任务等（与之前的版本相比，会多了几个backup节点，但是对于集群稳定性来说是一个挺大的提升）。<br>而worker节点则只负责执行任务， 也就是数据的读取和写入。<br>提交任务时可以创建hazelcast的客户端连接集群来进行通信， 或者使用restapi来进行通信。</p>
<h1 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h1><p>当我们对集群的整体架构有个大致的了解后， 我们再来具体了解下具体的流程</p>
<p>首先看下server端的启动过程。 server端的启动命令为： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sh bin/seatunnel-cluster.sh -d -r &lt;node role type&gt;</span><br></pre></td></tr></table></figure>

<p>当我们查看这个脚本的内容后就会发现， 这个脚本最终的执行命令为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp seatunnel-starter.jar org.apache.seatunnel.core.starter.seatunnel.SeaTunnelServer &lt;other_java_jvm_config_and_args&gt;</span><br></pre></td></tr></table></figure>
<p>我们查看这个<code>starter.seatunnel.SeaTunnelServer</code>的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeaTunnelServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CommandException &#123;</span><br><span class="line">        <span class="type">ServerCommandArgs</span> <span class="variable">serverCommandArgs</span> <span class="operator">=</span></span><br><span class="line">                CommandLineUtils.parse(</span><br><span class="line">                        args,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ServerCommandArgs</span>(),</span><br><span class="line">                        EngineType.SEATUNNEL.getStarterShellName(),</span><br><span class="line">                        <span class="literal">true</span>);</span><br><span class="line">        SeaTunnel.run(serverCommandArgs.buildCommand());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是使用了<code>JCommander</code>来解析用户传递的参数并构建并运行<code>Command</code>， <code>serverCommandArgs.buildCommand</code>返回的类为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerExecuteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span>&lt;ServerCommandArgs&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerCommandArgs serverCommandArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerExecuteCommand</span><span class="params">(ServerCommandArgs serverCommandArgs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverCommandArgs = serverCommandArgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SeaTunnelConfig</span> <span class="variable">seaTunnelConfig</span> <span class="operator">=</span> ConfigProvider.locateAndGetSeaTunnelConfig();</span><br><span class="line">        <span class="type">String</span> <span class="variable">clusterRole</span> <span class="operator">=</span> <span class="built_in">this</span>.serverCommandArgs.getClusterRole();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(clusterRole)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (EngineConfig.ClusterRole.MASTER.toString().equalsIgnoreCase(clusterRole)) &#123;</span><br><span class="line">                seaTunnelConfig.getEngineConfig().setClusterRole(EngineConfig.ClusterRole.MASTER);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EngineConfig.ClusterRole.WORKER.toString().equalsIgnoreCase(clusterRole)) &#123;</span><br><span class="line">                seaTunnelConfig.getEngineConfig().setClusterRole(EngineConfig.ClusterRole.WORKER);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// in hazelcast lite node will not store IMap data.</span></span><br><span class="line">                seaTunnelConfig.getHazelcastConfig().setLiteMember(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SeaTunnelEngineException</span>(<span class="string">&quot;Not supported cluster role: &quot;</span> + clusterRole);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            seaTunnelConfig</span><br><span class="line">                    .getEngineConfig()</span><br><span class="line">                    .setClusterRole(EngineConfig.ClusterRole.MASTER_AND_WORKER);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HazelcastInstanceFactory.newHazelcastInstance(</span><br><span class="line">                seaTunnelConfig.getHazelcastConfig(),</span><br><span class="line">                Thread.currentThread().getName(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SeaTunnelNodeContext</span>(seaTunnelConfig));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里会根据配置的角色类型来修改配置信息。 当是worker节点时，将hazelcast节点的类型设置为<code>lite member</code>，在hazelcast中lite member是不进行数据存储的</p>
<p>然后会创建了一个<code>hazelcast</code>实例， 并且传递了<code>SeaTunnelNodeContext</code>实例以及读取并修改的配置信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeaTunnelNodeContext</span> <span class="keyword">extends</span> <span class="title class_">DefaultNodeContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SeaTunnelConfig seaTunnelConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeaTunnelNodeContext</span><span class="params">(<span class="meta">@NonNull</span> SeaTunnelConfig seaTunnelConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seaTunnelConfig = seaTunnelConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NodeExtension <span class="title function_">createNodeExtension</span><span class="params">(<span class="meta">@NonNull</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.apache.seatunnel.engine.server.NodeExtension(node, seaTunnelConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Joiner <span class="title function_">createJoiner</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">JoinConfig</span> <span class="variable">join</span> <span class="operator">=</span></span><br><span class="line">                getActiveMemberNetworkConfig(seaTunnelConfig.getHazelcastConfig()).getJoin();</span><br><span class="line">        join.verify();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.shouldUseMulticastJoiner(join) &amp;&amp; node.multicastService != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>.createJoiner(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (join.getTcpIpConfig().isEnabled()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Using LiteNodeDropOutTcpIpJoiner TCP/IP discovery&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LiteNodeDropOutTcpIpJoiner</span>(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getProperties().getBoolean(DISCOVERY_SPI_ENABLED)</span><br><span class="line">                || isAnyAliasedConfigEnabled(join)</span><br><span class="line">                || join.isAutoDetectionEnabled()) &#123;</span><br><span class="line">            <span class="built_in">super</span>.createJoiner(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAnyAliasedConfigEnabled</span><span class="params">(JoinConfig join)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !AliasedDiscoveryConfigUtils.createDiscoveryStrategyConfigs(join).isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">usePublicAddress</span><span class="params">(JoinConfig join, Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node.getProperties().getBoolean(DISCOVERY_SPI_PUBLIC_IP_ENABLED)</span><br><span class="line">                || allUsePublicAddress(</span><br><span class="line">                        AliasedDiscoveryConfigUtils.aliasedDiscoveryConfigsFrom(join));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>SeaTunnelNodeContext</code>中覆盖了<code>createNodeExtension</code>方法， 将使用<code>engine.server.NodeExtension</code>类， 这个类的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeExtension</span> <span class="keyword">extends</span> <span class="title class_">DefaultNodeExtension</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NodeExtensionCommon extCommon;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NodeExtension</span><span class="params">(<span class="meta">@NonNull</span> Node node, <span class="meta">@NonNull</span> SeaTunnelConfig seaTunnelConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(node);</span><br><span class="line">        extCommon = <span class="keyword">new</span> <span class="title class_">NodeExtensionCommon</span>(node, <span class="keyword">new</span> <span class="title class_">SeaTunnelServer</span>(seaTunnelConfig));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Get Config from Node here</span></span><br><span class="line">        <span class="built_in">super</span>.beforeStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.afterStart();</span><br><span class="line">        extCommon.afterStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeClusterStateChange</span><span class="params">(</span></span><br><span class="line"><span class="params">            ClusterState currState, ClusterState requestedState, <span class="type">boolean</span> isTransient)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.beforeClusterStateChange(currState, requestedState, isTransient);</span><br><span class="line">        extCommon.beforeClusterStateChange(requestedState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClusterStateChange</span><span class="params">(ClusterState newState, <span class="type">boolean</span> isTransient)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onClusterStateChange(newState, isTransient);</span><br><span class="line">        extCommon.onClusterStateChange(newState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">createExtensionServices</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> extCommon.createExtensionServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextCommandService <span class="title function_">createTextCommandService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TextCommandServiceImpl</span>(node) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                register(HTTP_GET, <span class="keyword">new</span> <span class="title class_">Log4j2HttpGetCommandProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">                register(HTTP_POST, <span class="keyword">new</span> <span class="title class_">Log4j2HttpPostCommandProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">                register(HTTP_GET, <span class="keyword">new</span> <span class="title class_">RestHttpGetCommandProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">                register(HTTP_POST, <span class="keyword">new</span> <span class="title class_">RestHttpPostCommandProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printNodeInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        extCommon.printNodeInfo(systemLogger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个代码中， 我们可以看到在构造方法中， 初始化了<code>SeaTunnelServer</code>这个类， 而这个类与最开始的类是同名的， 但是在不同的包下， 这个类的完整类名为： <code>org.apache.seatunnel.engine.server.SeaTunnelServer</code></p>
<p>我们看下这个类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeaTunnelServer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ManagedService</span>, MembershipAwareService, LiveOperationsTracker &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ILogger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> Logger.getLogger(SeaTunnelServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVICE_NAME</span> <span class="operator">=</span> <span class="string">&quot;st:impl:seaTunnelServer&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NodeEngineImpl nodeEngine;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LiveOperationRegistry liveOperationRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SlotService slotService;</span><br><span class="line">    <span class="keyword">private</span> TaskExecutionService taskExecutionService;</span><br><span class="line">    <span class="keyword">private</span> ClassLoaderService classLoaderService;</span><br><span class="line">    <span class="keyword">private</span> CoordinatorService coordinatorService;</span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService monitorService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span> <span class="keyword">private</span> SeaTunnelHealthMonitor seaTunnelHealthMonitor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SeaTunnelConfig seaTunnelConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeaTunnelServer</span><span class="params">(<span class="meta">@NonNull</span> SeaTunnelConfig seaTunnelConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liveOperationRegistry = <span class="keyword">new</span> <span class="title class_">LiveOperationRegistry</span>();</span><br><span class="line">        <span class="built_in">this</span>.seaTunnelConfig = seaTunnelConfig;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;SeaTunnel server start...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(NodeEngine engine, Properties hzProperties)</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">        <span class="keyword">if</span> (EngineConfig.ClusterRole.MASTER_AND_WORKER.ordinal()</span><br><span class="line">                == seaTunnelConfig.getEngineConfig().getClusterRole().ordinal()) &#123;</span><br><span class="line">            startWorker();</span><br><span class="line">            startMaster();</span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EngineConfig.ClusterRole.WORKER.ordinal()</span><br><span class="line">                == seaTunnelConfig.getEngineConfig().getClusterRole().ordinal()) &#123;</span><br><span class="line">            startWorker();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startMaster();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类是SeaTunnel Server端的核心代码， 在这个类中会根据节点的角色来启动相关的组件。<br>稍微总结下seatunnel的流程：<br>SeaTunnel是借助于hazelcast的基础能力， 来实现集群端的组网， 并调用启动核心的代码。对于这一块有想深入了解的朋友可以去看下hazelcast的相关内容，这里仅仅列出了调用路径。<br>按照顺序所加载调用的类为</p>
<ol>
<li>starter.SeaTunnelServer</li>
<li>ServerExecutreCommand</li>
<li>SeaTunnelNodeContext</li>
<li>NodeExtension</li>
<li>server.SeaTunnelServer</li>
</ol>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/4b36c4dacf642e23cb1a2b8b0a63fdacd2574a49/Pasted%20image%2020240821111210.png"></p>
<p>接下来再来详细看下master节点以及worker节点中所创建的组件</p>
<h2 id="master相关组件"><a href="#master相关组件" class="headerlink" title="master相关组件"></a>master相关组件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startMaster</span><span class="params">()</span> &#123;</span><br><span class="line">    coordinatorService =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CoordinatorService</span>(nodeEngine, <span class="built_in">this</span>, seaTunnelConfig.getEngineConfig());</span><br><span class="line">    monitorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    monitorService.scheduleAtFixedRate(</span><br><span class="line">            <span class="built_in">this</span>::printExecutionInfo,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            seaTunnelConfig.getEngineConfig().getPrintExecutionInfoInterval(),</span><br><span class="line">            TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法内，可以看到一个初始化了两个组件</p>
<ul>
<li><code>coordinatorService</code> 协调器组件</li>
<li><code>monitorService</code> 监控组件<br>监控组件所做的事情，在这个方法内，也可以看到，就是周期性的打印信息。</li>
</ul>
<h3 id="CoordinatorService"><a href="#CoordinatorService" class="headerlink" title="CoordinatorService"></a>CoordinatorService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CoordinatorService</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> NodeEngineImpl nodeEngine,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> SeaTunnelServer seaTunnelServer,</span></span><br><span class="line"><span class="params">        EngineConfig engineConfig)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nodeEngine = nodeEngine;</span><br><span class="line">    <span class="built_in">this</span>.logger = nodeEngine.getLogger(getClass());</span><br><span class="line">    <span class="built_in">this</span>.executorService =</span><br><span class="line">            Executors.newCachedThreadPool(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                            .setNameFormat(<span class="string">&quot;seatunnel-coordinator-service-%d&quot;</span>)</span><br><span class="line">                            .build());</span><br><span class="line">    <span class="built_in">this</span>.seaTunnelServer = seaTunnelServer;</span><br><span class="line">    <span class="built_in">this</span>.engineConfig = engineConfig;</span><br><span class="line">    masterActiveListener = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    masterActiveListener.scheduleAtFixedRate(</span><br><span class="line">            <span class="built_in">this</span>::checkNewActiveMaster, <span class="number">0</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkNewActiveMaster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isActive &amp;&amp; <span class="built_in">this</span>.seaTunnelServer.isMasterNode()) &#123;</span><br><span class="line">            logger.info(</span><br><span class="line">                    <span class="string">&quot;This node become a new active master node, begin init coordinator service&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.executorService.isShutdown()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.executorService =</span><br><span class="line">                        Executors.newCachedThreadPool(</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                                        .setNameFormat(<span class="string">&quot;seatunnel-coordinator-service-%d&quot;</span>)</span><br><span class="line">                                        .build());</span><br><span class="line">            &#125;</span><br><span class="line">            initCoordinatorService();</span><br><span class="line">            isActive = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isActive &amp;&amp; !<span class="built_in">this</span>.seaTunnelServer.isMasterNode()) &#123;</span><br><span class="line">            isActive = <span class="literal">false</span>;</span><br><span class="line">            logger.info(</span><br><span class="line">                    <span class="string">&quot;This node become leave active master node, begin clear coordinator service&quot;</span>);</span><br><span class="line">            clearCoordinatorService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        isActive = <span class="literal">false</span>;</span><br><span class="line">        logger.severe(ExceptionUtils.getMessage(e));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SeaTunnelEngineException</span>(<span class="string">&quot;check new active master error, stop loop&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>协调器组件启动之后，会创建一个线程定时检测自身与集群状态，检查是否需要进行切换。<br>状态检查有两种</p>
<ol>
<li>当本地标记不是master，但在hazelcast集群中被选举为master时<br>调用<code>initCoordinatorService()</code>来进行状态的初始化，同时修改本地状态标记信息</li>
<li>当本地标记自身为master，但是在集群中已经不是master时<br>状态清理</li>
</ol>
<p>我们看下<code>initCoordinatorService()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initCoordinatorService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从hazelcast中获取分布式IMAP</span></span><br><span class="line">    runningJobInfoIMap =</span><br><span class="line">            nodeEngine.getHazelcastInstance().getMap(Constant.IMAP_RUNNING_JOB_INFO);</span><br><span class="line">    runningJobStateIMap =</span><br><span class="line">            nodeEngine.getHazelcastInstance().getMap(Constant.IMAP_RUNNING_JOB_STATE);</span><br><span class="line">    runningJobStateTimestampsIMap =</span><br><span class="line">            nodeEngine.getHazelcastInstance().getMap(Constant.IMAP_STATE_TIMESTAMPS);</span><br><span class="line">    ownedSlotProfilesIMap =</span><br><span class="line">            nodeEngine.getHazelcastInstance().getMap(Constant.IMAP_OWNED_SLOT_PROFILES);</span><br><span class="line">    metricsImap = nodeEngine.getHazelcastInstance().getMap(Constant.IMAP_RUNNING_JOB_METRICS);</span><br><span class="line">    <span class="comment">// 初始化JobHistoryService</span></span><br><span class="line">    jobHistoryService =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">JobHistoryService</span>(</span><br><span class="line">                    runningJobStateIMap,</span><br><span class="line">                    logger,</span><br><span class="line">                    runningJobMasterMap,</span><br><span class="line">                    nodeEngine.getHazelcastInstance().getMap(Constant.IMAP_FINISHED_JOB_STATE),</span><br><span class="line">                    nodeEngine</span><br><span class="line">                            .getHazelcastInstance()</span><br><span class="line">                            .getMap(Constant.IMAP_FINISHED_JOB_METRICS),</span><br><span class="line">                    nodeEngine</span><br><span class="line">                            .getHazelcastInstance()</span><br><span class="line">                            .getMap(Constant.IMAP_FINISHED_JOB_VERTEX_INFO),</span><br><span class="line">                    engineConfig.getHistoryJobExpireMinutes());</span><br><span class="line">    <span class="comment">// 初始化EventProcess, 用于发送事件到其他服务</span></span><br><span class="line">    eventProcessor =</span><br><span class="line">            createJobEventProcessor(</span><br><span class="line">                    engineConfig.getEventReportHttpApi(),</span><br><span class="line">                    engineConfig.getEventReportHttpHeaders(),</span><br><span class="line">                    nodeEngine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the user has configured the connector package service, create it  on the master node.</span></span><br><span class="line">    <span class="type">ConnectorJarStorageConfig</span> <span class="variable">connectorJarStorageConfig</span> <span class="operator">=</span></span><br><span class="line">            engineConfig.getConnectorJarStorageConfig();</span><br><span class="line">    <span class="keyword">if</span> (connectorJarStorageConfig.getEnable()) &#123;</span><br><span class="line">        connectorPackageService = <span class="keyword">new</span> <span class="title class_">ConnectorPackageService</span>(seaTunnelServer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 集群恢复后, 尝试恢复之前的历史任务</span></span><br><span class="line">    restoreAllJobFromMasterNodeSwitchFuture =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PassiveCompletableFuture</span>(</span><br><span class="line">                    CompletableFuture.runAsync(</span><br><span class="line">                            <span class="built_in">this</span>::restoreAllRunningJobFromMasterNodeSwitch, executorService));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在coordinatorservice中， 会拉取分布式MAP， 这个数据结构是hazelcast的一个数据结构， 可以认为是在集群中数据一致的一个MAP。 在seatunnel中， 使用这个结构来存储任务信息， slot信息等。</p>
<p>在这里还会创建<code>EventProcessor</code>， 这个类是用来将事件通知到其他服务， 比如任务失败， 可以发送信息到配置的接口中， 实现事件推送。</p>
<p>最后， 由于节点启动， 可能是集群异常重启， 或者节点切换， 这时需要恢复历史运行的任务， 那么就会从刚刚获取到的IMAP中获取到之前正在跑的任务列表， 然后尝试进行恢复。<br>这里的IMAP信息可以开启持久化将信息存储到HDFS等文件系统中， 这样可以在系统完全重启后仍然能够读取到之前的任务状态并进行恢复。</p>
<p>在<code>CoordinatorService</code>中运行的组件有：</p>
<ul>
<li>executorService （所有可能被选举为master的节点）</li>
<li>masterActiveListener（所有可能被选举为master的节点）</li>
<li>jobHistoryService （master节点）</li>
<li>eventProcessor （master节点）<br><img src="https://raw.githubusercontent.com/liunaijie/images/0952cb7c3fc3e3b66cba6cf4b9b0005577544778/Pasted%20image%2020240821111742.png">  –  TODO 修改图片，添加executorService<br>接下来再看下worker节点所启动的组件</li>
</ul>
<h2 id="worker节点"><a href="#worker节点" class="headerlink" title="worker节点"></a>worker节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startWorker</span><span class="params">()</span> &#123;</span><br><span class="line">    taskExecutionService =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TaskExecutionService</span>(</span><br><span class="line">                    classLoaderService, nodeEngine, nodeEngine.getProperties());</span><br><span class="line">    nodeEngine.getMetricsRegistry().registerDynamicMetricsProvider(taskExecutionService);</span><br><span class="line">    taskExecutionService.start();</span><br><span class="line">    getSlotService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SlotService <span class="title function_">getSlotService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (slotService == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slotService == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">SlotService</span> <span class="variable">service</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">DefaultSlotService</span>(</span><br><span class="line">                                nodeEngine,</span><br><span class="line">                                taskExecutionService,</span><br><span class="line">                                seaTunnelConfig.getEngineConfig().getSlotServiceConfig());</span><br><span class="line">                service.init();</span><br><span class="line">                slotService = service;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slotService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到在<code>startWorker</code>方法中， 也会初始化两个组件</p>
<ul>
<li><code>taskExecutionService</code> 任务执行线程池</li>
<li><code>slotService</code>                  任务资源管理</li>
</ul>
<h3 id="SlotService"><a href="#SlotService" class="headerlink" title="SlotService"></a>SlotService</h3><p>先来看下<code>SlotService</code>的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    initStatus = <span class="literal">true</span>;</span><br><span class="line">    slotServiceSequence = UUID.randomUUID().toString();</span><br><span class="line">    contexts = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    assignedSlots = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    unassignedSlots = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    unassignedResource = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ResourceProfile</span>());</span><br><span class="line">    assignedResource = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ResourceProfile</span>());</span><br><span class="line">    scheduledExecutorService =</span><br><span class="line">            Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">                    r -&gt;</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">                                    r,</span><br><span class="line">                                    String.format(</span><br><span class="line">                                            <span class="string">&quot;hz.%s.seaTunnel.slotService.thread&quot;</span>,</span><br><span class="line">                                            nodeEngine.getHazelcastInstance().getName())));</span><br><span class="line">    <span class="keyword">if</span> (!config.isDynamicSlot()) &#123;</span><br><span class="line">        initFixedSlots();</span><br><span class="line">    &#125;</span><br><span class="line">    unassignedResource.set(getNodeResource());</span><br><span class="line">    scheduledExecutorService.scheduleAtFixedRate(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LOGGER.fine(</span><br><span class="line">                            <span class="string">&quot;start send heartbeat to resource manager, this address: &quot;</span></span><br><span class="line">                                    + nodeEngine.getClusterService().getThisAddress());</span><br><span class="line">                    sendToMaster(<span class="keyword">new</span> <span class="title class_">WorkerHeartbeatOperation</span>(getWorkerProfile())).join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOGGER.warning(</span><br><span class="line">                            <span class="string">&quot;failed send heartbeat to resource manager, will retry later. this address: &quot;</span></span><br><span class="line">                                    + nodeEngine.getClusterService().getThisAddress());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            DEFAULT_HEARTBEAT_TIMEOUT,</span><br><span class="line">            TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SeaTunnel中，会有一个<strong>动态slot(DynamicSlot)</strong> 的概念。<br>如果设置为<code>true</code>， 则每个节点不再有Slot数量的限制，可以提交任意数量的任务到此节点上。<br>如果设置为固定数量的<code>slot</code>， 那么该节点仅能接受这些<code>slot</code>数量的任务运行。</p>
<blockquote>
<p>两者的区别在于你的同步使用场景，<br>如果你的任务都是大数据量的同步任务，那么最好可以设置成固定数量的Slot，避免提交过多任务影响单个节点的稳定性<br>但是如果每个任务的数据量都很少，其实可以选择动态Slot，这样可以更大限度的提升资源使用率</p>
</blockquote>
<p>在初始化时， 会根据是否为动态slot来进行slot数量的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFixedSlots</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; config.getSlotNum(); i++) &#123;</span><br><span class="line">        unassignedSlots.put(</span><br><span class="line">                i,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SlotProfile</span>(</span><br><span class="line">                        nodeEngine.getThisAddress(),</span><br><span class="line">                        i,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ResourceProfile</span>(</span><br><span class="line">                                CPU.of(<span class="number">0</span>), Memory.of(maxMemory / config.getSlotNum())),</span><br><span class="line">                        slotServiceSequence));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时我们也可以看到初始化时会启动一个线程， 定时向master节点发送心跳， 心跳信息中则包含了当前节点的信息， 包括已经分配的， 未分配的slot数量等属性，worker节点通过心跳将信息定时更新给master。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> WorkerProfile <span class="title function_">getWorkerProfile</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WorkerProfile</span> <span class="variable">workerProfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkerProfile</span>(nodeEngine.getThisAddress());</span><br><span class="line">    workerProfile.setProfile(getNodeResource());</span><br><span class="line">    workerProfile.setAssignedSlots(assignedSlots.values().toArray(<span class="keyword">new</span> <span class="title class_">SlotProfile</span>[<span class="number">0</span>]));</span><br><span class="line">    workerProfile.setUnassignedSlots(unassignedSlots.values().toArray(<span class="keyword">new</span> <span class="title class_">SlotProfile</span>[<span class="number">0</span>]));</span><br><span class="line">    workerProfile.setUnassignedResource(unassignedResource.get());</span><br><span class="line">    workerProfile.setAttributes(nodeEngine.getLocalMember().getAttributes());</span><br><span class="line">    workerProfile.setDynamicSlot(config.isDynamicSlot());</span><br><span class="line">    <span class="keyword">return</span> workerProfile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ResourceProfile <span class="title function_">getNodeResource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourceProfile</span>(CPU.of(<span class="number">0</span>), Memory.of(Runtime.getRuntime().maxMemory()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="TaskExecutionService"><a href="#TaskExecutionService" class="headerlink" title="TaskExecutionService"></a>TaskExecutionService</h3><p>这个组件与任务提交相关， 这里先简单看下，与任务提交的相关代码在后续再深入查看。</p>
<p>在worker节点初始化时， 会新建一个<code>TaskExecutionService</code>对象，并调用其<code>start</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span></span><br><span class="line">        newCachedThreadPool(<span class="keyword">new</span> <span class="title class_">BlockingTaskThreadFactory</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TaskExecutionService</span><span class="params">(</span></span><br><span class="line"><span class="params">        ClassLoaderService classLoaderService,</span></span><br><span class="line"><span class="params">        NodeEngineImpl nodeEngine,</span></span><br><span class="line"><span class="params">        HazelcastProperties properties)</span> &#123;</span><br><span class="line">        <span class="comment">// 加载配置信息</span></span><br><span class="line">    seaTunnelConfig = ConfigProvider.locateAndGetSeaTunnelConfig();</span><br><span class="line">    <span class="built_in">this</span>.hzInstanceName = nodeEngine.getHazelcastInstance().getName();</span><br><span class="line">    <span class="built_in">this</span>.nodeEngine = nodeEngine;</span><br><span class="line">    <span class="built_in">this</span>.classLoaderService = classLoaderService;</span><br><span class="line">    <span class="built_in">this</span>.logger = nodeEngine.getLoggingService().getLogger(TaskExecutionService.class);</span><br><span class="line">    <span class="comment">// 指标相关</span></span><br><span class="line">    <span class="type">MetricsRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> nodeEngine.getMetricsRegistry();</span><br><span class="line">    <span class="type">MetricDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span></span><br><span class="line">            registry.newMetricDescriptor()</span><br><span class="line">                    .withTag(MetricTags.SERVICE, <span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    registry.registerStaticMetrics(descriptor, <span class="built_in">this</span>);</span><br><span class="line">    scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    <span class="comment">// 定时任务更新指标到IMAP中</span></span><br><span class="line">    scheduledExecutorService.scheduleAtFixedRate(</span><br><span class="line">            <span class="built_in">this</span>::updateMetricsContextInImap,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            seaTunnelConfig.getEngineConfig().getJobMetricsBackupInterval(),</span><br><span class="line">            TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    serverConnectorPackageClient =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerConnectorPackageClient</span>(nodeEngine, seaTunnelConfig);</span><br><span class="line"></span><br><span class="line">    eventBuffer = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2048</span>);</span><br><span class="line">    <span class="comment">// 事件转发服务</span></span><br><span class="line">    eventForwardService =</span><br><span class="line">            Executors.newSingleThreadExecutor(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;event-forwarder-%d&quot;</span>).build());</span><br><span class="line">    eventForwardService.submit(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                List&lt;Event&gt; events = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                RetryUtils.<span class="type">RetryMaterial</span> <span class="variable">retryMaterial</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">RetryUtils</span>.RetryMaterial(<span class="number">2</span>, <span class="literal">true</span>, e -&gt; <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        events.clear();</span><br><span class="line"></span><br><span class="line">                        <span class="type">Event</span> <span class="variable">first</span> <span class="operator">=</span> eventBuffer.take();</span><br><span class="line">                        events.add(first);</span><br><span class="line"></span><br><span class="line">                        eventBuffer.drainTo(events, <span class="number">500</span>);</span><br><span class="line">                        <span class="type">JobEventReportOperation</span> <span class="variable">operation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobEventReportOperation</span>(events);</span><br><span class="line"></span><br><span class="line">                        RetryUtils.retryWithException(</span><br><span class="line">                                () -&gt;</span><br><span class="line">                                        NodeEngineUtil.sendOperationToMasterNode(</span><br><span class="line">                                                        nodeEngine, operation)</span><br><span class="line">                                                .join(),</span><br><span class="line">                                retryMaterial);</span><br><span class="line"></span><br><span class="line">                        logger.fine(<span class="string">&quot;Event forward success, events &quot;</span> + events.size());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        logger.info(<span class="string">&quot;Event forward thread interrupted&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.warning(</span><br><span class="line">                                <span class="string">&quot;Event forward failed, discard events &quot;</span> + events.size(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    runBusWorkSupplier.runNewBusWork(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个类中，有一个成员变量，创建了一个线程池，该线程池为<code>CachedThreadPool</code>，没有大小限制。<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081457994.png" alt="image.png"></p>
<p>在构造方法中构建了一个定时任务，这个任务会将本地执行的一些指标信息更新到IMAP中。<br>同时创建了一个任务来将Event信息发送给master节点， 由master节点再将这些Event发送给外部服务。<br><img src="https://raw.githubusercontent.com/liunaijie/images/9fda0101fd39e1313558eafe28506b634ff29759/Pasted%20image%2020240821111350.png"></p>
<p>至此， 服务端所有服务组件都已启动完成</p>
<p>master节点与备选节点上会</p>
<ol>
<li>定时检查自己是否为master节点， 如果是则进行相应的状态转化<br>master节点上会</li>
<li>定时打印集群的状态信息。</li>
<li>启动转发服务， 将要推送的事件转发到外部服务<br>在worker节点上， 启动后会</li>
<li>定时将状态信息上报到master节点</li>
<li>将任务信息更新到IMAP里面。</li>
<li>将在worker产生的要推送给外部服务的事件转发到master节点上。</li>
</ol>
<hr>
<hr>
<hr>
<p>下面我们会再从一个简单的任务开始， 从客户端看下任务的提交流程。</p>
<h1 id="客户端提交任务"><a href="#客户端提交任务" class="headerlink" title="客户端提交任务"></a>客户端提交任务</h1><p>这里以命令行提交任务的形式来讲解任务的提交流程。</p>
<p>命令行提交任务的命令为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/seatunnel/sh -c &lt;config_path&gt;</span><br></pre></td></tr></table></figure>

<p>我们查看这个脚本文件后可以看到这个脚本中最后会调用<code>org.apache.seatunnel.core.starter.seatunnel.SeaTunnelClient</code>这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeaTunnelClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CommandException &#123;</span><br><span class="line">        <span class="type">ClientCommandArgs</span> <span class="variable">clientCommandArgs</span> <span class="operator">=</span></span><br><span class="line">                CommandLineUtils.parse(</span><br><span class="line">                        args,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ClientCommandArgs</span>(),</span><br><span class="line">                        EngineType.SEATUNNEL.getStarterShellName(),</span><br><span class="line">                        <span class="literal">true</span>);</span><br><span class="line">        SeaTunnel.run(clientCommandArgs.buildCommand());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类中，仅有一个main方法， 与上面的server端的代码类似，不过这里构建的是<code>ClientCommandArgs</code></p>
<h2 id="解析命令行参数"><a href="#解析命令行参数" class="headerlink" title="解析命令行参数"></a>解析命令行参数</h2><p>我们查看<code>clientCommandArgs.buildCommand</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Command&lt;?&gt; buildCommand() &#123;</span><br><span class="line">    Common.setDeployMode(getDeployMode());</span><br><span class="line">    <span class="keyword">if</span> (checkConfig) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SeaTunnelConfValidateCommand</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (encrypt) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConfEncryptCommand</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (decrypt) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConfDecryptCommand</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientExecuteCommand</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是调用了<code>jcommander</code>来解析参数， 会根据用户传递的参数来决定构建哪个类， 例如是对配置文件做检查，还是加密文件，解密文件以及是不是Client提交任务的命令。<br>这里就不再讲解其他几个类，主要来看下<code>ClientExecuteCommand</code><br>这个类的主要代码都在<code>execute</code>方法中， 整体方法比较长， 我将分段来描述每一段的作业</p>
<h2 id="连接集群"><a href="#连接集群" class="headerlink" title="连接集群"></a>连接集群</h2><p>在这一部分代码中， 做的事情是读取<code>hazelcast-client.yaml</code>文件，尝试建立与server端的连接， 当使用<code>local</code>模式时，会现在本地创建一个hazelcast的实例， 然后连接到这个实例上， 当使用<code>cluster</code>模式时， 则直接连接到集群上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> CommandExecuteException &#123;</span><br><span class="line">    JobMetricsRunner.<span class="type">JobMetricsSummary</span> <span class="variable">jobMetricsSummary</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">startTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">SeaTunnelConfig</span> <span class="variable">seaTunnelConfig</span> <span class="operator">=</span> ConfigProvider.locateAndGetSeaTunnelConfig();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clusterName</span> <span class="operator">=</span> clientCommandArgs.getClusterName();</span><br><span class="line">        <span class="comment">// 加载配置信息</span></span><br><span class="line">        <span class="type">ClientConfig</span> <span class="variable">clientConfig</span> <span class="operator">=</span> ConfigProvider.locateAndGetClientConfig();</span><br><span class="line">        <span class="comment">// 根据此次提交的任务类型，当使用local模式时，意味着上面服务端的流程是没有执行的，</span></span><br><span class="line">        <span class="comment">// 所以先创建一个本地seatunnel server</span></span><br><span class="line">        <span class="keyword">if</span> (clientCommandArgs.getMasterType().equals(MasterType.LOCAL)) &#123;</span><br><span class="line">            clusterName =</span><br><span class="line">                    creatRandomClusterName(</span><br><span class="line">                            StringUtils.isNotEmpty(clusterName)</span><br><span class="line">                                    ? clusterName</span><br><span class="line">                                    : Constant.DEFAULT_SEATUNNEL_CLUSTER_NAME);</span><br><span class="line">            instance = createServerInLocal(clusterName, seaTunnelConfig);</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> instance.getCluster().getLocalMember().getSocketAddress().getPort();</span><br><span class="line">            clientConfig</span><br><span class="line">                    .getNetworkConfig()</span><br><span class="line">                    .setAddresses(Collections.singletonList(<span class="string">&quot;localhost:&quot;</span> + port));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 与远程或本地的seatunnel server连接，创建一个engineClient</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(clusterName)) &#123;</span><br><span class="line">            seaTunnelConfig.getHazelcastConfig().setClusterName(clusterName);</span><br><span class="line">            clientConfig.setClusterName(clusterName);</span><br><span class="line">        &#125;</span><br><span class="line">        engineClient = <span class="keyword">new</span> <span class="title class_">SeaTunnelClient</span>(clientConfig);</span><br><span class="line">        <span class="comment">// 省略第二段代码</span></span><br><span class="line">        <span class="comment">// 省略第三段代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CommandExecuteException</span>(<span class="string">&quot;SeaTunnel job executed failed&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobMetricsSummary != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 任务结束，打印日志</span></span><br><span class="line">            log.info(</span><br><span class="line">                    StringFormatUtils.formatTable(</span><br><span class="line">                            <span class="string">&quot;Job Statistic Information&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;Start Time&quot;</span>,</span><br><span class="line">                            DateTimeUtils.toString(</span><br><span class="line">                                    startTime, DateTimeUtils.Formatter.YYYY_MM_DD_HH_MM_SS),</span><br><span class="line">                            <span class="string">&quot;End Time&quot;</span>,</span><br><span class="line">                            DateTimeUtils.toString(</span><br><span class="line">                                    endTime, DateTimeUtils.Formatter.YYYY_MM_DD_HH_MM_SS),</span><br><span class="line">                            <span class="string">&quot;Total Time(s)&quot;</span>,</span><br><span class="line">                            Duration.between(startTime, endTime).getSeconds(),</span><br><span class="line">                            <span class="string">&quot;Total Read Count&quot;</span>,</span><br><span class="line">                            jobMetricsSummary.getSourceReadCount(),</span><br><span class="line">                            <span class="string">&quot;Total Write Count&quot;</span>,</span><br><span class="line">                            jobMetricsSummary.getSinkWriteCount(),</span><br><span class="line">                            <span class="string">&quot;Total Failed Count&quot;</span>,</span><br><span class="line">                            jobMetricsSummary.getSourceReadCount()</span><br><span class="line">                                    - jobMetricsSummary.getSinkWriteCount()));</span><br><span class="line">        &#125;</span><br><span class="line">        closeClient();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/f76b60e984b135c06eb6cafb83601cb44078e564/Pasted%20image%2020240821111832.png"></p>
<h2 id="判断任务类型，调用相关方法"><a href="#判断任务类型，调用相关方法" class="headerlink" title="判断任务类型，调用相关方法"></a>判断任务类型，调用相关方法</h2><p>则是根据用户的参数来判断这次的任务类型是什么， 根据参数的不同，调用不同的方法， 例如取消任务， 则会调用相应的取消任务方法， 这次对这里的几个任务不再具体分析， 这次以提交任务为主， 当我们将提交任务的流程弄明白， 这些再去看时也就简单了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (clientCommandArgs.isListJob()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">jobStatus</span> <span class="operator">=</span> engineClient.getJobClient().listJobStatus(<span class="literal">true</span>);</span><br><span class="line">            System.out.println(jobStatus);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (clientCommandArgs.isGetRunningJobMetrics()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">runningJobMetrics</span> <span class="operator">=</span> engineClient.getJobClient().getRunningJobMetrics();</span><br><span class="line">    System.out.println(runningJobMetrics);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != clientCommandArgs.getJobId()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jobState</span> <span class="operator">=</span></span><br><span class="line">            engineClient</span><br><span class="line">                    .getJobClient()</span><br><span class="line">                    .getJobDetailStatus(Long.parseLong(clientCommandArgs.getJobId()));</span><br><span class="line">    System.out.println(jobState);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != clientCommandArgs.getCancelJobId()) &#123;</span><br><span class="line">    engineClient</span><br><span class="line">            .getJobClient()</span><br><span class="line">            .cancelJob(Long.parseLong(clientCommandArgs.getCancelJobId()));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != clientCommandArgs.getMetricsJobId()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jobMetrics</span> <span class="operator">=</span></span><br><span class="line">            engineClient</span><br><span class="line">                    .getJobClient()</span><br><span class="line">                    .getJobMetrics(Long.parseLong(clientCommandArgs.getMetricsJobId()));</span><br><span class="line">    System.out.println(jobMetrics);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != clientCommandArgs.getSavePointJobId()) &#123;</span><br><span class="line">    engineClient</span><br><span class="line">            .getJobClient()</span><br><span class="line">            .savePointJob(Long.parseLong(clientCommandArgs.getSavePointJobId()));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 省略第三段代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提交任务到集群"><a href="#提交任务到集群" class="headerlink" title="提交任务到集群"></a>提交任务到集群</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取配置文件的路径, 并检查文件是否存在</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">configFile</span> <span class="operator">=</span> FileUtils.getConfigPath(clientCommandArgs);</span><br><span class="line">checkConfigExist(configFile);</span><br><span class="line"><span class="type">JobConfig</span> <span class="variable">jobConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobConfig</span>();</span><br><span class="line"><span class="comment">// 下面会根据这次任务是根据savepoint重启还是启动新任务来调用不同的方法来构建ClientJobExecutionEnvironment对象</span></span><br><span class="line">ClientJobExecutionEnvironment jobExecutionEnv;</span><br><span class="line">jobConfig.setName(clientCommandArgs.getJobName());</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != clientCommandArgs.getRestoreJobId()) &#123;</span><br><span class="line">    jobExecutionEnv =</span><br><span class="line">            engineClient.restoreExecutionContext(</span><br><span class="line">                    configFile.toString(),</span><br><span class="line">                    clientCommandArgs.getVariables(),</span><br><span class="line">                    jobConfig,</span><br><span class="line">                    seaTunnelConfig,</span><br><span class="line">                    Long.parseLong(clientCommandArgs.getRestoreJobId()));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    jobExecutionEnv =</span><br><span class="line">            engineClient.createExecutionContext(</span><br><span class="line">                    configFile.toString(),</span><br><span class="line">                    clientCommandArgs.getVariables(),</span><br><span class="line">                    jobConfig,</span><br><span class="line">                    seaTunnelConfig,</span><br><span class="line">                    clientCommandArgs.getCustomJobId() != <span class="literal">null</span></span><br><span class="line">                            ? Long.parseLong(clientCommandArgs.getCustomJobId())</span><br><span class="line">                            : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get job start time</span></span><br><span class="line">startTime = LocalDateTime.now();</span><br><span class="line"><span class="comment">// create job proxy</span></span><br><span class="line"><span class="comment">// 提交任务</span></span><br><span class="line"><span class="type">ClientJobProxy</span> <span class="variable">clientJobProxy</span> <span class="operator">=</span> jobExecutionEnv.execute();</span><br><span class="line"><span class="comment">// 判断是否为异步提交,当异步提交时会直接退出,不进行状态检查</span></span><br><span class="line"><span class="keyword">if</span> (clientCommandArgs.isAsync()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clientCommandArgs.getMasterType().equals(MasterType.LOCAL)) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;The job is running in local mode, can not use async mode.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// register cancelJob hook</span></span><br><span class="line"><span class="comment">// 添加hook方法, 当提交完成任务后, 命令行退出时, 取消刚刚提交的任务</span></span><br><span class="line">Runtime.getRuntime()</span><br><span class="line">        .addShutdownHook(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">                        () -&gt; &#123;</span><br><span class="line">                            CompletableFuture&lt;Void&gt; future =</span><br><span class="line">                                    CompletableFuture.runAsync(</span><br><span class="line">                                            () -&gt; &#123;</span><br><span class="line">                                                log.info(</span><br><span class="line">                                                        <span class="string">&quot;run shutdown hook because get close signal&quot;</span>);</span><br><span class="line">                                                shutdownHook(clientJobProxy);</span><br><span class="line">                                            &#125;);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                future.get(<span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                log.error(<span class="string">&quot;Cancel job failed.&quot;</span>, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;));</span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line"><span class="comment">// 同步，检查任务状态相关代码</span></span><br><span class="line"><span class="comment">// 获取任务id, 然后启动后台线程定时检查任务状态</span></span><br><span class="line"><span class="type">long</span> <span class="variable">jobId</span> <span class="operator">=</span> clientJobProxy.getJobId();</span><br><span class="line"><span class="type">JobMetricsRunner</span> <span class="variable">jobMetricsRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobMetricsRunner</span>(engineClient, jobId);</span><br><span class="line"><span class="comment">// 创建线程，定时检查状态</span></span><br><span class="line">executorService =</span><br><span class="line">        Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(<span class="string">&quot;job-metrics-runner-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>)</span><br><span class="line">                        .build());</span><br><span class="line">executorService.scheduleAtFixedRate(</span><br><span class="line">        jobMetricsRunner,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        seaTunnelConfig.getEngineConfig().getPrintJobMetricsInfoInterval(),</span><br><span class="line">        TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// wait for job complete</span></span><br><span class="line"><span class="comment">// 等待任务结束, 检查任务状态,当任务为异常退出时, 抛出异常</span></span><br><span class="line"><span class="type">JobResult</span> <span class="variable">jobResult</span> <span class="operator">=</span> clientJobProxy.waitForJobCompleteV2();</span><br><span class="line">jobStatus = jobResult.getStatus();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotEmpty(jobResult.getError())</span><br><span class="line">        || jobResult.getStatus().equals(JobStatus.FAILED)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SeaTunnelEngineException</span>(jobResult.getError());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get job end time</span></span><br><span class="line">endTime = LocalDateTime.now();</span><br><span class="line"><span class="comment">// get job statistic information when job finished</span></span><br><span class="line">jobMetricsSummary = engineClient.getJobMetricsSummary(jobId);        </span><br></pre></td></tr></table></figure>

<p>下面我们就看下<code>jobExecutionEnv</code>这个类的初始化与<code>execute</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClientJobExecutionEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">        JobConfig jobConfig,</span></span><br><span class="line"><span class="params">        String jobFilePath,</span></span><br><span class="line"><span class="params">        List&lt;String&gt; variables,</span></span><br><span class="line"><span class="params">        SeaTunnelHazelcastClient seaTunnelHazelcastClient,</span></span><br><span class="line"><span class="params">        SeaTunnelConfig seaTunnelConfig,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isStartWithSavePoint,</span></span><br><span class="line"><span class="params">        Long jobId)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(jobConfig, isStartWithSavePoint);</span><br><span class="line">    <span class="built_in">this</span>.jobFilePath = jobFilePath;</span><br><span class="line">    <span class="built_in">this</span>.variables = variables;</span><br><span class="line">    <span class="built_in">this</span>.seaTunnelHazelcastClient = seaTunnelHazelcastClient;</span><br><span class="line">    <span class="built_in">this</span>.jobClient = <span class="keyword">new</span> <span class="title class_">JobClient</span>(seaTunnelHazelcastClient);</span><br><span class="line">    <span class="built_in">this</span>.seaTunnelConfig = seaTunnelConfig;</span><br><span class="line">    Long finalJobId;</span><br><span class="line">    <span class="keyword">if</span> (isStartWithSavePoint || jobId != <span class="literal">null</span>) &#123;</span><br><span class="line">        finalJobId = jobId;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finalJobId = jobClient.getNewJobId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.jobConfig.setJobContext(<span class="keyword">new</span> <span class="title class_">JobContext</span>(finalJobId));</span><br><span class="line">    <span class="built_in">this</span>.connectorPackageClient = <span class="keyword">new</span> <span class="title class_">ConnectorPackageClient</span>(seaTunnelHazelcastClient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类的初始化中，很简单，只是变量赋值操作，没有做其他初始化操作。再来看下<code>execute</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ClientJobProxy <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">LogicalDag</span> <span class="variable">logicalDag</span> <span class="operator">=</span> getLogicalDag();</span><br><span class="line">    log.info(</span><br><span class="line">            <span class="string">&quot;jarUrls is : [&#123;&#125;]&quot;</span>,</span><br><span class="line">            jarUrls.stream().map(URL::getPath).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>)));</span><br><span class="line">    <span class="type">JobImmutableInformation</span> <span class="variable">jobImmutableInformation</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">JobImmutableInformation</span>(</span><br><span class="line">                    Long.parseLong(jobConfig.getJobContext().getJobId()),</span><br><span class="line">                    jobConfig.getName(),</span><br><span class="line">                    isStartWithSavePoint,</span><br><span class="line">                    seaTunnelHazelcastClient.getSerializationService().toData(logicalDag),</span><br><span class="line">                    jobConfig,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(jarUrls),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(connectorJarIdentifiers));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jobClient.createJobProxy(jobImmutableInformation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中，先调用<code>getLogicalDag</code>生产了逻辑计划，然后构建<code>JobImmutableInformation</code> 信息，传递给<code>jobClient</code>，我们先看后面的步骤，等会再看如何生成的逻辑计划。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ClientJobProxy <span class="title function_">createJobProxy</span><span class="params">(<span class="meta">@NonNull</span> JobImmutableInformation jobImmutableInformation)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientJobProxy</span>(hazelcastClient, jobImmutableInformation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClientJobProxy</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> SeaTunnelHazelcastClient seaTunnelHazelcastClient,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> JobImmutableInformation jobImmutableInformation)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.seaTunnelHazelcastClient = seaTunnelHazelcastClient;</span><br><span class="line">    <span class="built_in">this</span>.jobId = jobImmutableInformation.getJobId();</span><br><span class="line">    submitJob(jobImmutableInformation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">submitJob</span><span class="params">(JobImmutableInformation jobImmutableInformation)</span> &#123;</span><br><span class="line">    LOGGER.info(</span><br><span class="line">            String.format(</span><br><span class="line">                    <span class="string">&quot;Start submit job, job id: %s, with plugin jar %s&quot;</span>,</span><br><span class="line">                    jobImmutableInformation.getJobId(),</span><br><span class="line">                    jobImmutableInformation.getPluginJarsUrls()));</span><br><span class="line">    <span class="type">ClientMessage</span> <span class="variable">request</span> <span class="operator">=</span></span><br><span class="line">            SeaTunnelSubmitJobCodec.encodeRequest(</span><br><span class="line">                    jobImmutableInformation.getJobId(),</span><br><span class="line">                    seaTunnelHazelcastClient</span><br><span class="line">                            .getSerializationService()</span><br><span class="line">                            .toData(jobImmutableInformation),</span><br><span class="line">                    jobImmutableInformation.isStartWithSavePoint());</span><br><span class="line">    PassiveCompletableFuture&lt;Void&gt; submitJobFuture =</span><br><span class="line">            seaTunnelHazelcastClient.requestOnMasterAndGetCompletableFuture(request);</span><br><span class="line">    submitJobFuture.join();</span><br><span class="line">    LOGGER.info(</span><br><span class="line">            String.format(</span><br><span class="line">                    <span class="string">&quot;Submit job finished, job id: %s, job name: %s&quot;</span>,</span><br><span class="line">                    jobImmutableInformation.getJobId(), jobImmutableInformation.getJobName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里的代码可以看到，生成<code>JobImmutableInformation</code>后，会将这个信息转换为<code>ClientMessage(SeaTunnelSubmitJobCodec)</code>然后发送给Master节点，也就是hazelcast server中的master节点。提交完成之后又回到上面的任务状态检测相关步骤。</p>
<p>这里的消息发送是调用了hazelcast的相关方法，我们对其的实现不需要关注。</p>
<h2 id="逻辑计划解析"><a href="#逻辑计划解析" class="headerlink" title="逻辑计划解析"></a>逻辑计划解析</h2><p>下面一章会再回到Server端看下当收到client端发送的提交任务后的处理逻辑，这里我们先回到前面，看下在客户端如何生成的逻辑计划。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LogicalDag</span> <span class="variable">logicalDag</span> <span class="operator">=</span> getLogicalDag();</span><br></pre></td></tr></table></figure>

<p>先看下<code>LogicalDag</code>的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span> <span class="keyword">private</span> JobConfig jobConfig;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;LogicalEdge&gt; edges = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, LogicalVertex&gt; logicalVertexMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> IdGenerator idGenerator;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isStartWithSavePoint</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>在这个类里有这几个变量，有两个比较关键的类<code>LogicalEdge</code>和<code>LogicalVertex</code>，通过任务之间的关联关联构建出DAG。</p>
<p><code>LogicalEdge</code>的类中存储的变量很简单， 存储了两个点的关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The input vertex connected to this edge. */</span></span><br><span class="line"><span class="keyword">private</span> LogicalVertex inputVertex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The target vertex connected to this edge. */</span></span><br><span class="line"><span class="keyword">private</span> LogicalVertex targetVertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long inputVertexId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long targetVertexId;</span><br></pre></td></tr></table></figure>
<p><code>LogicalVertex</code>的变量为这几个变量，有当前点的编号，以及所需的并行度，以及<code>Action</code>接口， Action接口会有<code>SourceAction</code>，<code>SinkAction</code>，<code>TransformAction</code>等不同的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long vertexId;</span><br><span class="line"><span class="keyword">private</span> Action action;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of subtasks to split this task into at runtime. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> parallelism;</span><br></pre></td></tr></table></figure>
<p>看下<code>getLogicalDag</code>的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LogicalDag <span class="title function_">getLogicalDag</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    ImmutablePair&lt;List&lt;Action&gt;, Set&lt;URL&gt;&gt; immutablePair = getJobConfigParser().parse(<span class="literal">null</span>);</span><br><span class="line">    actions.addAll(immutablePair.getLeft());</span><br><span class="line">    <span class="comment">// seatunnel有个功能是不需要服务端所有节点有全部的依赖，可以在客户端中将所需依赖上传到服务端</span></span><br><span class="line">    <span class="comment">// 这里的if-else是这个功能的一些逻辑判断，判断是否需要从客户端将jar包上传到服务端，从而服务端不需要维护全部的jar包</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">enableUploadConnectorJarPackage</span> <span class="operator">=</span></span><br><span class="line">            seaTunnelConfig.getEngineConfig().getConnectorJarStorageConfig().getEnable();</span><br><span class="line">    <span class="keyword">if</span> (enableUploadConnectorJarPackage) &#123;</span><br><span class="line">        Set&lt;ConnectorJarIdentifier&gt; commonJarIdentifiers =</span><br><span class="line">                connectorPackageClient.uploadCommonPluginJars(</span><br><span class="line">                        Long.parseLong(jobConfig.getJobContext().getJobId()), commonPluginJars);</span><br><span class="line">        Set&lt;URL&gt; commonPluginJarUrls = getJarUrlsFromIdentifiers(commonJarIdentifiers);</span><br><span class="line">        Set&lt;ConnectorJarIdentifier&gt; pluginJarIdentifiers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        uploadActionPluginJar(actions, pluginJarIdentifiers);</span><br><span class="line">        Set&lt;URL&gt; connectorPluginJarUrls = getJarUrlsFromIdentifiers(pluginJarIdentifiers);</span><br><span class="line">        connectorJarIdentifiers.addAll(commonJarIdentifiers);</span><br><span class="line">        connectorJarIdentifiers.addAll(pluginJarIdentifiers);</span><br><span class="line">        jarUrls.addAll(commonPluginJarUrls);</span><br><span class="line">        jarUrls.addAll(connectorPluginJarUrls);</span><br><span class="line">        actions.forEach(</span><br><span class="line">                action -&gt; &#123;</span><br><span class="line">                    addCommonPluginJarsToAction(</span><br><span class="line">                            action, commonPluginJarUrls, commonJarIdentifiers);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jarUrls.addAll(commonPluginJars);</span><br><span class="line">        jarUrls.addAll(immutablePair.getRight());</span><br><span class="line">        actions.forEach(</span><br><span class="line">                action -&gt; &#123;</span><br><span class="line">                    addCommonPluginJarsToAction(</span><br><span class="line">                            action, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(commonPluginJars), Collections.emptySet());</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getLogicalDagGenerator().generate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中首先调用了<code>.parse(null)</code>方法，此方法的返回值是一个不可变二元组，第一个值为<code>List&lt;Action&gt;</code>对象，<code>getJobConfigParser</code>返回的对象是<code>MultipleTableJobConfigParser</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MultipleTableJobConfigParser</span><span class="params">(</span></span><br><span class="line"><span class="params">        Config seaTunnelJobConfig,</span></span><br><span class="line"><span class="params">        IdGenerator idGenerator,</span></span><br><span class="line"><span class="params">        JobConfig jobConfig,</span></span><br><span class="line"><span class="params">        List&lt;URL&gt; commonPluginJars,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isStartWithSavePoint)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.idGenerator = idGenerator;</span><br><span class="line">    <span class="built_in">this</span>.jobConfig = jobConfig;</span><br><span class="line">    <span class="built_in">this</span>.commonPluginJars = commonPluginJars;</span><br><span class="line">    <span class="built_in">this</span>.isStartWithSavePoint = isStartWithSavePoint;</span><br><span class="line">    <span class="built_in">this</span>.seaTunnelJobConfig = seaTunnelJobConfig;</span><br><span class="line">    <span class="built_in">this</span>.envOptions = ReadonlyConfig.fromConfig(seaTunnelJobConfig.getConfig(<span class="string">&quot;env&quot;</span>));</span><br><span class="line">    <span class="built_in">this</span>.fallbackParser =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">JobConfigParser</span>(idGenerator, commonPluginJars, <span class="built_in">this</span>, isStartWithSavePoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用<code>parse(null)</code>方法时，会进行解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ImmutablePair&lt;List&lt;Action&gt;, Set&lt;URL&gt;&gt; <span class="title function_">parse</span><span class="params">(ClassLoaderService classLoaderService)</span> &#123;</span><br><span class="line">    <span class="comment">// 将配置文件中的 env.jars添加到 commonJars中</span></span><br><span class="line">    <span class="built_in">this</span>.fillJobConfigAndCommonJars();</span><br><span class="line">    <span class="comment">// 从配置文件中，将source，transform，sink的配置分别读取处理</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Config</span>&gt; sourceConfigs =</span><br><span class="line">            TypesafeConfigUtils.getConfigList(</span><br><span class="line">                    seaTunnelJobConfig, <span class="string">&quot;source&quot;</span>, Collections.emptyList());</span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Config</span>&gt; transformConfigs =</span><br><span class="line">            TypesafeConfigUtils.getConfigList(</span><br><span class="line">                    seaTunnelJobConfig, <span class="string">&quot;transform&quot;</span>, Collections.emptyList());</span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Config</span>&gt; sinkConfigs =</span><br><span class="line">            TypesafeConfigUtils.getConfigList(</span><br><span class="line">                    seaTunnelJobConfig, <span class="string">&quot;sink&quot;</span>, Collections.emptyList());</span><br><span class="line">    <span class="comment">// 获取连接器的jar包地址</span></span><br><span class="line">    List&lt;URL&gt; connectorJars = getConnectorJarList(sourceConfigs, sinkConfigs);</span><br><span class="line">    <span class="keyword">if</span> (!commonPluginJars.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 将commonJars添加到连接器的jars中</span></span><br><span class="line">        connectorJars.addAll(commonPluginJars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">parentClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">    ClassLoader classLoader;</span><br><span class="line">    <span class="keyword">if</span> (classLoaderService == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 由于我们刚才传递了null，所以这里会创建SeaTunnelChildFirstClassLoader类加载器</span></span><br><span class="line">        <span class="comment">// 从名字也能看出，这里会与默认的加载器不同，不会先调用父类进行加载，</span></span><br><span class="line">        <span class="comment">// 而是自己找不到之后再调用父类进行加载，避免jar包冲突</span></span><br><span class="line">        classLoader = <span class="keyword">new</span> <span class="title class_">SeaTunnelChildFirstClassLoader</span>(connectorJars, parentClassLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        classLoader =</span><br><span class="line">                classLoaderService.getClassLoader(</span><br><span class="line">                        Long.parseLong(jobConfig.getJobContext().getJobId()), connectorJars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">        <span class="comment">// 检查DAG里面是否构成环，避免后续的构建过程陷入循环</span></span><br><span class="line">        ConfigParserUtil.checkGraph(sourceConfigs, transformConfigs, sinkConfigs);</span><br><span class="line">        LinkedHashMap&lt;String, List&lt;Tuple2&lt;CatalogTable, Action&gt;&gt;&gt; tableWithActionMap =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        log.info(<span class="string">&quot;start generating all sources.&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">configIndex</span> <span class="operator">=</span> <span class="number">0</span>; configIndex &lt; sourceConfigs.size(); configIndex++) &#123;</span><br><span class="line">            <span class="type">Config</span> <span class="variable">sourceConfig</span> <span class="operator">=</span> sourceConfigs.get(configIndex);</span><br><span class="line">            <span class="comment">// parseSource方法为真正生成source的方法</span></span><br><span class="line">            <span class="comment">// 返回值为2元组，第一个值为 当前source生成的表名称</span></span><br><span class="line">            <span class="comment">// 第二个值为 CatalogTable和Action的二元组列表</span></span><br><span class="line">            <span class="comment">// 由于SeaTunnel Source支持读取多表，所以第二个值为列表</span></span><br><span class="line">            Tuple2&lt;String, List&lt;Tuple2&lt;CatalogTable, Action&gt;&gt;&gt; tuple2 =</span><br><span class="line">                    parseSource(configIndex, sourceConfig, classLoader);</span><br><span class="line">            tableWithActionMap.put(tuple2._1(), tuple2._2());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;start generating all transforms.&quot;</span>);</span><br><span class="line">        <span class="comment">// parseTransforms来生成transform</span></span><br><span class="line">        <span class="comment">// 这里将上面的 tableWithActionMap传递了进去，所以不需要返回值</span></span><br><span class="line">        parseTransforms(transformConfigs, classLoader, tableWithActionMap);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;start generating all sinks.&quot;</span>);</span><br><span class="line">        List&lt;Action&gt; sinkActions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">configIndex</span> <span class="operator">=</span> <span class="number">0</span>; configIndex &lt; sinkConfigs.size(); configIndex++) &#123;</span><br><span class="line">            <span class="type">Config</span> <span class="variable">sinkConfig</span> <span class="operator">=</span> sinkConfigs.get(configIndex);</span><br><span class="line">            <span class="comment">// parseSink方法来生成sink</span></span><br><span class="line">            <span class="comment">// 同样，传递了tableWithActionMap</span></span><br><span class="line">            sinkActions.addAll(</span><br><span class="line">                    parseSink(configIndex, sinkConfig, classLoader, tableWithActionMap));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;URL&gt; factoryUrls = getUsedFactoryUrls(sinkActions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImmutablePair</span>&lt;&gt;(sinkActions, factoryUrls);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前线程的类加载器切换为原来的类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(parentClassLoader);</span><br><span class="line">        <span class="keyword">if</span> (classLoaderService != <span class="literal">null</span>) &#123;</span><br><span class="line">            classLoaderService.releaseClassLoader(</span><br><span class="line">                    Long.parseLong(jobConfig.getJobContext().getJobId()), connectorJars);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析Source"><a href="#解析Source" class="headerlink" title="解析Source"></a>解析Source</h3><p>先来看下<code>parseSource</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Tuple2&lt;String, List&lt;Tuple2&lt;CatalogTable, Action&gt;&gt;&gt; <span class="title function_">parseSource</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> configIndex, Config sourceConfig, ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReadonlyConfig</span> <span class="variable">readonlyConfig</span> <span class="operator">=</span> ReadonlyConfig.fromConfig(sourceConfig);</span><br><span class="line">    <span class="comment">// factoryId就是我们配置里面的 source名称，例如 FakeSource， Jdbc</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">factoryId</span> <span class="operator">=</span> getFactoryId(readonlyConfig);</span><br><span class="line">    <span class="comment">// 获取当前数据源生成的 表 名称，注意这里的表可能并不对应一个表</span></span><br><span class="line">    <span class="comment">// 由于 seatunnel source支持多表读取，那么这里就会出现一对多的关系</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">tableId</span> <span class="operator">=</span></span><br><span class="line">            readonlyConfig.getOptional(CommonOptions.RESULT_TABLE_NAME).orElse(DEFAULT_ID);</span><br><span class="line">    <span class="comment">// 获取并行度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parallelism</span> <span class="operator">=</span> getParallelism(readonlyConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个地方是由于某些Source还不支持通过Factory工厂来构建，所以会有两种构建方法</span></span><br><span class="line">    <span class="comment">// 后续当所有连接器都支持通过工厂来创建后，这里的代码会被删除掉，所以这次忽略掉这部分代码</span></span><br><span class="line">    <span class="comment">// 方法内部是查询是否有相应的工厂类，相应的工厂类不存在时返回 true，不存在时返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">fallback</span> <span class="operator">=</span></span><br><span class="line">            isFallback(</span><br><span class="line">                    classLoader,</span><br><span class="line">                    TableSourceFactory.class,</span><br><span class="line">                    factoryId,</span><br><span class="line">                    (factory) -&gt; factory.createSource(<span class="literal">null</span>));</span><br><span class="line">    <span class="keyword">if</span> (fallback) &#123;</span><br><span class="line">        Tuple2&lt;CatalogTable, Action&gt; tuple =</span><br><span class="line">                fallbackParser.parseSource(sourceConfig, jobConfig, tableId, parallelism);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(tableId, Collections.singletonList(tuple));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过FactoryUtil来创建Source</span></span><br><span class="line">    <span class="comment">// 返回对象为 SeaTunnelSource实例，以及List&lt;CatalogTable&gt;</span></span><br><span class="line">    <span class="comment">// 这里会创建我们同步任务中Source的实例，catalogtable列表表示这个数据源读取的表的表结构等信息</span></span><br><span class="line">    Tuple2&lt;SeaTunnelSource&lt;Object, SourceSplit, Serializable&gt;, List&lt;CatalogTable&gt;&gt; tuple2 =</span><br><span class="line">            FactoryUtil.createAndPrepareSource(readonlyConfig, classLoader, factoryId);</span><br><span class="line">    <span class="comment">// 获取当前source connector的jar包</span></span><br><span class="line">    Set&lt;URL&gt; factoryUrls = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    factoryUrls.addAll(getSourcePluginJarPaths(sourceConfig));</span><br><span class="line"></span><br><span class="line">    List&lt;Tuple2&lt;CatalogTable, Action&gt;&gt; actions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idGenerator.getNextId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">actionName</span> <span class="operator">=</span> JobConfigParser.createSourceActionName(configIndex, factoryId);</span><br><span class="line">    SeaTunnelSource&lt;Object, SourceSplit, Serializable&gt; source = tuple2._1();</span><br><span class="line">    source.setJobContext(jobConfig.getJobContext());</span><br><span class="line">    PluginUtil.ensureJobModeMatch(jobConfig.getJobContext(), source);</span><br><span class="line">    <span class="comment">// 构建 SourceAction</span></span><br><span class="line">    SourceAction&lt;Object, SourceSplit, Serializable&gt; action =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SourceAction</span>&lt;&gt;(id, actionName, tuple2._1(), factoryUrls, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">    action.setParallelism(parallelism);</span><br><span class="line">    <span class="keyword">for</span> (CatalogTable catalogTable : tuple2._2()) &#123;</span><br><span class="line">        actions.add(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(catalogTable, action));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(tableId, actions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下新版本中是如何通过工厂来创建Source实例的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, SplitT <span class="keyword">extends</span> <span class="title class_">SourceSplit</span>, StateT <span class="keyword">extends</span> <span class="title class_">Serializable</span>&gt;</span><br><span class="line">        Tuple2&lt;SeaTunnelSource&lt;T, SplitT, StateT&gt;, List&lt;CatalogTable&gt;&gt; <span class="title function_">createAndPrepareSource</span><span class="params">(</span></span><br><span class="line"><span class="params">                ReadonlyConfig options, ClassLoader classLoader, String factoryIdentifier)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过SPI加载TableSourceFactory的类，然后根据factoryIdentifier找对应的类</span></span><br><span class="line">        <span class="comment">// 即 找到 souce对应的 SourceFactory</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TableSourceFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line">                discoverFactory(classLoader, TableSourceFactory.class, factoryIdentifier);</span><br><span class="line">        <span class="comment">// 通过Factory来创建Source实例，这个Source实例就是你任务中对应类型的Source        </span></span><br><span class="line">        <span class="comment">// 也就是说Source类的初始化会在Client端创建一次，需要注意这里的环境是否能够连接到该Source</span></span><br><span class="line">        SeaTunnelSource&lt;T, SplitT, StateT&gt; source =</span><br><span class="line">                createAndPrepareSource(factory, options, classLoader);</span><br><span class="line">        List&lt;CatalogTable&gt; catalogTables;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 source会产生的表 列表。包含了字段，数据类型，分区信息等</span></span><br><span class="line">            catalogTables = source.getProducedCatalogTables();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">            <span class="comment">// 为了兼容有些Connector未实现getProducedCatalogTables方法</span></span><br><span class="line">            <span class="comment">// 调用老的获取数据类型的方法，并转换为Catalog</span></span><br><span class="line">            SeaTunnelDataType&lt;T&gt; seaTunnelDataType = source.getProducedType();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">tableId</span> <span class="operator">=</span></span><br><span class="line">                    options.getOptional(CommonOptions.RESULT_TABLE_NAME).orElse(DEFAULT_ID);</span><br><span class="line">            catalogTables =</span><br><span class="line">                    CatalogTableUtil.convertDataTypeToCatalogTables(seaTunnelDataType, tableId);</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(</span><br><span class="line">                <span class="string">&quot;get the CatalogTable from source &#123;&#125;: &#123;&#125;&quot;</span>,</span><br><span class="line">                source.getPluginName(),</span><br><span class="line">                catalogTables.stream()</span><br><span class="line">                        .map(CatalogTable::getTableId)</span><br><span class="line">                        .map(TableIdentifier::toString)</span><br><span class="line">                        .collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        <span class="comment">// 这个代码已经过时</span></span><br><span class="line">        <span class="keyword">if</span> (options.get(SourceOptions.DAG_PARSING_MODE) == ParsingMode.SHARDING) &#123;</span><br><span class="line">            <span class="type">CatalogTable</span> <span class="variable">catalogTable</span> <span class="operator">=</span> catalogTables.get(<span class="number">0</span>);</span><br><span class="line">            catalogTables.clear();</span><br><span class="line">            catalogTables.add(catalogTable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(source, catalogTables);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FactoryException</span>(</span><br><span class="line">                String.format(</span><br><span class="line">                        <span class="string">&quot;Unable to create a source for identifier &#x27;%s&#x27;.&quot;</span>, factoryIdentifier),</span><br><span class="line">                t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T, SplitT <span class="keyword">extends</span> <span class="title class_">SourceSplit</span>, StateT <span class="keyword">extends</span> <span class="title class_">Serializable</span>&gt;</span><br><span class="line">        SeaTunnelSource&lt;T, SplitT, StateT&gt; <span class="title function_">createAndPrepareSource</span><span class="params">(</span></span><br><span class="line"><span class="params">                TableSourceFactory factory, ReadonlyConfig options, ClassLoader classLoader)</span> &#123;</span><br><span class="line">                <span class="comment">// 通过TableSourceFactory来创建Source</span></span><br><span class="line">    <span class="type">TableSourceFactoryContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableSourceFactoryContext</span>(options, classLoader);</span><br><span class="line">    ConfigValidator.of(context.getOptions()).validate(factory.optionRule());</span><br><span class="line">    TableSource&lt;T, SplitT, StateT&gt; tableSource = factory.createSource(context);</span><br><span class="line">    <span class="keyword">return</span> tableSource.createSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端就会通过<code>SPI</code>加载到<code>Source</code>相应的<code>Factory</code>然后创建出对应的Source实例出来，所以这里需要保证提交的客户端也能够与Source&#x2F;Sink端建立连接，避免网络连不通的问题。</p>
<h3 id="解析Transform"><a href="#解析Transform" class="headerlink" title="解析Transform"></a>解析Transform</h3><p>接下来在看一下如何创建Transform</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseTransforms</span><span class="params">(</span></span><br><span class="line"><span class="params">        List&lt;? extends Config&gt; transformConfigs,</span></span><br><span class="line"><span class="params">        ClassLoader classLoader,</span></span><br><span class="line"><span class="params">        LinkedHashMap&lt;String, List&lt;Tuple2&lt;CatalogTable, Action&gt;&gt;&gt; tableWithActionMap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(transformConfigs) || transformConfigs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Config&gt; configList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(transformConfigs);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!configList.isEmpty()) &#123;</span><br><span class="line">        parseTransform(index++, configList, classLoader, tableWithActionMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseTransform</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">        Queue&lt;Config&gt; transforms,</span></span><br><span class="line"><span class="params">        ClassLoader classLoader,</span></span><br><span class="line"><span class="params">        LinkedHashMap&lt;String, List&lt;Tuple2&lt;CatalogTable, Action&gt;&gt;&gt; tableWithActionMap)</span> &#123;</span><br><span class="line">    <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> transforms.poll();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReadonlyConfig</span> <span class="variable">readonlyConfig</span> <span class="operator">=</span> ReadonlyConfig.fromConfig(config);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">factoryId</span> <span class="operator">=</span> getFactoryId(readonlyConfig);</span><br><span class="line">    <span class="comment">// get jar urls</span></span><br><span class="line">    Set&lt;URL&gt; jarUrls = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    jarUrls.addAll(getTransformPluginJarPaths(config));</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; inputIds = getInputIds(readonlyConfig);</span><br><span class="line">    <span class="comment">// inputIds为source_table_name，根据这个值找到所依赖的上游source</span></span><br><span class="line">    <span class="comment">// 目前Transform不支持对多表进行处理，所以如果所依赖的上游是多表，会抛出异常</span></span><br><span class="line">    List&lt;Tuple2&lt;CatalogTable, Action&gt;&gt; inputs =</span><br><span class="line">            inputIds.stream()</span><br><span class="line">                    .map(tableWithActionMap::get)</span><br><span class="line">                    .filter(Objects::nonNull)</span><br><span class="line">                    .peek(</span><br><span class="line">                            input -&gt; &#123;</span><br><span class="line">                                <span class="keyword">if</span> (input.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JobDefineCheckException</span>(</span><br><span class="line">                                            <span class="string">&quot;Adding transform to multi-table source is not supported.&quot;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                    .flatMap(Collection::stream)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// inputs为空，表明当前Transform节点找不到任何上游的节点</span></span><br><span class="line">    <span class="comment">// 此时会有几种情况</span></span><br><span class="line">    <span class="keyword">if</span> (inputs.isEmpty()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (transforms.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 未设置source_table_name，设置结果与之前不对应并且只有一个transform时</span></span><br><span class="line">            <span class="comment">// 把最后一个source作为这个transform的上游表</span></span><br><span class="line">            inputs = findLast(tableWithActionMap);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 所依赖的transform可能还没有创建，将本次的transform再放回队列中，后续再进行解析</span></span><br><span class="line">            transforms.offer(config);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这次transform结果产生的表名称</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">tableId</span> <span class="operator">=</span></span><br><span class="line">            readonlyConfig.getOptional(CommonOptions.RESULT_TABLE_NAME).orElse(DEFAULT_ID);</span><br><span class="line">    <span class="comment">// 获取上游source的Action</span></span><br><span class="line">    Set&lt;Action&gt; inputActions =</span><br><span class="line">            inputs.stream()</span><br><span class="line">                    .map(Tuple2::_2)</span><br><span class="line">                    .collect(Collectors.toCollection(LinkedHashSet::<span class="keyword">new</span>));</span><br><span class="line">    <span class="comment">// 验证所依赖的多个上游，是否产生的表结构都相同，只有所有的表结构都相同才能进入一个transform来处理</span></span><br><span class="line">    checkProducedTypeEquals(inputActions);</span><br><span class="line">    <span class="comment">// 设置并行度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">spareParallelism</span> <span class="operator">=</span> inputs.get(<span class="number">0</span>)._2().getParallelism();</span><br><span class="line">    <span class="type">int</span> <span class="variable">parallelism</span> <span class="operator">=</span></span><br><span class="line">            readonlyConfig.getOptional(CommonOptions.PARALLELISM).orElse(spareParallelism);</span><br><span class="line">    <span class="comment">// 创建Transform实例，与刚刚通过Source工厂来创建差不多的行为</span></span><br><span class="line">    <span class="type">CatalogTable</span> <span class="variable">catalogTable</span> <span class="operator">=</span> inputs.get(<span class="number">0</span>)._1();</span><br><span class="line">    SeaTunnelTransform&lt;?&gt; transform =</span><br><span class="line">            FactoryUtil.createAndPrepareTransform(</span><br><span class="line">                    catalogTable, readonlyConfig, classLoader, factoryId);</span><br><span class="line">    transform.setJobContext(jobConfig.getJobContext());</span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idGenerator.getNextId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">actionName</span> <span class="operator">=</span> JobConfigParser.createTransformActionName(index, factoryId);</span><br><span class="line">    <span class="comment">// 封装成Action</span></span><br><span class="line">    <span class="type">TransformAction</span> <span class="variable">transformAction</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TransformAction</span>(</span><br><span class="line">                    id,</span><br><span class="line">                    actionName,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(inputActions),</span><br><span class="line">                    transform,</span><br><span class="line">                    jarUrls,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">    transformAction.setParallelism(parallelism);</span><br><span class="line">    <span class="comment">// 放入到map中，此时map里面存储了source和transform</span></span><br><span class="line">    <span class="comment">// 以每个节点产生的表结构为key，action作为value</span></span><br><span class="line">    tableWithActionMap.put(</span><br><span class="line">            tableId,</span><br><span class="line">            Collections.singletonList(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(transform.getProducedCatalogTable(), transformAction)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析Sink"><a href="#解析Sink" class="headerlink" title="解析Sink"></a>解析Sink</h3><p>当看完source&#x2F;transform的解析之后，对于sink的解析逻辑也会比较明了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;SinkAction&lt;?, ?, ?, ?&gt;&gt; parseSink(</span><br><span class="line">        <span class="type">int</span> configIndex,</span><br><span class="line">        Config sinkConfig,</span><br><span class="line">        ClassLoader classLoader,</span><br><span class="line">        LinkedHashMap&lt;String, List&lt;Tuple2&lt;CatalogTable, Action&gt;&gt;&gt; tableWithActionMap) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReadonlyConfig</span> <span class="variable">readonlyConfig</span> <span class="operator">=</span> ReadonlyConfig.fromConfig(sinkConfig);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">factoryId</span> <span class="operator">=</span> getFactoryId(readonlyConfig);</span><br><span class="line">    <span class="comment">// 获取当前sink节点依赖的上游节点</span></span><br><span class="line">    List&lt;String&gt; inputIds = getInputIds(readonlyConfig);</span><br><span class="line">    <span class="comment">// 在tableWithActionMap中查找</span></span><br><span class="line">    List&lt;List&lt;Tuple2&lt;CatalogTable, Action&gt;&gt;&gt; inputVertices =</span><br><span class="line">            inputIds.stream()</span><br><span class="line">                    .map(tableWithActionMap::get)</span><br><span class="line">                    .filter(Objects::nonNull)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">     <span class="comment">// 当sink节点找不到上游节点时，找到最后一个节点信息作为上游节点</span></span><br><span class="line">     <span class="comment">// 这里与transform不一样的地方是，不会再等其他sink节点初始化完成，因为sink节点不可能依赖与其他sink节点</span></span><br><span class="line">    <span class="keyword">if</span> (inputVertices.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// Tolerates incorrect configuration of simple graph</span></span><br><span class="line">        inputVertices = Collections.singletonList(findLast(tableWithActionMap));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inputVertices.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Tuple2&lt;CatalogTable, Action&gt;&gt; inputVertex : inputVertices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputVertex.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 当一个sink节点即有多个上游节点，且某个上游节点还会产生多表时抛出异常</span></span><br><span class="line">            <span class="comment">// sink可以支持多个数据源，或者单个数据源下产生多表，不能同时支持多个数据源，且某个数据源下存在多表</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JobDefineCheckException</span>(</span><br><span class="line">                        <span class="string">&quot;Sink don&#x27;t support simultaneous writing of data from multi-table source and other sources.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与解析source一样，对老代码的兼容</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">fallback</span> <span class="operator">=</span></span><br><span class="line">            isFallback(</span><br><span class="line">                    classLoader,</span><br><span class="line">                    TableSinkFactory.class,</span><br><span class="line">                    factoryId,</span><br><span class="line">                    (factory) -&gt; factory.createSink(<span class="literal">null</span>));</span><br><span class="line">    <span class="keyword">if</span> (fallback) &#123;</span><br><span class="line">        <span class="keyword">return</span> fallbackParser.parseSinks(configIndex, inputVertices, sinkConfig, jobConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取sink的连接器jar包</span></span><br><span class="line">    Set&lt;URL&gt; jarUrls = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    jarUrls.addAll(getSinkPluginJarPaths(sinkConfig));</span><br><span class="line">    List&lt;SinkAction&lt;?, ?, ?, ?&gt;&gt; sinkActions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个数据源的情况</span></span><br><span class="line">    <span class="keyword">if</span> (inputVertices.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Set&lt;Action&gt; inputActions =</span><br><span class="line">                inputVertices.stream()</span><br><span class="line">                        .flatMap(Collection::stream)</span><br><span class="line">                        .map(Tuple2::_2)</span><br><span class="line">                        .collect(Collectors.toCollection(LinkedHashSet::<span class="keyword">new</span>));</span><br><span class="line">        <span class="comment">// 检查多个上游数据源产生的表结构是否一致</span></span><br><span class="line">        checkProducedTypeEquals(inputActions);</span><br><span class="line">        <span class="comment">// 创建sinkAction</span></span><br><span class="line">        Tuple2&lt;CatalogTable, Action&gt; inputActionSample = inputVertices.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        SinkAction&lt;?, ?, ?, ?&gt; sinkAction =</span><br><span class="line">                createSinkAction(</span><br><span class="line">                        inputActionSample._1(),</span><br><span class="line">                        inputActions,</span><br><span class="line">                        readonlyConfig,</span><br><span class="line">                        classLoader,</span><br><span class="line">                        jarUrls,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(),</span><br><span class="line">                        factoryId,</span><br><span class="line">                        inputActionSample._2().getParallelism(),</span><br><span class="line">                        configIndex);</span><br><span class="line">        sinkActions.add(sinkAction);</span><br><span class="line">        <span class="keyword">return</span> sinkActions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时只有一个数据源，且此数据源下可能会产生多表，循环创建sinkAction</span></span><br><span class="line">    <span class="keyword">for</span> (Tuple2&lt;CatalogTable, Action&gt; tuple : inputVertices.get(<span class="number">0</span>)) &#123;</span><br><span class="line">        SinkAction&lt;?, ?, ?, ?&gt; sinkAction =</span><br><span class="line">                createSinkAction(</span><br><span class="line">                        tuple._1(),</span><br><span class="line">                        Collections.singleton(tuple._2()),</span><br><span class="line">                        readonlyConfig,</span><br><span class="line">                        classLoader,</span><br><span class="line">                        jarUrls,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(),</span><br><span class="line">                        factoryId,</span><br><span class="line">                        tuple._2().getParallelism(),</span><br><span class="line">                        configIndex);</span><br><span class="line">        sinkActions.add(sinkAction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当一个数据源下多表时与多个数据源 会多进行这么这一步</span></span><br><span class="line">    <span class="comment">// 上面的createSinkAction是一致的</span></span><br><span class="line">    <span class="comment">// 此方法内会判断sink是否支持多表，以及</span></span><br><span class="line">    Optional&lt;SinkAction&lt;?, ?, ?, ?&gt;&gt; multiTableSink =</span><br><span class="line">            tryGenerateMultiTableSink(</span><br><span class="line">                    sinkActions, readonlyConfig, classLoader, factoryId, configIndex);</span><br><span class="line">    <span class="comment">// 最终会将所创建的sink action作为返回值返回</span></span><br><span class="line">    <span class="keyword">return</span> multiTableSink</span><br><span class="line">            .&lt;List&lt;SinkAction&lt;?, ?, ?, ?&gt;&gt;&gt;map(Collections::singletonList)</span><br><span class="line">            .orElse(sinkActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看下创建<code>sinkAction</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SinkAction&lt;?, ?, ?, ?&gt; createSinkAction(</span><br><span class="line">        CatalogTable catalogTable,</span><br><span class="line">        Set&lt;Action&gt; inputActions,</span><br><span class="line">        ReadonlyConfig readonlyConfig,</span><br><span class="line">        ClassLoader classLoader,</span><br><span class="line">        Set&lt;URL&gt; factoryUrls,</span><br><span class="line">        Set&lt;ConnectorJarIdentifier&gt; connectorJarIdentifiers,</span><br><span class="line">        String factoryId,</span><br><span class="line">        <span class="type">int</span> parallelism,</span><br><span class="line">        <span class="type">int</span> configIndex) &#123;</span><br><span class="line">    <span class="comment">// 使用工厂类创建sink</span></span><br><span class="line">    SeaTunnelSink&lt;?, ?, ?, ?&gt; sink =</span><br><span class="line">            FactoryUtil.createAndPrepareSink(</span><br><span class="line">                    catalogTable, readonlyConfig, classLoader, factoryId);</span><br><span class="line">    sink.setJobContext(jobConfig.getJobContext());</span><br><span class="line">    <span class="type">SinkConfig</span> <span class="variable">actionConfig</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SinkConfig</span>(catalogTable.getTableId().toTablePath().toString());</span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idGenerator.getNextId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">actionName</span> <span class="operator">=</span></span><br><span class="line">            JobConfigParser.createSinkActionName(</span><br><span class="line">                    configIndex, factoryId, actionConfig.getMultipleRowTableId());</span><br><span class="line">    <span class="comment">// 创建sinkAction</span></span><br><span class="line">    SinkAction&lt;?, ?, ?, ?&gt; sinkAction =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SinkAction</span>&lt;&gt;(</span><br><span class="line">                    id,</span><br><span class="line">                    actionName,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(inputActions),</span><br><span class="line">                    sink,</span><br><span class="line">                    factoryUrls,</span><br><span class="line">                    connectorJarIdentifiers,</span><br><span class="line">                    actionConfig);</span><br><span class="line">    <span class="keyword">if</span> (!isStartWithSavePoint) &#123;</span><br><span class="line">    <span class="comment">// 这里需要注意，当非从savepoint启动时，会进行savemode的处理</span></span><br><span class="line">        handleSaveMode(sink);</span><br><span class="line">    &#125;</span><br><span class="line">    sinkAction.setParallelism(parallelism);</span><br><span class="line">    <span class="keyword">return</span> sinkAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleSaveMode</span><span class="params">(SeaTunnelSink&lt;?, ?, ?, ?&gt; sink)</span> &#123;</span><br><span class="line"><span class="comment">// 当sink类支持了savemode特性时，会进行savemode处理</span></span><br><span class="line"><span class="comment">// 例如删除表，重建表，报错等</span></span><br><span class="line">    <span class="keyword">if</span> (SupportSaveMode.class.isAssignableFrom(sink.getClass())) &#123;</span><br><span class="line">        <span class="type">SupportSaveMode</span> <span class="variable">saveModeSink</span> <span class="operator">=</span> (SupportSaveMode) sink;</span><br><span class="line">        <span class="comment">// 当 设置savemode在client端执行时，会在client端去做这些事</span></span><br><span class="line">        <span class="comment">// 我们之前出现过一个错误是当在客户端执行完毕后，到集群后任务执行出错，卡在scheduling的状态</span></span><br><span class="line">        <span class="comment">// 导致数据被清空后没有及时写入</span></span><br><span class="line">        <span class="comment">// 以及需要注意这个地方执行的机器到sink集群的网络是否能够连通，推荐将这个行为放到server端执行</span></span><br><span class="line">        <span class="keyword">if</span> (envOptions</span><br><span class="line">                .get(EnvCommonOptions.SAVEMODE_EXECUTE_LOCATION)</span><br><span class="line">                .equals(SaveModeExecuteLocation.CLIENT)) &#123;</span><br><span class="line">            log.warn(</span><br><span class="line">                    <span class="string">&quot;SaveMode execute location on CLIENT is deprecated, please use CLUSTER instead.&quot;</span>);</span><br><span class="line">            Optional&lt;SaveModeHandler&gt; saveModeHandler = saveModeSink.getSaveModeHandler();</span><br><span class="line">            <span class="keyword">if</span> (saveModeHandler.isPresent()) &#123;</span><br><span class="line">                <span class="keyword">try</span> (<span class="type">SaveModeHandler</span> <span class="variable">handler</span> <span class="operator">=</span> saveModeHandler.get()) &#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">SaveModeExecuteWrapper</span>(handler).execute();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SeaTunnelRuntimeException</span>(HANDLE_SAVE_MODE_FAILED, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看完了如何去解析Source&#x2F;Transform&#x2F;Sink的逻辑，再回到调用的地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Action&gt; sinkActions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">configIndex</span> <span class="operator">=</span> <span class="number">0</span>; configIndex &lt; sinkConfigs.size(); configIndex++) &#123;</span><br><span class="line">    <span class="type">Config</span> <span class="variable">sinkConfig</span> <span class="operator">=</span> sinkConfigs.get(configIndex);</span><br><span class="line">    <span class="comment">// parseSink方法来生成sink</span></span><br><span class="line">    <span class="comment">// 同样，传递了tableWithActionMap</span></span><br><span class="line">    sinkActions.addAll(</span><br><span class="line">            parseSink(configIndex, sinkConfig, classLoader, tableWithActionMap));</span><br><span class="line">&#125;</span><br><span class="line">Set&lt;URL&gt; factoryUrls = getUsedFactoryUrls(sinkActions);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImmutablePair</span>&lt;&gt;(sinkActions, factoryUrls);</span><br></pre></td></tr></table></figure>

<p><code>parseSink</code>会返回所有创建的<code>Sink Action</code>，而每个Action都维护了<code>upstream Action</code>，所以我们能通过最终的<code>Sink Action</code>找到相关联的<code>Transform Action</code>和<code>Source Action</code></p>
<p>最终调用<code>getUsedFactoryUrls</code>或找到此链路上的所有依赖的Jar</p>
<p>然后返回一个二元组</p>
<h2 id="逻辑计划解析-1"><a href="#逻辑计划解析-1" class="headerlink" title="逻辑计划解析"></a>逻辑计划解析</h2><p>再回到逻辑计划生成的部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LogicalDag <span class="title function_">getLogicalDag</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    ImmutablePair&lt;List&lt;Action&gt;, Set&lt;URL&gt;&gt; immutablePair = getJobConfigParser().parse(<span class="literal">null</span>);</span><br><span class="line">    actions.addAll(immutablePair.getLeft());</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> getLogicalDagGenerator().generate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面看完了如何去解析配置，接下来看下如何去生成逻辑计划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化将我们生成的所有SinkAction传入</span></span><br><span class="line"><span class="keyword">protected</span> LogicalDagGenerator <span class="title function_">getLogicalDagGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogicalDagGenerator</span>(actions, jobConfig, idGenerator, isStartWithSavePoint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> LogicalDag <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 根据action来生成节点信息</span></span><br><span class="line">    actions.forEach(<span class="built_in">this</span>::createLogicalVertex);</span><br><span class="line">    <span class="comment">// 创建边</span></span><br><span class="line">    Set&lt;LogicalEdge&gt; logicalEdges = createLogicalEdges();</span><br><span class="line">    <span class="comment">// 构建LogicalDag对象，并将解析的值设置到相应属性中</span></span><br><span class="line">    <span class="type">LogicalDag</span> <span class="variable">logicalDag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogicalDag</span>(jobConfig, idGenerator);</span><br><span class="line">    logicalDag.getEdges().addAll(logicalEdges);</span><br><span class="line">    logicalDag.getLogicalVertexMap().putAll(logicalVertexMap);</span><br><span class="line">    logicalDag.setStartWithSavePoint(isStartWithSavePoint);</span><br><span class="line">    <span class="keyword">return</span> logicalDag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建逻辑计划节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createLogicalVertex</span><span class="params">(Action action)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前action的id,判断当map中已经存在则返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">logicalVertexId</span> <span class="operator">=</span> action.getId();</span><br><span class="line">    <span class="keyword">if</span> (logicalVertexMap.containsKey(logicalVertexId)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对上游的依赖进行循环创建</span></span><br><span class="line">    <span class="comment">// map对象的存储结构为：</span></span><br><span class="line">    <span class="comment">// 当前节点的id为key</span></span><br><span class="line">    <span class="comment">// value为一个list，存储下游使用到该节点的id编号</span></span><br><span class="line">    action.getUpstream()</span><br><span class="line">            .forEach(</span><br><span class="line">                    inputAction -&gt; &#123;</span><br><span class="line">                        createLogicalVertex(inputAction);</span><br><span class="line">                        inputVerticesMap</span><br><span class="line">                                .computeIfAbsent(</span><br><span class="line">                                        inputAction.getId(), id -&gt; <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;())</span><br><span class="line">                                .add(logicalVertexId);</span><br><span class="line">                    &#125;);</span><br><span class="line">    <span class="comment">// 最后创建当前节点的信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">LogicalVertex</span> <span class="variable">logicalVertex</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LogicalVertex</span>(logicalVertexId, action, action.getParallelism());</span><br><span class="line">    <span class="comment">// 注意这里有两个map</span></span><br><span class="line">    <span class="comment">// 一个为inputVerticesMap，一个为logicalVertexMap</span></span><br><span class="line">    <span class="comment">// inputVerticesMap中存储了节点之间的关系</span></span><br><span class="line">    <span class="comment">// logicalVertexMap存储了节点编号与节点的关系</span></span><br><span class="line">    logicalVertexMap.put(logicalVertexId, logicalVertex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;LogicalEdge&gt; <span class="title function_">createLogicalEdges</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用上面创建的两个map来创建边</span></span><br><span class="line">    <span class="keyword">return</span> inputVerticesMap.entrySet().stream()</span><br><span class="line">            .map(</span><br><span class="line">                    entry -&gt;</span><br><span class="line">                            entry.getValue().stream()</span><br><span class="line">                                    .map(</span><br><span class="line">                                            targetId -&gt;</span><br><span class="line">                                                    <span class="keyword">new</span> <span class="title class_">LogicalEdge</span>(</span><br><span class="line">                                                            logicalVertexMap.get(</span><br><span class="line">                                                                    entry.getKey()),</span><br><span class="line">                                                            logicalVertexMap.get(targetId)))</span><br><span class="line">                                    .collect(Collectors.toList()))</span><br><span class="line">            .flatMap(Collection::stream)</span><br><span class="line">            .collect(Collectors.toCollection(LinkedHashSet::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/375cb007569e00c1171271c8e34f2865c7ac56ee/Pasted%20image%2020240821112058.png"></p>
<p>上面的配置中，会根据上下游关系生成这样的逻辑计划图，并且由于Fake2节点是没有任务下游的，并不会计入到逻辑计划中</p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>至此我们看完了在客户端如何完成一个任务的提交流程<br>小结一下：</p>
<ol>
<li>首先会判断我们执行的模式，当我们是local模式时，会在本机创建一个server节点</li>
<li>然后在当前节点创建一个hazelcast节点，与hazelcast集群进行连接，连接到集群或者刚刚启动的本地节点</li>
<li>接下来判断我们这次的任务类型来调用不同的方法</li>
<li>以提交任务为例，会解析配置文件，并进行逻辑计划解析，在逻辑计划解析时，会在提交的机器上创建Source&#x2F;Transform&#x2F;Sink实例。并且去执行savemode功能，有可能会建表，重建表，删除数据操作（当启用客户端执行时）  </li>
<li>当逻辑计划解析完成后，会将信息编码，然后通过hazelcast的集群通信功能，将信息发送给server的master节点</li>
<li>发送完成后，根据配置决定退出还是继续做任务状态的检测</li>
<li>程序添加hook配置，当客户端退出后取消刚刚提交的任务</li>
</ol>
<hr>
<hr>
<hr>
<h1 id="服务端提交任务相关"><a href="#服务端提交任务相关" class="headerlink" title="服务端提交任务相关"></a>服务端提交任务相关</h1><p>我们再回顾一下当服务端启动后会执行的组件：</p>
<ul>
<li>coordinatorService<br>仅在master&#x2F;standby节点启用，会监听集群状态，主备切换</li>
<li>SlotService<br>在worker节点中启用，会定期上报自身信息到master中</li>
<li>TaskExecutionSerive<br>在worker节点中启用，会定时更新执行的任务指标到IMAP中</li>
</ul>
<p>在集群未接收到任何任务时，会运行这些组件，当Client发送一条<code>SeaTunnelSubmitJobCodec</code>信息到服务端后，服务端又是如何处理的呢？</p>
<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>因为客户端与服务端在不同的机器上，所有这里无法使用方法调用，而是使用了消息传递，当服务端接收到一条消息后是如何进行相关的方法调用的呢<br>首先我们在上面的代码中，知道客户端向服务端发送的是一条类型为<code>SeaTunnelSubmitJobCodec</code>的消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端相关代码</span></span><br><span class="line"><span class="type">ClientMessage</span> <span class="variable">request</span> <span class="operator">=</span></span><br><span class="line">        SeaTunnelSubmitJobCodec.encodeRequest(</span><br><span class="line">                jobImmutableInformation.getJobId(),</span><br><span class="line">                seaTunnelHazelcastClient</span><br><span class="line">                        .getSerializationService()</span><br><span class="line">                        .toData(jobImmutableInformation),</span><br><span class="line">                jobImmutableInformation.isStartWithSavePoint());</span><br><span class="line">PassiveCompletableFuture&lt;Void&gt; submitJobFuture =</span><br><span class="line">        seaTunnelHazelcastClient.requestOnMasterAndGetCompletableFuture(request);</span><br></pre></td></tr></table></figure>

<p>我们进入<code>SeaTunnelSubmitJobCodec</code>这个类，查看他的相关调用类，可以找到一个<code>SeaTunnelMessageTaskFactoryProvider</code>的类，在这个里中维护了一个消息类型到<code>MessageTask</code>的映射关系，也可以理解为客户端消息到服务端调用类的映射关系，以<code>SeaTunnelSubmitJobCodec</code>为例，会返回<code>SubmitJobTask</code>这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Int2ObjectHashMap&lt;MessageTaskFactory&gt; factories = <span class="keyword">new</span> <span class="title class_">Int2ObjectHashMap</span>&lt;&gt;(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFactories</span><span class="params">()</span> &#123;</span><br><span class="line">    factories.put(</span><br><span class="line">            SeaTunnelPrintMessageCodec.REQUEST_MESSAGE_TYPE,</span><br><span class="line">            (clientMessage, connection) -&gt;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">PrintMessageTask</span>(clientMessage, node, connection));</span><br><span class="line">    factories.put(</span><br><span class="line">            SeaTunnelSubmitJobCodec.REQUEST_MESSAGE_TYPE,</span><br><span class="line">            (clientMessage, connection) -&gt; <span class="keyword">new</span> <span class="title class_">SubmitJobTask</span>(clientMessage, node, connection));</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们查看<code>SubmitJobTask</code>这个类时，又会发现继续调用了<code>SubmitJobOperation</code>这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Operation <span class="title function_">prepareOperation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubmitJobOperation</span>(</span><br><span class="line">            parameters.jobId,</span><br><span class="line">            parameters.jobImmutableInformation,</span><br><span class="line">            parameters.isStartWithSavePoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>SubmitJobOperation</code>中我们可以看到真正调用的地方，将我们的信息交给了<code>CoordinatorService</code>组件，调用了其<code>submitJob</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> PassiveCompletableFuture&lt;?&gt; doRun() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">SeaTunnelServer</span> <span class="variable">seaTunnelServer</span> <span class="operator">=</span> getService();</span><br><span class="line">    <span class="keyword">return</span> seaTunnelServer</span><br><span class="line">            .getCoordinatorService()</span><br><span class="line">            .submitJob(jobId, jobImmutableInformation, isStartWithSavePoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时一个客户端的消息就真正的被交给服务端来进行方法调用了，至于其他类型的操作也都可以类似找到相关的类，就不再赘述。</p>
<h3 id="CoordinatorService-1"><a href="#CoordinatorService-1" class="headerlink" title="CoordinatorService"></a>CoordinatorService</h3><p>接下来看下在<code>CoordinatorService</code>是如何进行任务提交的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PassiveCompletableFuture&lt;Void&gt; <span class="title function_">submitJob</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">long</span> jobId, Data jobImmutableInformation, <span class="type">boolean</span> isStartWithSavePoint)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; jobSubmitFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先会根据任务id来判断，当存在相同任务的id时，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (getJobMaster(jobId) != <span class="literal">null</span>) &#123;</span><br><span class="line">        logger.warning(</span><br><span class="line">                String.format(</span><br><span class="line">                        <span class="string">&quot;The job %s is currently running; no need to submit again.&quot;</span>, jobId));</span><br><span class="line">        jobSubmitFuture.complete(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PassiveCompletableFuture</span>&lt;&gt;(jobSubmitFuture);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化JobMaster对象</span></span><br><span class="line">    <span class="type">JobMaster</span> <span class="variable">jobMaster</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">JobMaster</span>(</span><br><span class="line">                    jobImmutableInformation,</span><br><span class="line">                    <span class="built_in">this</span>.nodeEngine,</span><br><span class="line">                    executorService,</span><br><span class="line">                    getResourceManager(),</span><br><span class="line">                    getJobHistoryService(),</span><br><span class="line">                    runningJobStateIMap,</span><br><span class="line">                    runningJobStateTimestampsIMap,</span><br><span class="line">                    ownedSlotProfilesIMap,</span><br><span class="line">                    runningJobInfoIMap,</span><br><span class="line">                    metricsImap,</span><br><span class="line">                    engineConfig,</span><br><span class="line">                    seaTunnelServer);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    executorService.submit(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 由于2.3.6中任务id可以由用户传递，而在seatunnel中会根据任务id来做一些状态判断</span></span><br><span class="line">                <span class="comment">// 所以这里的检查是保证在当前的状态中，不会存在相同id的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (!isStartWithSavePoint</span><br><span class="line">                            &amp;&amp; getJobHistoryService().getJobMetrics(jobId) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JobException</span>(</span><br><span class="line">                                String.format(</span><br><span class="line">                                        <span class="string">&quot;The job id %s has already been submitted and is not starting with a savepoint.&quot;</span>,</span><br><span class="line">                                        jobId));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将当前任务的信息添加到IMAP中</span></span><br><span class="line">                    runningJobInfoIMap.put(</span><br><span class="line">                            jobId,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">JobInfo</span>(System.currentTimeMillis(), jobImmutableInformation));</span><br><span class="line">                    runningJobMasterMap.put(jobId, jobMaster);</span><br><span class="line">                    <span class="comment">// 对JobMaster做初始化操作</span></span><br><span class="line">                    jobMaster.init(</span><br><span class="line">                            runningJobInfoIMap.get(jobId).getInitializationTimestamp(), <span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">// 当jobMaster初始化完成后，会认为任务创建成功</span></span><br><span class="line">                    jobSubmitFuture.complete(<span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> ExceptionUtils.getMessage(e);</span><br><span class="line">                    logger.severe(String.format(<span class="string">&quot;submit job %s error %s &quot;</span>, jobId, errorMsg));</span><br><span class="line">                    jobSubmitFuture.completeExceptionally(<span class="keyword">new</span> <span class="title class_">JobException</span>(errorMsg));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!jobSubmitFuture.isCompletedExceptionally()) &#123;</span><br><span class="line">                <span class="comment">// 当任务正常提交后，调用jobMaster的run方法开始执行任务</span></span><br><span class="line">                <span class="comment">// 以及最后会检查任务状态，从内部状态中将此次任务信息删除</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        jobMaster.run();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// voidCompletableFuture will be cancelled when zeta master node</span></span><br><span class="line">                        <span class="comment">// shutdown to simulate master failure,</span></span><br><span class="line">                        <span class="comment">// don&#x27;t update runningJobMasterMap is this case.</span></span><br><span class="line">                        <span class="keyword">if</span> (!jobMaster.getJobMasterCompleteFuture().isCancelled()) &#123;</span><br><span class="line">                            runningJobMasterMap.remove(jobId);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    runningJobInfoIMap.remove(jobId);</span><br><span class="line">                    runningJobMasterMap.remove(jobId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PassiveCompletableFuture</span>&lt;&gt;(jobSubmitFuture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在服务端，会通过创建一个<code>JobMaster</code>对象，由这个对象来进行单个任务的管理。</p>
<p>在创建JobMaster对象时，会通过<code>getResourceManager</code>方法来获取资源管理对象，以及通过<code>getJobHistoryService</code>方法获取任务历史信息，<code>jobHistoryService</code>在启动时就会创建完成，<code>ResourceManage</code>则采用了懒加载的方式，在第一次有任务提交之后才会进行创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lazy load for resource manager */</span></span><br><span class="line"><span class="keyword">public</span> ResourceManager <span class="title function_">getResourceManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resourceManager == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resourceManager == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ResourceManager</span> <span class="variable">manager</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ResourceManagerFactory</span>(nodeEngine, engineConfig)</span><br><span class="line">                                .getResourceManager();</span><br><span class="line">                manager.init();</span><br><span class="line">                resourceManager = manager;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resourceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h4><p>目前seatunnel也仅支持standalone的部署方式，当初始化ResourceManager时，会获取到集群所有节点，然后向其发送<code>SyncWorkerProfileOperation</code>操作来获取节点的信息，然后更新到内部的<code>registerWorker</code>状态中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;Init ResourceManager&quot;</span>);</span><br><span class="line">    initWorker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initWorker</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;initWorker... &quot;</span>);</span><br><span class="line">    List&lt;Address&gt; aliveNode =</span><br><span class="line">            nodeEngine.getClusterService().getMembers().stream()</span><br><span class="line">                    .map(Member::getAddress)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">    log.info(<span class="string">&quot;init live nodes: &#123;&#125;&quot;</span>, aliveNode);</span><br><span class="line">    List&lt;CompletableFuture&lt;Void&gt;&gt; futures =</span><br><span class="line">            aliveNode.stream()</span><br><span class="line">                    .map(</span><br><span class="line">                            node -&gt;</span><br><span class="line">                                    sendToMember(<span class="keyword">new</span> <span class="title class_">SyncWorkerProfileOperation</span>(), node)</span><br><span class="line">                                            .thenAccept(</span><br><span class="line">                                                    p -&gt; &#123;</span><br><span class="line">                                                        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">                                                            registerWorker.put(</span><br><span class="line">                                                                    node, (WorkerProfile) p);</span><br><span class="line">                                                            log.info(</span><br><span class="line">                                                                    <span class="string">&quot;received new worker register: &quot;</span></span><br><span class="line">                                                                            + ((WorkerProfile)</span><br><span class="line">                                                                                            p)</span><br><span class="line">                                                                                    .getAddress());</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                    &#125;))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">    futures.forEach(CompletableFuture::join);</span><br><span class="line">    log.info(<span class="string">&quot;registerWorker: &#123;&#125;&quot;</span>, registerWorker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们之前在<code>SlotService</code>中注意到在每个节点会定时向master发送心跳信息，心跳信息里面包含了当前节点的状态，在ResourceManager中当接收到心跳信息后，也会在内部状态中更新每个节点的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heartbeat</span><span class="params">(WorkerProfile workerProfile)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!registerWorker.containsKey(workerProfile.getAddress())) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;received new worker register: &quot;</span> + workerProfile.getAddress());</span><br><span class="line">        sendToMember(<span class="keyword">new</span> <span class="title class_">ResetResourceOperation</span>(), workerProfile.getAddress()).join();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;received worker heartbeat from: &quot;</span> + workerProfile.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">    registerWorker.put(workerProfile.getAddress(), workerProfile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JobMaster"><a href="#JobMaster" class="headerlink" title="JobMaster"></a>JobMaster</h3><p>在<code>CoordinatorService</code>中会创建JobMaster并调用其init方法，当init方法完成后会认为任务创建成功。然后再调用run方法来正式运行任务</p>
<p>我们看一下初始化以及init方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JobMaster</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> Data jobImmutableInformationData,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> NodeEngine nodeEngine,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> ExecutorService executorService,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> ResourceManager resourceManager,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> JobHistoryService jobHistoryService,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IMap runningJobStateIMap,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IMap runningJobStateTimestampsIMap,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IMap ownedSlotProfilesIMap,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IMap&lt;Long, JobInfo&gt; runningJobInfoIMap,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IMap&lt;Long, HashMap&lt;TaskLocation, SeaTunnelMetricsContext&gt;&gt; metricsImap,</span></span><br><span class="line"><span class="params">        EngineConfig engineConfig,</span></span><br><span class="line"><span class="params">        SeaTunnelServer seaTunnelServer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.jobImmutableInformationData = jobImmutableInformationData;</span><br><span class="line">    <span class="built_in">this</span>.nodeEngine = nodeEngine;</span><br><span class="line">    <span class="built_in">this</span>.executorService = executorService;</span><br><span class="line">    flakeIdGenerator =</span><br><span class="line">            <span class="built_in">this</span>.nodeEngine</span><br><span class="line">                    .getHazelcastInstance()</span><br><span class="line">                    .getFlakeIdGenerator(Constant.SEATUNNEL_ID_GENERATOR_NAME);</span><br><span class="line">    <span class="built_in">this</span>.ownedSlotProfilesIMap = ownedSlotProfilesIMap;</span><br><span class="line">    <span class="built_in">this</span>.resourceManager = resourceManager;</span><br><span class="line">    <span class="built_in">this</span>.jobHistoryService = jobHistoryService;</span><br><span class="line">    <span class="built_in">this</span>.runningJobStateIMap = runningJobStateIMap;</span><br><span class="line">    <span class="built_in">this</span>.runningJobStateTimestampsIMap = runningJobStateTimestampsIMap;</span><br><span class="line">    <span class="built_in">this</span>.runningJobInfoIMap = runningJobInfoIMap;</span><br><span class="line">    <span class="built_in">this</span>.engineConfig = engineConfig;</span><br><span class="line">    <span class="built_in">this</span>.metricsImap = metricsImap;</span><br><span class="line">    <span class="built_in">this</span>.seaTunnelServer = seaTunnelServer;</span><br><span class="line">    <span class="built_in">this</span>.releasedSlotWhenTaskGroupFinished = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化时只是进行简单的变量赋值，并没有进行什么操作，我们需要着重看下init方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">long</span> initializationTimestamp, <span class="type">boolean</span> restart)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="comment">// 服务端接收到客户端传递过来的消息是一个二进制的对象</span></span><br><span class="line">     <span class="comment">// 首先将其转换为JobImmutableInformation对象，而这个对象也正是客户端发送给服务端的对象</span></span><br><span class="line">    jobImmutableInformation =</span><br><span class="line">            nodeEngine.getSerializationService().toObject(jobImmutableInformationData);</span><br><span class="line">    <span class="comment">// 获取checkpoint的相关配置，例如周期，超时时间等</span></span><br><span class="line">    jobCheckpointConfig =</span><br><span class="line">            createJobCheckpointConfig(</span><br><span class="line">                    engineConfig.getCheckpointConfig(), jobImmutableInformation.getJobConfig());</span><br><span class="line"></span><br><span class="line">    LOGGER.info(</span><br><span class="line">            String.format(</span><br><span class="line">                    <span class="string">&quot;Init JobMaster for Job %s (%s) &quot;</span>,</span><br><span class="line">                    jobImmutableInformation.getJobConfig().getName(),</span><br><span class="line">                    jobImmutableInformation.getJobId()));</span><br><span class="line">    LOGGER.info(</span><br><span class="line">            String.format(</span><br><span class="line">                    <span class="string">&quot;Job %s (%s) needed jar urls %s&quot;</span>,</span><br><span class="line">                    jobImmutableInformation.getJobConfig().getName(),</span><br><span class="line">                    jobImmutableInformation.getJobId(),</span><br><span class="line">                    jobImmutableInformation.getPluginJarsUrls()));</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">appClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="comment">// 获取ClassLoader</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span></span><br><span class="line">            seaTunnelServer</span><br><span class="line">                    .getClassLoaderService()</span><br><span class="line">                    .getClassLoader(</span><br><span class="line">                            jobImmutableInformation.getJobId(),</span><br><span class="line">                            jobImmutableInformation.getPluginJarsUrls());</span><br><span class="line">    <span class="comment">// 将客户端传递的信息反序列化为逻辑计划</span></span><br><span class="line">    logicalDag =</span><br><span class="line">            CustomClassLoadedObject.deserializeWithCustomClassLoader(</span><br><span class="line">                    nodeEngine.getSerializationService(),</span><br><span class="line">                    classLoader,</span><br><span class="line">                    jobImmutableInformation.getLogicalDag());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">        <span class="comment">// 在服务端会执行savemode的功能，例如对表进行创建，删除操作。</span></span><br><span class="line">        <span class="keyword">if</span> (!restart</span><br><span class="line">                &amp;&amp; !logicalDag.isStartWithSavePoint()</span><br><span class="line">                &amp;&amp; ReadonlyConfig.fromMap(logicalDag.getJobConfig().getEnvOptions())</span><br><span class="line">                        .get(EnvCommonOptions.SAVEMODE_EXECUTE_LOCATION)</span><br><span class="line">                        .equals(SaveModeExecuteLocation.CLUSTER)) &#123;</span><br><span class="line">            logicalDag.getLogicalVertexMap().values().stream()</span><br><span class="line">                    .map(LogicalVertex::getAction)</span><br><span class="line">                    .filter(action -&gt; action <span class="keyword">instanceof</span> SinkAction)</span><br><span class="line">                    .map(sink -&gt; ((SinkAction&lt;?, ?, ?, ?&gt;) sink).getSink())</span><br><span class="line">                    .forEach(JobMaster::handleSaveMode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逻辑计划到物理计划的解析</span></span><br><span class="line">        <span class="keyword">final</span> Tuple2&lt;PhysicalPlan, Map&lt;Integer, CheckpointPlan&gt;&gt; planTuple =</span><br><span class="line">                PlanUtils.fromLogicalDAG(</span><br><span class="line">                        logicalDag,</span><br><span class="line">                        nodeEngine,</span><br><span class="line">                        jobImmutableInformation,</span><br><span class="line">                        initializationTimestamp,</span><br><span class="line">                        executorService,</span><br><span class="line">                        flakeIdGenerator,</span><br><span class="line">                        runningJobStateIMap,</span><br><span class="line">                        runningJobStateTimestampsIMap,</span><br><span class="line">                        engineConfig.getQueueType(),</span><br><span class="line">                        engineConfig);</span><br><span class="line">        <span class="built_in">this</span>.physicalPlan = planTuple.f0();</span><br><span class="line">        <span class="built_in">this</span>.physicalPlan.setJobMaster(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.checkpointPlanMap = planTuple.f1();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 重置当前线程的ClassLoader，并且释放上面创建的classLoader</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(appClassLoader);</span><br><span class="line">        seaTunnelServer</span><br><span class="line">                .getClassLoaderService()</span><br><span class="line">                .releaseClassLoader(</span><br><span class="line">                        jobImmutableInformation.getJobId(),</span><br><span class="line">                        jobImmutableInformation.getPluginJarsUrls());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">initException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化checkpointManager</span></span><br><span class="line">        <span class="built_in">this</span>.initCheckPointManager(restart);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        initException = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加一些回调函数做任务状态监听</span></span><br><span class="line">    <span class="built_in">this</span>.initStateFuture();</span><br><span class="line">    <span class="keyword">if</span> (initException != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (restart) &#123;</span><br><span class="line">            cancelJob();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> initException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后再看下run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        physicalPlan.startJob();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        LOGGER.severe(</span><br><span class="line">                String.format(</span><br><span class="line">                        <span class="string">&quot;Job %s (%s) run error with: %s&quot;</span>,</span><br><span class="line">                        physicalPlan.getJobImmutableInformation().getJobConfig().getName(),</span><br><span class="line">                        physicalPlan.getJobImmutableInformation().getJobId(),</span><br><span class="line">                        ExceptionUtils.getMessage(e)));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        jobMasterCompleteFuture.join();</span><br><span class="line">        <span class="keyword">if</span> (engineConfig.getConnectorJarStorageConfig().getEnable()) &#123;</span><br><span class="line">            List&lt;ConnectorJarIdentifier&gt; pluginJarIdentifiers =</span><br><span class="line">                    jobImmutableInformation.getPluginJarIdentifiers();</span><br><span class="line">            seaTunnelServer</span><br><span class="line">                    .getConnectorPackageService()</span><br><span class="line">                    .cleanUpWhenJobFinished(</span><br><span class="line">                            jobImmutableInformation.getJobId(), pluginJarIdentifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法比较简单，调用<code>physicalPlan.startJob()</code>对生成的物理计划调用<code>run</code>方法</p>
<p>通过以上代码可以看出，当服务端接收到客户端提交任务请求后，会初始化JobMaster类，在JobMaster中完成了从逻辑计划到物理计划的生成，最终执行生成的物理计划。</p>
<p>下面需要深入看下如何从逻辑计划生成物理计划</p>
<h3 id="逻辑计划到物理计划"><a href="#逻辑计划到物理计划" class="headerlink" title="逻辑计划到物理计划"></a>逻辑计划到物理计划</h3><p>物理计划的生成是由JobMaster中调用生成的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Tuple2&lt;PhysicalPlan, Map&lt;Integer, CheckpointPlan&gt;&gt; planTuple =</span><br><span class="line">        PlanUtils.fromLogicalDAG(</span><br><span class="line">                logicalDag,</span><br><span class="line">                nodeEngine,</span><br><span class="line">                jobImmutableInformation,</span><br><span class="line">                initializationTimestamp,</span><br><span class="line">                executorService,</span><br><span class="line">                flakeIdGenerator,</span><br><span class="line">                runningJobStateIMap,</span><br><span class="line">                runningJobStateTimestampsIMap,</span><br><span class="line">                engineConfig.getQueueType(),</span><br><span class="line">                engineConfig);</span><br></pre></td></tr></table></figure>

<p>在生成的方法中可以看到中间会先从逻辑计划生成执行计划，然后再由执行计划生成物理计划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Tuple2&lt;PhysicalPlan, Map&lt;Integer, CheckpointPlan&gt;&gt; <span class="title function_">fromLogicalDAG</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> LogicalDag logicalDag,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> NodeEngine nodeEngine,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> JobImmutableInformation jobImmutableInformation,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> initializationTimestamp,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> ExecutorService executorService,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> FlakeIdGenerator flakeIdGenerator,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IMap runningJobStateIMap,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IMap runningJobStateTimestampsIMap,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> QueueType queueType,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> EngineConfig engineConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PhysicalPlanGenerator</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ExecutionPlanGenerator</span>(</span><br><span class="line">                                    logicalDag, jobImmutableInformation, engineConfig)</span><br><span class="line">                            .generate(),</span><br><span class="line">                    nodeEngine,</span><br><span class="line">                    jobImmutableInformation,</span><br><span class="line">                    initializationTimestamp,</span><br><span class="line">                    executorService,</span><br><span class="line">                    flakeIdGenerator,</span><br><span class="line">                    runningJobStateIMap,</span><br><span class="line">                    runningJobStateTimestampsIMap,</span><br><span class="line">                    queueType)</span><br><span class="line">            .generate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行计划的生成"><a href="#执行计划的生成" class="headerlink" title="执行计划的生成"></a>执行计划的生成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ExecutionPlanGenerator</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> LogicalDag logicalPlan,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> JobImmutableInformation jobImmutableInformation,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> EngineConfig engineConfig)</span> &#123;</span><br><span class="line">    checkArgument(</span><br><span class="line">            logicalPlan.getEdges().size() &gt; <span class="number">0</span>, <span class="string">&quot;ExecutionPlan Builder must have LogicalPlan.&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.logicalPlan = logicalPlan;</span><br><span class="line">    <span class="built_in">this</span>.jobImmutableInformation = jobImmutableInformation;</span><br><span class="line">    <span class="built_in">this</span>.engineConfig = engineConfig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ExecutionPlan <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;Generate execution plan using logical plan:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;ExecutionEdge&gt; executionEdges = generateExecutionEdges(logicalPlan.getEdges());</span><br><span class="line">    log.debug(<span class="string">&quot;Phase 1: generate execution edge list &#123;&#125;&quot;</span>, executionEdges);</span><br><span class="line"></span><br><span class="line">    executionEdges = generateShuffleEdges(executionEdges);</span><br><span class="line">    log.debug(<span class="string">&quot;Phase 2: generate shuffle edge list &#123;&#125;&quot;</span>, executionEdges);</span><br><span class="line"></span><br><span class="line">    executionEdges = generateTransformChainEdges(executionEdges);</span><br><span class="line">    log.debug(<span class="string">&quot;Phase 3: generate transform chain edge list &#123;&#125;&quot;</span>, executionEdges);</span><br><span class="line"></span><br><span class="line">    List&lt;Pipeline&gt; pipelines = generatePipelines(executionEdges);</span><br><span class="line">    log.debug(<span class="string">&quot;Phase 4: generate pipeline list &#123;&#125;&quot;</span>, pipelines);</span><br><span class="line"></span><br><span class="line">    <span class="type">ExecutionPlan</span> <span class="variable">executionPlan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutionPlan</span>(pipelines, jobImmutableInformation);</span><br><span class="line">    log.debug(<span class="string">&quot;Phase 5: generate execution plan: &#123;&#125;&quot;</span>, executionPlan);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> executionPlan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看下执行计划这个类里面有什么内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutionPlan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Pipeline&gt; pipelines;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobImmutableInformation jobImmutableInformation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pipeline</span> &#123;</span><br><span class="line">    <span class="comment">/** The ID of the pipeline. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExecutionEdge&gt; edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, ExecutionVertex&gt; vertexes;</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutionEdge</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ExecutionVertex leftVertex;</span><br><span class="line">    <span class="keyword">private</span> ExecutionVertex rightVertex;  </span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutionVertex</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long vertexId;</span><br><span class="line">    <span class="keyword">private</span> Action action;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> parallelism;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>我们再与逻辑计划比较一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogicalDag</span> <span class="keyword">implements</span> <span class="title class_">IdentifiedDataSerializable</span> &#123;</span><br><span class="line">    <span class="meta">@Getter</span> <span class="keyword">private</span> JobConfig jobConfig;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;LogicalEdge&gt; edges = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, LogicalVertex&gt; logicalVertexMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> IdGenerator idGenerator;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isStartWithSavePoint</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogicalEdge</span> <span class="keyword">implements</span> <span class="title class_">IdentifiedDataSerializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LogicalVertex inputVertex;</span><br><span class="line">    <span class="keyword">private</span> LogicalVertex targetVertex;</span><br><span class="line">    <span class="keyword">private</span> Long inputVertexId;</span><br><span class="line">    <span class="keyword">private</span> Long targetVertexId;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogicalVertex</span> <span class="keyword">implements</span> <span class="title class_">IdentifiedDataSerializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long vertexId;</span><br><span class="line">    <span class="keyword">private</span> Action action;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> parallelism;  </span><br><span class="line"> &#125;        </span><br></pre></td></tr></table></figure>

<p>我们看这两个类的内容，感觉每个Pipeline都像一个逻辑计划，为什么需要这一步转换呢，我们来具体看下逻辑计划的生成过程。<br>在上面可以看到生成执行计划共有5步，我们逐步看下</p>
<ul>
<li><p>第一步：逻辑计划转执行计划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参是逻辑计划的边，每个边存储了上下游的节点</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;ExecutionEdge&gt; <span class="title function_">generateExecutionEdges</span><span class="params">(Set&lt;LogicalEdge&gt; logicalEdges)</span> &#123;</span><br><span class="line">    Set&lt;ExecutionEdge&gt; executionEdges = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Map&lt;Long, ExecutionVertex&gt; logicalVertexIdToExecutionVertexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="comment">// 按照顺序进行排序，首先按照输入节点的顺序进行排序，当输入节点相同时，按照输出节点进行排序</span></span><br><span class="line">    List&lt;LogicalEdge&gt; sortedLogicalEdges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(logicalEdges);</span><br><span class="line">    Collections.sort(</span><br><span class="line">            sortedLogicalEdges,</span><br><span class="line">            (o1, o2) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.getInputVertexId() != o2.getInputVertexId()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.getInputVertexId() &gt; o2.getInputVertexId() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (o1.getTargetVertexId() != o2.getTargetVertexId()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.getTargetVertexId() &gt; o2.getTargetVertexId() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// 循环将每个逻辑计划的边转换为执行计划的边         </span></span><br><span class="line">    <span class="keyword">for</span> (LogicalEdge logicalEdge : sortedLogicalEdges) &#123;</span><br><span class="line">        <span class="type">LogicalVertex</span> <span class="variable">logicalInputVertex</span> <span class="operator">=</span> logicalEdge.getInputVertex();</span><br><span class="line">        <span class="type">ExecutionVertex</span> <span class="variable">executionInputVertex</span> <span class="operator">=</span></span><br><span class="line">                logicalVertexIdToExecutionVertexMap.computeIfAbsent(</span><br><span class="line">                        logicalInputVertex.getVertexId(),</span><br><span class="line">                        vertexId -&gt; &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">newId</span> <span class="operator">=</span> idGenerator.getNextId();</span><br><span class="line">                            <span class="comment">// 对每个逻辑计划节点重新创建Action</span></span><br><span class="line">                            <span class="type">Action</span> <span class="variable">newLogicalInputAction</span> <span class="operator">=</span></span><br><span class="line">                                    recreateAction(</span><br><span class="line">                                            logicalInputVertex.getAction(),</span><br><span class="line">                                            newId,</span><br><span class="line">                                            logicalInputVertex.getParallelism());</span><br><span class="line">                            <span class="comment">// 转换为执行计划节点</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecutionVertex</span>(</span><br><span class="line">                                    newId,</span><br><span class="line">                                    newLogicalInputAction,</span><br><span class="line">                                    logicalInputVertex.getParallelism());</span><br><span class="line">                        &#125;);</span><br><span class="line">        <span class="comment">// 与输入节点类似，重新创建执行计划节点</span></span><br><span class="line">        <span class="type">LogicalVertex</span> <span class="variable">logicalTargetVertex</span> <span class="operator">=</span> logicalEdge.getTargetVertex();</span><br><span class="line">        <span class="type">ExecutionVertex</span> <span class="variable">executionTargetVertex</span> <span class="operator">=</span></span><br><span class="line">                logicalVertexIdToExecutionVertexMap.computeIfAbsent(</span><br><span class="line">                        logicalTargetVertex.getVertexId(),</span><br><span class="line">                        vertexId -&gt; &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">newId</span> <span class="operator">=</span> idGenerator.getNextId();</span><br><span class="line">                            <span class="type">Action</span> <span class="variable">newLogicalTargetAction</span> <span class="operator">=</span></span><br><span class="line">                                    recreateAction(</span><br><span class="line">                                            logicalTargetVertex.getAction(),</span><br><span class="line">                                            newId,</span><br><span class="line">                                            logicalTargetVertex.getParallelism());</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecutionVertex</span>(</span><br><span class="line">                                    newId,</span><br><span class="line">                                    newLogicalTargetAction,</span><br><span class="line">                                    logicalTargetVertex.getParallelism());</span><br><span class="line">                        &#125;);</span><br><span class="line">        <span class="comment">// 生成执行计划的边</span></span><br><span class="line">        <span class="type">ExecutionEdge</span> <span class="variable">executionEdge</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ExecutionEdge</span>(executionInputVertex, executionTargetVertex);</span><br><span class="line">        executionEdges.add(executionEdge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executionEdges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;ExecutionEdge&gt; <span class="title function_">generateShuffleEdges</span><span class="params">(Set&lt;ExecutionEdge&gt; executionEdges)</span> &#123;</span><br><span class="line">    <span class="comment">// 以上游节点编号为key，list存储下游所有节点</span></span><br><span class="line">    Map&lt;Long, List&lt;ExecutionVertex&gt;&gt; targetVerticesMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 仅存储类型为Source的节点</span></span><br><span class="line">    Set&lt;ExecutionVertex&gt; sourceExecutionVertices = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    executionEdges.forEach(</span><br><span class="line">            edge -&gt; &#123;</span><br><span class="line">                <span class="type">ExecutionVertex</span> <span class="variable">leftVertex</span> <span class="operator">=</span> edge.getLeftVertex();</span><br><span class="line">                <span class="type">ExecutionVertex</span> <span class="variable">rightVertex</span> <span class="operator">=</span> edge.getRightVertex();</span><br><span class="line">                <span class="keyword">if</span> (leftVertex.getAction() <span class="keyword">instanceof</span> SourceAction) &#123;</span><br><span class="line">                    sourceExecutionVertices.add(leftVertex);</span><br><span class="line">                &#125;</span><br><span class="line">                targetVerticesMap</span><br><span class="line">                        .computeIfAbsent(leftVertex.getVertexId(), id -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">                        .add(rightVertex);</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">if</span> (sourceExecutionVertices.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> executionEdges;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ExecutionVertex</span> <span class="variable">sourceExecutionVertex</span> <span class="operator">=</span> sourceExecutionVertices.stream().findFirst().get();</span><br><span class="line">    <span class="type">Action</span> <span class="variable">sourceAction</span> <span class="operator">=</span> sourceExecutionVertex.getAction();</span><br><span class="line">    List&lt;CatalogTable&gt; producedCatalogTables = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (sourceAction <span class="keyword">instanceof</span> SourceAction) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producedCatalogTables =</span><br><span class="line">                    ((SourceAction&lt;?, ?, ?&gt;) sourceAction)</span><br><span class="line">                            .getSource()</span><br><span class="line">                            .getProducedCatalogTables();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sourceAction <span class="keyword">instanceof</span> TransformChainAction) &#123;</span><br><span class="line">        <span class="keyword">return</span> executionEdges;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SeaTunnelException</span>(</span><br><span class="line">                <span class="string">&quot;source action must be SourceAction or TransformChainAction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据源仅产生单表或</span></span><br><span class="line">    <span class="comment">// 数据源仅有一个下游输出时，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (producedCatalogTables.size() &lt;= <span class="number">1</span></span><br><span class="line">            || targetVerticesMap.get(sourceExecutionVertex.getVertexId()).size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> executionEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;ExecutionVertex&gt; sinkVertices =</span><br><span class="line">            targetVerticesMap.get(sourceExecutionVertex.getVertexId());</span><br><span class="line">    <span class="comment">// 检查是否有其他类型的Action，在当前步骤下游节点尽可能有两种类型，Transform与Sink，这里是判断仅能有Sink类型</span></span><br><span class="line">    Optional&lt;ExecutionVertex&gt; hasOtherAction =</span><br><span class="line">            sinkVertices.stream()</span><br><span class="line">                    .filter(vertex -&gt; !(vertex.getAction() <span class="keyword">instanceof</span> SinkAction))</span><br><span class="line">                    .findFirst();</span><br><span class="line">    </span><br><span class="line">    checkArgument(!hasOtherAction.isPresent());</span><br><span class="line">    <span class="comment">// 当以上代码全部走完之后，当前的场景为：</span></span><br><span class="line">    <span class="comment">// 仅有一个数据源，该数据源会产生多张表，下游还有多个sink节点依赖与产生的多表</span></span><br><span class="line">    <span class="comment">// 也就是说当前任务仅有两类节点，一个会产生多张表的Source节点，一组依赖与该Source的Sink节点</span></span><br><span class="line">    <span class="comment">// 那么会新生成一个shuffle节点，添加到两者之间</span></span><br><span class="line">    <span class="comment">// 将依赖关系修改与source-&gt;shuffle-&gt;多个sink</span></span><br><span class="line">    Set&lt;ExecutionEdge&gt; newExecutionEdges = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 这里的Shuffle策略此次不深入了解了</span></span><br><span class="line">    <span class="type">ShuffleStrategy</span> <span class="variable">shuffleStrategy</span> <span class="operator">=</span></span><br><span class="line">            ShuffleMultipleRowStrategy.builder()</span><br><span class="line">                    .jobId(jobImmutableInformation.getJobId())</span><br><span class="line">                    .inputPartitions(sourceAction.getParallelism())</span><br><span class="line">                    .catalogTables(producedCatalogTables)</span><br><span class="line">                    .queueEmptyQueueTtl(</span><br><span class="line">                            (<span class="type">int</span>)</span><br><span class="line">                                    (engineConfig.getCheckpointConfig().getCheckpointInterval()</span><br><span class="line">                                            * <span class="number">3</span>))</span><br><span class="line">                    .build();</span><br><span class="line">    <span class="type">ShuffleConfig</span> <span class="variable">shuffleConfig</span> <span class="operator">=</span></span><br><span class="line">            ShuffleConfig.builder().shuffleStrategy(shuffleStrategy).build();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">shuffleVertexId</span> <span class="operator">=</span> idGenerator.getNextId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">shuffleActionName</span> <span class="operator">=</span> String.format(<span class="string">&quot;Shuffle [%s]&quot;</span>, sourceAction.getName());</span><br><span class="line">    <span class="type">ShuffleAction</span> <span class="variable">shuffleAction</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ShuffleAction</span>(shuffleVertexId, shuffleActionName, shuffleConfig);</span><br><span class="line">    shuffleAction.setParallelism(sourceAction.getParallelism());</span><br><span class="line">    <span class="type">ExecutionVertex</span> <span class="variable">shuffleVertex</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExecutionVertex</span>(shuffleVertexId, shuffleAction, shuffleAction.getParallelism());</span><br><span class="line">    <span class="type">ExecutionEdge</span> <span class="variable">sourceToShuffleEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutionEdge</span>(sourceExecutionVertex, shuffleVertex);</span><br><span class="line">    newExecutionEdges.add(sourceToShuffleEdge);</span><br><span class="line">    <span class="comment">// 将多个sink节点的并行度修改为1</span></span><br><span class="line">    <span class="keyword">for</span> (ExecutionVertex sinkVertex : sinkVertices) &#123;</span><br><span class="line">        sinkVertex.setParallelism(<span class="number">1</span>);</span><br><span class="line">        sinkVertex.getAction().setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ExecutionEdge</span> <span class="variable">shuffleToSinkEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutionEdge</span>(shuffleVertex, sinkVertex);</span><br><span class="line">        newExecutionEdges.add(shuffleToSinkEdge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newExecutionEdges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这一步Shuffle是针对某些特殊场景，source支持多表读取，并且有多个sink节点依赖与该source节点时会在中间添加一个shuffle节点</p>
<ul>
<li>第三步</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;ExecutionEdge&gt; <span class="title function_">generateTransformChainEdges</span><span class="params">(Set&lt;ExecutionEdge&gt; executionEdges)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用了三个结构，存储所有的Source节点，以及每个输入，输出节点</span></span><br><span class="line">    <span class="comment">// inputVerticesMap中以下游节点id为key，存储了所有的上游输入节点</span></span><br><span class="line">    <span class="comment">// targetVerticesMap则以上游节点id为key，存储了所有的下游输出节点</span></span><br><span class="line">    Map&lt;Long, List&lt;ExecutionVertex&gt;&gt; inputVerticesMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Long, List&lt;ExecutionVertex&gt;&gt; targetVerticesMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;ExecutionVertex&gt; sourceExecutionVertices = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    executionEdges.forEach(</span><br><span class="line">            edge -&gt; &#123;</span><br><span class="line">                <span class="type">ExecutionVertex</span> <span class="variable">leftVertex</span> <span class="operator">=</span> edge.getLeftVertex();</span><br><span class="line">                <span class="type">ExecutionVertex</span> <span class="variable">rightVertex</span> <span class="operator">=</span> edge.getRightVertex();</span><br><span class="line">                <span class="keyword">if</span> (leftVertex.getAction() <span class="keyword">instanceof</span> SourceAction) &#123;</span><br><span class="line">                    sourceExecutionVertices.add(leftVertex);</span><br><span class="line">                &#125;</span><br><span class="line">                inputVerticesMap</span><br><span class="line">                        .computeIfAbsent(rightVertex.getVertexId(), id -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">                        .add(leftVertex);</span><br><span class="line">                targetVerticesMap</span><br><span class="line">                        .computeIfAbsent(leftVertex.getVertexId(), id -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">                        .add(rightVertex);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    Map&lt;Long, ExecutionVertex&gt; transformChainVertexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Long, Long&gt; chainedTransformVerticesMapping = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 对每个source进行循环，即从DAG中所有的头节点开始变量</span></span><br><span class="line">    <span class="keyword">for</span> (ExecutionVertex sourceVertex : sourceExecutionVertices) &#123;</span><br><span class="line">        List&lt;ExecutionVertex&gt; vertices = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        vertices.add(sourceVertex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; vertices.size(); index++) &#123;</span><br><span class="line">            <span class="type">ExecutionVertex</span> <span class="variable">vertex</span> <span class="operator">=</span> vertices.get(index);</span><br><span class="line"></span><br><span class="line">            fillChainedTransformExecutionVertex(</span><br><span class="line">                    vertex,</span><br><span class="line">                    chainedTransformVerticesMapping,</span><br><span class="line">                    transformChainVertexMap,</span><br><span class="line">                    executionEdges,</span><br><span class="line">                    Collections.unmodifiableMap(inputVerticesMap),</span><br><span class="line">                    Collections.unmodifiableMap(targetVerticesMap));</span><br><span class="line">            <span class="comment">// 当当前节点存在下游节点时，将所有下游节点放入list中，二层循环会重新计算刚刚加入进去的下游节点，可能是Transform节点也可能是Sink节点</span></span><br><span class="line">            <span class="keyword">if</span> (targetVerticesMap.containsKey(vertex.getVertexId())) &#123;</span><br><span class="line">                vertices.addAll(targetVerticesMap.get(vertex.getVertexId()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环完成，会将可以链化的Transform节点进行链化，在链化过程中会将可以链化的关系边从执行计划中删除</span></span><br><span class="line">    <span class="comment">// 所以此时的逻辑计划已经无法构成图的关系，需要重新构建</span></span><br><span class="line">    Set&lt;ExecutionEdge&gt; transformChainEdges = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 对现存关系进行循环</span></span><br><span class="line">    <span class="keyword">for</span> (ExecutionEdge executionEdge : executionEdges) &#123;</span><br><span class="line">        <span class="type">ExecutionVertex</span> <span class="variable">leftVertex</span> <span class="operator">=</span> executionEdge.getLeftVertex();</span><br><span class="line">        <span class="type">ExecutionVertex</span> <span class="variable">rightVertex</span> <span class="operator">=</span> executionEdge.getRightVertex();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needRebuild</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 会从链化的map中查询当前边的输入，输出节点</span></span><br><span class="line">        <span class="comment">// 如果在链化的map中存在，则表明该节点已经被链化，需要从映射关系中找到链化之后的节点</span></span><br><span class="line">        <span class="comment">// 重新修正DAG</span></span><br><span class="line">        <span class="keyword">if</span> (chainedTransformVerticesMapping.containsKey(leftVertex.getVertexId())) &#123;</span><br><span class="line">            needRebuild = <span class="literal">true</span>;</span><br><span class="line">            leftVertex =</span><br><span class="line">                    transformChainVertexMap.get(</span><br><span class="line">                            chainedTransformVerticesMapping.get(leftVertex.getVertexId()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chainedTransformVerticesMapping.containsKey(rightVertex.getVertexId())) &#123;</span><br><span class="line">            needRebuild = <span class="literal">true</span>;</span><br><span class="line">            rightVertex =</span><br><span class="line">                    transformChainVertexMap.get(</span><br><span class="line">                            chainedTransformVerticesMapping.get(rightVertex.getVertexId()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needRebuild) &#123;</span><br><span class="line">            executionEdge = <span class="keyword">new</span> <span class="title class_">ExecutionEdge</span>(leftVertex, rightVertex);</span><br><span class="line">        &#125;</span><br><span class="line">        transformChainEdges.add(executionEdge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transformChainEdges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fillChainedTransformExecutionVertex</span><span class="params">(</span></span><br><span class="line"><span class="params">        ExecutionVertex currentVertex,</span></span><br><span class="line"><span class="params">        Map&lt;Long, Long&gt; chainedTransformVerticesMapping,</span></span><br><span class="line"><span class="params">        Map&lt;Long, ExecutionVertex&gt; transformChainVertexMap,</span></span><br><span class="line"><span class="params">        Set&lt;ExecutionEdge&gt; executionEdges,</span></span><br><span class="line"><span class="params">        Map&lt;Long, List&lt;ExecutionVertex&gt;&gt; inputVerticesMap,</span></span><br><span class="line"><span class="params">        Map&lt;Long, List&lt;ExecutionVertex&gt;&gt; targetVerticesMap)</span> &#123;</span><br><span class="line">    <span class="comment">// 当map中以及包含当前节点则退出</span></span><br><span class="line">    <span class="keyword">if</span> (chainedTransformVerticesMapping.containsKey(currentVertex.getVertexId())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;ExecutionVertex&gt; transformChainedVertices = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    collectChainedVertices(</span><br><span class="line">            currentVertex,</span><br><span class="line">            transformChainedVertices,</span><br><span class="line">            executionEdges,</span><br><span class="line">            inputVerticesMap,</span><br><span class="line">            targetVerticesMap);</span><br><span class="line">    <span class="comment">// 当list不为空时，表示list里面的transform节点可以被合并成一个</span></span><br><span class="line">    <span class="keyword">if</span> (transformChainedVertices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">newVertexId</span> <span class="operator">=</span> idGenerator.getNextId();</span><br><span class="line">        List&lt;SeaTunnelTransform&gt; transforms = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(transformChainedVertices.size());</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(transformChainedVertices.size());</span><br><span class="line">        Set&lt;URL&gt; jars = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;ConnectorJarIdentifier&gt; identifiers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        transformChainedVertices.stream()</span><br><span class="line">                .peek(</span><br><span class="line">                        <span class="comment">// 在mapping中添加所有历史节点编号与新节点编号的映射</span></span><br><span class="line">                        vertex -&gt;</span><br><span class="line">                                chainedTransformVerticesMapping.put(</span><br><span class="line">                                        vertex.getVertexId(), newVertexId))</span><br><span class="line">                .map(ExecutionVertex::getAction)</span><br><span class="line">                .map(action -&gt; (TransformAction) action)</span><br><span class="line">                .forEach(</span><br><span class="line">                        action -&gt; &#123;</span><br><span class="line">                            transforms.add(action.getTransform());</span><br><span class="line">                            jars.addAll(action.getJarUrls());</span><br><span class="line">                            identifiers.addAll(action.getConnectorJarIdentifiers());</span><br><span class="line">                            names.add(action.getName());</span><br><span class="line">                        &#125;);</span><br><span class="line">        <span class="type">String</span> <span class="variable">transformChainActionName</span> <span class="operator">=</span></span><br><span class="line">                String.format(<span class="string">&quot;TransformChain[%s]&quot;</span>, String.join(<span class="string">&quot;-&gt;&quot;</span>, names));</span><br><span class="line">        <span class="comment">// 将多个TransformAction合并成一个TransformChainAction</span></span><br><span class="line">        <span class="type">TransformChainAction</span> <span class="variable">transformChainAction</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TransformChainAction</span>(</span><br><span class="line">                        newVertexId, transformChainActionName, jars, identifiers, transforms);</span><br><span class="line">        transformChainAction.setParallelism(currentVertex.getAction().getParallelism());</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutionVertex</span> <span class="variable">executionVertex</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ExecutionVertex</span>(</span><br><span class="line">                        newVertexId, transformChainAction, currentVertex.getParallelism());</span><br><span class="line">        <span class="comment">// 在状态中将修改完成的节点信息放入</span></span><br><span class="line">        transformChainVertexMap.put(newVertexId, executionVertex);</span><br><span class="line">        chainedTransformVerticesMapping.put(</span><br><span class="line">                currentVertex.getVertexId(), executionVertex.getVertexId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">collectChainedVertices</span><span class="params">(</span></span><br><span class="line"><span class="params">        ExecutionVertex currentVertex,</span></span><br><span class="line"><span class="params">        List&lt;ExecutionVertex&gt; chainedVertices,</span></span><br><span class="line"><span class="params">        Set&lt;ExecutionEdge&gt; executionEdges,</span></span><br><span class="line"><span class="params">        Map&lt;Long, List&lt;ExecutionVertex&gt;&gt; inputVerticesMap,</span></span><br><span class="line"><span class="params">        Map&lt;Long, List&lt;ExecutionVertex&gt;&gt; targetVerticesMap)</span> &#123;</span><br><span class="line">    <span class="type">Action</span> <span class="variable">action</span> <span class="operator">=</span> currentVertex.getAction();</span><br><span class="line">    <span class="comment">// 仅对TransformAction进行合并</span></span><br><span class="line">    <span class="keyword">if</span> (action <span class="keyword">instanceof</span> TransformAction) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chainedVertices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 需要进行合并的节点list为空时，将自身添加到list中</span></span><br><span class="line">            <span class="comment">// 进入该分支的条件为当前节点为TransformAction并且所需链化列表为空</span></span><br><span class="line">            <span class="comment">// 此时可能有几种场景：第一个Transform节点进入，该Transform节点无任何限制</span></span><br><span class="line">            chainedVertices.add(currentVertex);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inputVerticesMap.get(currentVertex.getVertexId()).size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 当进入该条件分支则表明：</span></span><br><span class="line">            <span class="comment">// 所需链化的列表chainedVertices已经至少有一个TransformAction了</span></span><br><span class="line">            <span class="comment">// 此时的场景为：上游的Transform节点仅有一个下游节点，即当前节点。此限制是由下方的判断保证</span></span><br><span class="line">            <span class="comment">// 将当前TransformAction节点与上一个TransformAction节点进行链化</span></span><br><span class="line">            <span class="comment">// 在执行计划中将该关系删除</span></span><br><span class="line">            executionEdges.remove(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ExecutionEdge</span>(</span><br><span class="line">                            chainedVertices.get(chainedVertices.size() - <span class="number">1</span>), currentVertex));</span><br><span class="line">            <span class="comment">// 将自身加入需要链化的list中</span></span><br><span class="line">            chainedVertices.add(currentVertex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It cannot chain to any target vertex if it has multiple target vertices.</span></span><br><span class="line">    <span class="keyword">if</span> (targetVerticesMap.get(currentVertex.getVertexId()).size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 当当前节点仅有一个下游节点时，再次尝试链化</span></span><br><span class="line">        <span class="comment">// 如果当前节点存在多个下游节点，则不会将下游的节点进行链化，所以能保证上面的链化时两个节点是一对一的关系</span></span><br><span class="line">        <span class="comment">// 这里会调用的场景为Transform节点仅有一个下游节点</span></span><br><span class="line">        collectChainedVertices(</span><br><span class="line">                targetVerticesMap.get(currentVertex.getVertexId()).get(<span class="number">0</span>),</span><br><span class="line">                chainedVertices,</span><br><span class="line">                executionEdges,</span><br><span class="line">                inputVerticesMap,</span><br><span class="line">                targetVerticesMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第四步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Pipeline&gt; <span class="title function_">generatePipelines</span><span class="params">(Set&lt;ExecutionEdge&gt; executionEdges)</span> &#123;</span><br><span class="line">    <span class="comment">// 存储每个执行计划节点</span></span><br><span class="line">    Set&lt;ExecutionVertex&gt; executionVertices = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ExecutionEdge edge : executionEdges) &#123;</span><br><span class="line">        executionVertices.add(edge.getLeftVertex());</span><br><span class="line">        executionVertices.add(edge.getRightVertex());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用Pipeline执行器将执行计划转换为Pipeline</span></span><br><span class="line">    <span class="type">PipelineGenerator</span> <span class="variable">pipelineGenerator</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PipelineGenerator</span>(executionVertices, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(executionEdges));</span><br><span class="line">    List&lt;Pipeline&gt; pipelines = pipelineGenerator.generatePipelines();</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; duplicatedActionNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; actionNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Pipeline pipeline : pipelines) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pipelineId</span> <span class="operator">=</span> pipeline.getId();</span><br><span class="line">        <span class="keyword">for</span> (ExecutionVertex vertex : pipeline.getVertexes().values()) &#123;</span><br><span class="line">            <span class="comment">// 获取当前Pipeline的每个执行节点，重新设置Action的名称，添加了pipeline的名称</span></span><br><span class="line">            <span class="type">Action</span> <span class="variable">action</span> <span class="operator">=</span> vertex.getAction();</span><br><span class="line">            <span class="type">String</span> <span class="variable">actionName</span> <span class="operator">=</span> String.format(<span class="string">&quot;pipeline-%s [%s]&quot;</span>, pipelineId, action.getName());</span><br><span class="line">            action.setName(actionName);</span><br><span class="line">            <span class="keyword">if</span> (actionNames.contains(actionName)) &#123;</span><br><span class="line">                duplicatedActionNames.add(actionName);</span><br><span class="line">            &#125;</span><br><span class="line">            actionNames.add(actionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查，不能存在重复的Action Name</span></span><br><span class="line">    checkArgument(</span><br><span class="line">            duplicatedActionNames.isEmpty(),</span><br><span class="line">            <span class="string">&quot;Action name is duplicated: &quot;</span> + duplicatedActionNames);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pipelines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PipelineGenerator</span><span class="params">(Collection&lt;ExecutionVertex&gt; vertices, List&lt;ExecutionEdge&gt; edges)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.vertices = vertices;</span><br><span class="line">    <span class="built_in">this</span>.edges = edges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Pipeline&gt; <span class="title function_">generatePipelines</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;ExecutionEdge&gt; executionEdges = expandEdgeByParallelism(edges);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将执行计划进行拆分，按照关联关系，将执行计划进行拆分</span></span><br><span class="line">    <span class="comment">// 拆分为几个不相关的执行计划</span></span><br><span class="line">    List&lt;List&lt;ExecutionEdge&gt;&gt; edgesList = splitUnrelatedEdges(executionEdges);</span><br><span class="line"></span><br><span class="line">    edgesList =</span><br><span class="line">            edgesList.stream()</span><br><span class="line">                    .flatMap(e -&gt; <span class="built_in">this</span>.splitUnionEdge(e).stream())</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// just convert execution plan to pipeline at now. We should split it to multi pipeline with</span></span><br><span class="line">    <span class="comment">// cache in the future</span></span><br><span class="line">    <span class="type">IdGenerator</span> <span class="variable">idGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">    <span class="comment">// 将执行计划图转换为Pipeline</span></span><br><span class="line">    <span class="keyword">return</span> edgesList.stream()</span><br><span class="line">            .map(</span><br><span class="line">                    e -&gt; &#123;</span><br><span class="line">                        Map&lt;Long, ExecutionVertex&gt; vertexes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                        List&lt;ExecutionEdge&gt; pipelineEdges =</span><br><span class="line">                                e.stream()</span><br><span class="line">                                        .map(</span><br><span class="line">                                                edge -&gt; &#123;</span><br><span class="line">                                                    <span class="keyword">if</span> (!vertexes.containsKey(</span><br><span class="line">                                                            edge.getLeftVertexId())) &#123;</span><br><span class="line">                                                        vertexes.put(</span><br><span class="line">                                                                edge.getLeftVertexId(),</span><br><span class="line">                                                                edge.getLeftVertex());</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                    <span class="type">ExecutionVertex</span> <span class="variable">source</span> <span class="operator">=</span></span><br><span class="line">                                                            vertexes.get(</span><br><span class="line">                                                                    edge.getLeftVertexId());</span><br><span class="line">                                                    <span class="keyword">if</span> (!vertexes.containsKey(</span><br><span class="line">                                                            edge.getRightVertexId())) &#123;</span><br><span class="line">                                                        vertexes.put(</span><br><span class="line">                                                                edge.getRightVertexId(),</span><br><span class="line">                                                                edge.getRightVertex());</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                    <span class="type">ExecutionVertex</span> <span class="variable">destination</span> <span class="operator">=</span></span><br><span class="line">                                                            vertexes.get(</span><br><span class="line">                                                                    edge.getRightVertexId());</span><br><span class="line">                                                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecutionEdge</span>(</span><br><span class="line">                                                            source, destination);</span><br><span class="line">                                                &#125;)</span><br><span class="line">                                        .collect(Collectors.toList());</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pipeline</span>(</span><br><span class="line">                                (<span class="type">int</span>) idGenerator.getNextId(), pipelineEdges, vertexes);</span><br><span class="line">                    &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第五步</p>
</li>
</ul>
<p>第五步则是生成执行计划实例，传递了第四步生成的Pipeline参数</p>
<p><strong>小结一下：</strong><br>执行计划会将逻辑计划做这几件事情</p>
<ol>
<li>当source会生成多张表，并且有多个sink节点依赖于此source时，会在中间添加一个shuffle节点</li>
<li>尝试对transform节点进行链化合并，将多个transform节点合并为一个节点</li>
<li>将任务进行拆分，将一个<code>配置文件/LogicalDag</code>拆分为几个不相关的任务<code>List&lt;Pipeline&gt;</code></li>
</ol>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/6a45288562e94e6cbea9413eaec23645d1747b83/Pasted%20image%2020240821112335.png"></p>
<h4 id="物理计划的生成"><a href="#物理计划的生成" class="headerlink" title="物理计划的生成"></a>物理计划的生成</h4><p>在看物理计划生成之前，先看下生成的物理计划中包含了什么信息，<br>我们对物理计划以及内部相关的内都拿出来看一下相关信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhysicalPlan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SubPlan&gt; pipelineList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">finishedPipelineNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">canceledPipelineNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">failedPipelineNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobImmutableInformation jobImmutableInformation;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMap&lt;Object, Object&gt; runningJobStateIMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMap&lt;Object, Long[]&gt; runningJobStateTimestampsIMap;</span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;JobResult&gt; jobEndFuture;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String&gt; errorBySubPlan = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobFullName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> jobId;</span><br><span class="line">    <span class="keyword">private</span> JobMaster jobMaster;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">makeJobEndWhenPipelineEnded</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个类中有一个关键字段pipelineList，是一个SubPlan的列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubPlan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> pipelineMaxRestoreNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> pipelineRestoreIntervalSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PhysicalVertex&gt; physicalVertexList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PhysicalVertex&gt; coordinatorVertexList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> pipelineId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">finishedTaskNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">canceledTaskNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">failedTaskNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String pipelineFullName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMap&lt;Object, Object&gt; runningJobStateIMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; tags;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMap&lt;Object, Long[]&gt; runningJobStateTimestampsIMap;</span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;PipelineExecutionState&gt; pipelineFuture;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PipelineLocation pipelineLocation;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;String&gt; errorByPhysicalVertex = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService;</span><br><span class="line">    <span class="keyword">private</span> JobMaster jobMaster;</span><br><span class="line">    <span class="keyword">private</span> PassiveCompletableFuture&lt;Void&gt; reSchedulerPipelineFuture;</span><br><span class="line">    <span class="keyword">private</span> Integer pipelineRestoreNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">restoreLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> PipelineStatus currPipelineStatus;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;TaskGroupLocation, SlotProfile&gt; slotProfiles;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>在SubPlan中，又维护了<code>PhysicalVertex</code>物理节点的一个列表，并且拆分成了物理计划节点和协调器节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhysicalVertex</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskGroupLocation taskGroupLocation;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String taskFullName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskGroupDefaultImpl taskGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FlakeIdGenerator flakeIdGenerator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;URL&gt; pluginJarsUrls;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;ConnectorJarIdentifier&gt; connectorJarIdentifiers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMap&lt;Object, Object&gt; runningJobStateIMap;</span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;TaskExecutionState&gt; taskFuture;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMap&lt;Object, Long[]&gt; runningJobStateTimestampsIMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NodeEngine nodeEngine;</span><br><span class="line">    <span class="keyword">private</span> JobMaster jobMaster;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">ExecutionState</span> <span class="variable">currExecutionState</span> <span class="operator">=</span> ExecutionState.CREATED;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;String&gt; errorByPhysicalVertex = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskGroupDefaultImpl</span> <span class="keyword">implements</span> <span class="title class_">TaskGroup</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskGroupLocation taskGroupLocation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String taskGroupName;</span><br><span class="line">    <span class="comment">// 存储了当前物理节点所需要执行的task</span></span><br><span class="line">    <span class="comment">// 这里的每个task可能是一个读取数据的任务，也可能是一个写入数据的任务</span></span><br><span class="line">    <span class="comment">// 或者是数据拆分，checkpoint的任务等等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, Task&gt; tasks;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PhysicalPlanGenerator</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> ExecutionPlan executionPlan,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> NodeEngine nodeEngine,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> JobImmutableInformation jobImmutableInformation,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> initializationTimestamp,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> ExecutorService executorService,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> FlakeIdGenerator flakeIdGenerator,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IMap runningJobStateIMap,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IMap runningJobStateTimestampsIMap,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> QueueType queueType)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.pipelines = executionPlan.getPipelines();</span><br><span class="line">    <span class="built_in">this</span>.nodeEngine = nodeEngine;</span><br><span class="line">    <span class="built_in">this</span>.jobImmutableInformation = jobImmutableInformation;</span><br><span class="line">    <span class="built_in">this</span>.initializationTimestamp = initializationTimestamp;</span><br><span class="line">    <span class="built_in">this</span>.executorService = executorService;</span><br><span class="line">    <span class="built_in">this</span>.flakeIdGenerator = flakeIdGenerator;</span><br><span class="line">    <span class="comment">// the checkpoint of a pipeline</span></span><br><span class="line">    <span class="built_in">this</span>.pipelineTasks = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.startingTasks = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.subtaskActions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.runningJobStateIMap = runningJobStateIMap;</span><br><span class="line">    <span class="built_in">this</span>.runningJobStateTimestampsIMap = runningJobStateTimestampsIMap;</span><br><span class="line">    <span class="built_in">this</span>.queueType = queueType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Tuple2&lt;PhysicalPlan, Map&lt;Integer, CheckpointPlan&gt;&gt; <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取用户配置中的节点过滤条件，用于选择任务将要运行的节点</span></span><br><span class="line">    Map&lt;String, String&gt; tagFilter =</span><br><span class="line">            (Map&lt;String, String&gt;)</span><br><span class="line">                    jobImmutableInformation</span><br><span class="line">                            .getJobConfig()</span><br><span class="line">                            .getEnvOptions()</span><br><span class="line">                            .get(EnvCommonOptions.NODE_TAG_FILTER.key());</span><br><span class="line">    <span class="comment">// TODO Determine which tasks do not need to be restored according to state</span></span><br><span class="line">    CopyOnWriteArrayList&lt;PassiveCompletableFuture&lt;PipelineStatus&gt;&gt;</span><br><span class="line">            waitForCompleteBySubPlanList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, CheckpointPlan&gt; checkpointPlans = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalPipelineNum</span> <span class="operator">=</span> pipelines.size();</span><br><span class="line">    Stream&lt;SubPlan&gt; subPlanStream =</span><br><span class="line">            pipelines.stream()</span><br><span class="line">                    .map(</span><br><span class="line">                            pipeline -&gt; &#123;</span><br><span class="line">                                <span class="comment">// 每次都将状态清空</span></span><br><span class="line">                                <span class="built_in">this</span>.pipelineTasks.clear();</span><br><span class="line">                                <span class="built_in">this</span>.startingTasks.clear();</span><br><span class="line">                                <span class="built_in">this</span>.subtaskActions.clear();</span><br><span class="line">                                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">pipelineId</span> <span class="operator">=</span> pipeline.getId();</span><br><span class="line">                                <span class="comment">// 获取当前任务的信息</span></span><br><span class="line">                                <span class="keyword">final</span> List&lt;ExecutionEdge&gt; edges = pipeline.getEdges();</span><br><span class="line">                                <span class="comment">// 获取所有的SourceAction</span></span><br><span class="line">                                List&lt;SourceAction&lt;?, ?, ?&gt;&gt; sources = findSourceAction(edges);</span><br><span class="line">                                <span class="comment">// 生成Source数据切片任务，即SourceSplitEnumeratorTask，</span></span><br><span class="line">                                <span class="comment">// 这个任务会调用连接器中的SourceSplitEnumerator类，如果该连接器支持的话</span></span><br><span class="line">                                List&lt;PhysicalVertex&gt; coordinatorVertexList =</span><br><span class="line">                                        getEnumeratorTask(</span><br><span class="line">                                                sources, pipelineId, totalPipelineNum);</span><br><span class="line">                                <span class="comment">// 生成Sink提交任务，即SinkAggregatedCommitterTask</span></span><br><span class="line">                                <span class="comment">// 这个任务会调用连接器中的SinkAggregatedCommitter类，如果该连接器支持的话</span></span><br><span class="line">                                <span class="comment">// 这两个任务是作为协调任务来执行的</span></span><br><span class="line">                                coordinatorVertexList.addAll(</span><br><span class="line">                                        getCommitterTask(edges, pipelineId, totalPipelineNum));</span><br><span class="line">                                List&lt;PhysicalVertex&gt; physicalVertexList =</span><br><span class="line">                                        getSourceTask(</span><br><span class="line">                                                edges, sources, pipelineId, totalPipelineNum);</span><br><span class="line">                                <span class="comment">//</span></span><br><span class="line">                                physicalVertexList.addAll(</span><br><span class="line">                                        getShuffleTask(edges, pipelineId, totalPipelineNum));</span><br><span class="line"></span><br><span class="line">                                CompletableFuture&lt;PipelineStatus&gt; pipelineFuture =</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">                                waitForCompleteBySubPlanList.add(</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">PassiveCompletableFuture</span>&lt;&gt;(pipelineFuture));</span><br><span class="line">                                <span class="comment">// 添加checkpoint的任务</span></span><br><span class="line">                                checkpointPlans.put(</span><br><span class="line">                                        pipelineId,</span><br><span class="line">                                        CheckpointPlan.builder()</span><br><span class="line">                                                .pipelineId(pipelineId)</span><br><span class="line">                                                .pipelineSubtasks(pipelineTasks)</span><br><span class="line">                                                .startingSubtasks(startingTasks)</span><br><span class="line">                                                .pipelineActions(pipeline.getActions())</span><br><span class="line">                                                .subtaskActions(subtaskActions)</span><br><span class="line">                                                .build());</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubPlan</span>(</span><br><span class="line">                                        pipelineId,</span><br><span class="line">                                        totalPipelineNum,</span><br><span class="line">                                        initializationTimestamp,</span><br><span class="line">                                        physicalVertexList,</span><br><span class="line">                                        coordinatorVertexList,</span><br><span class="line">                                        jobImmutableInformation,</span><br><span class="line">                                        executorService,</span><br><span class="line">                                        runningJobStateIMap,</span><br><span class="line">                                        runningJobStateTimestampsIMap,</span><br><span class="line">                                        tagFilter);</span><br><span class="line">                            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">PhysicalPlan</span> <span class="variable">physicalPlan</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PhysicalPlan</span>(</span><br><span class="line">                    subPlanStream.collect(Collectors.toList()),</span><br><span class="line">                    executorService,</span><br><span class="line">                    jobImmutableInformation,</span><br><span class="line">                    initializationTimestamp,</span><br><span class="line">                    runningJobStateIMap,</span><br><span class="line">                    runningJobStateTimestampsIMap);</span><br><span class="line">    <span class="keyword">return</span> Tuple2.tuple2(physicalPlan, checkpointPlans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成物理计划的过程就是去将执行计划转换成<code>SeaTunnelTask</code>，并且在执行过程中添加各种协调任务，例如数据切分任务，数据提交任务，checkpoint任务。</p>
<p>在<code>SeaTunnelTask</code>中，会将任务转换成<code>SourceFlowLifeCycle</code>，<code>SinkFlowLifeCycle</code>，<code>TransformFlowLifeCycle</code>，<code>ShuffleSinkFlowLifeCycle</code>，<code>ShuffleSourceFlowLifeCycle</code>。</p>
<p>我们以<code>SourceFlowLifeCycle</code>， <code>SinkFlowLifeCycle</code>为例</p>
<ul>
<li>SourceFlowLifeCycle<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="built_in">this</span>.splitSerializer = sourceAction.getSource().getSplitSerializer();</span><br><span class="line">    <span class="built_in">this</span>.reader =</span><br><span class="line">            sourceAction</span><br><span class="line">                    .getSource()</span><br><span class="line">                    .createReader(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">SourceReaderContext</span>(</span><br><span class="line">                                    indexID,</span><br><span class="line">                                    sourceAction.getSource().getBoundedness(),</span><br><span class="line">                                    <span class="built_in">this</span>,</span><br><span class="line">                                    metricsContext,</span><br><span class="line">                                    eventListener));</span><br><span class="line">    <span class="built_in">this</span>.enumeratorTaskAddress = getEnumeratorTaskAddress();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    reader.open();</span><br><span class="line">    register();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prepareClose) &#123;</span><br><span class="line">        <span class="keyword">if</span> (schemaChanging()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;schema is changing, stop reader collect records&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reader.pollNext(collector);</span><br><span class="line">        <span class="keyword">if</span> (collector.isEmptyThisPollNext()) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            collector.resetEmptyThisPollNext();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The current thread obtain a checkpoint lock in the method &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">             * SourceReader#pollNext(Collector)&#125;. When trigger the checkpoint or savepoint,</span></span><br><span class="line"><span class="comment">             * other threads try to obtain the lock in the method &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">             * SourceFlowLifeCycle#triggerBarrier(Barrier)&#125;. When high CPU load, checkpoint</span></span><br><span class="line"><span class="comment">             * process may be blocked as long time. So we need sleep to free the CPU.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread.sleep(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (collector.captureSchemaChangeBeforeCheckpointSignal()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (schemaChangePhase.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;previous schema changes in progress, schemaChangePhase: &quot;</span></span><br><span class="line">                                + schemaChangePhase.get());</span><br><span class="line">            &#125;</span><br><span class="line">            schemaChangePhase.set(SchemaChangePhase.createBeforePhase());</span><br><span class="line">            runningTask.triggerSchemaChangeBeforeCheckpoint().get();</span><br><span class="line">            log.info(<span class="string">&quot;triggered schema-change-before checkpoint, stopping collect data&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collector.captureSchemaChangeAfterCheckpointSignal()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (schemaChangePhase.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;previous schema changes in progress, schemaChangePhase: &quot;</span></span><br><span class="line">                                + schemaChangePhase.get());</span><br><span class="line">            &#125;</span><br><span class="line">            schemaChangePhase.set(SchemaChangePhase.createAfterPhase());</span><br><span class="line">            runningTask.triggerSchemaChangeAfterCheckpoint().get();</span><br><span class="line">            log.info(<span class="string">&quot;triggered schema-change-after checkpoint, stopping collect data&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以看到Source的数据读取，是在<code>SourceFlowLifeCycle</code>的<code>collect</code>方法中被真正的调用，</p>
<p>数据读取到之后，会放入<code>SeaTunnelSourceCollector</code>中，在这个collector中，当接收到数据时，会进行指标的更新，并将数据发送给相关的下游</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(T row)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row <span class="keyword">instanceof</span> SeaTunnelRow) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tableId</span> <span class="operator">=</span> ((SeaTunnelRow) row).getTableId();</span><br><span class="line">            <span class="type">int</span> size;</span><br><span class="line">            <span class="keyword">if</span> (rowType <span class="keyword">instanceof</span> SeaTunnelRowType) &#123;</span><br><span class="line">                size = ((SeaTunnelRow) row).getBytesSize((SeaTunnelRowType) rowType);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowType <span class="keyword">instanceof</span> MultipleRowType) &#123;</span><br><span class="line">                size = ((SeaTunnelRow) row).getBytesSize(rowTypeMap.get(tableId));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SeaTunnelEngineException</span>(</span><br><span class="line">                        <span class="string">&quot;Unsupported row type: &quot;</span> + rowType.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            sourceReceivedBytes.inc(size);</span><br><span class="line">            sourceReceivedBytesPerSeconds.markEvent(size);</span><br><span class="line">            flowControlGate.audit((SeaTunnelRow) row);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(tableId)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> getFullName(TablePath.of(tableId));</span><br><span class="line">                <span class="type">Counter</span> <span class="variable">sourceTableCounter</span> <span class="operator">=</span> sourceReceivedCountPerTable.get(tableName);</span><br><span class="line">                <span class="keyword">if</span> (Objects.nonNull(sourceTableCounter)) &#123;</span><br><span class="line">                    sourceTableCounter.inc();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span></span><br><span class="line">                            metricsContext.counter(SOURCE_RECEIVED_COUNT + <span class="string">&quot;#&quot;</span> + tableName);</span><br><span class="line">                    counter.inc();</span><br><span class="line">                    sourceReceivedCountPerTable.put(tableName, counter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sendRecordToNext(<span class="keyword">new</span> <span class="title class_">Record</span>&lt;&gt;(row));</span><br><span class="line">        emptyThisPollNext = <span class="literal">false</span>;</span><br><span class="line">        sourceReceivedCount.inc();</span><br><span class="line">        sourceReceivedQPS.markEvent();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRecordToNext</span><span class="params">(Record&lt;?&gt; record)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (checkpointLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (OneInputFlowLifeCycle&lt;Record&lt;?&gt;&gt; output : outputs) &#123;</span><br><span class="line">            output.received(record);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>SinkFlowLifeCycle<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">received</span><span class="params">(Record&lt;?&gt; record)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (record.getData() <span class="keyword">instanceof</span> Barrier) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="type">Barrier</span> <span class="variable">barrier</span> <span class="operator">=</span> (Barrier) record.getData();</span><br><span class="line">            <span class="keyword">if</span> (barrier.prepareClose(<span class="built_in">this</span>.taskLocation)) &#123;</span><br><span class="line">                prepareClose = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (barrier.snapshot()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lastCommitInfo = writer.prepareCommit();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    writer.abortPrepare();</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;StateT&gt; states = writer.snapshotState(barrier.getId());</span><br><span class="line">                <span class="keyword">if</span> (!writerStateSerializer.isPresent()) &#123;</span><br><span class="line">                    runningTask.addState(</span><br><span class="line">                            barrier, ActionStateKey.of(sinkAction), Collections.emptyList());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    runningTask.addState(</span><br><span class="line">                            barrier,</span><br><span class="line">                            ActionStateKey.of(sinkAction),</span><br><span class="line">                            serializeStates(writerStateSerializer.get(), states));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (containAggCommitter) &#123;</span><br><span class="line">                    <span class="type">CommitInfoT</span> <span class="variable">commitInfoT</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (lastCommitInfo.isPresent()) &#123;</span><br><span class="line">                        commitInfoT = lastCommitInfo.get();</span><br><span class="line">                    &#125;</span><br><span class="line">                    runningTask</span><br><span class="line">                            .getExecutionContext()</span><br><span class="line">                            .sendToMember(</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">SinkPrepareCommitOperation</span>&lt;CommitInfoT&gt;(</span><br><span class="line">                                            barrier,</span><br><span class="line">                                            committerTaskLocation,</span><br><span class="line">                                            commitInfoSerializer.isPresent()</span><br><span class="line">                                                    ? commitInfoSerializer</span><br><span class="line">                                                            .get()</span><br><span class="line">                                                            .serialize(commitInfoT)</span><br><span class="line">                                                    : <span class="literal">null</span>),</span><br><span class="line">                                    committerTaskAddress)</span><br><span class="line">                            .join();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (containAggCommitter) &#123;</span><br><span class="line">                    runningTask</span><br><span class="line">                            .getExecutionContext()</span><br><span class="line">                            .sendToMember(</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">BarrierFlowOperation</span>(barrier, committerTaskLocation),</span><br><span class="line">                                    committerTaskAddress)</span><br><span class="line">                            .join();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            runningTask.ack(barrier);</span><br><span class="line"></span><br><span class="line">            log.debug(</span><br><span class="line">                    <span class="string">&quot;trigger barrier [&#123;&#125;] finished, cost &#123;&#125;ms. taskLocation [&#123;&#125;]&quot;</span>,</span><br><span class="line">                    barrier.getId(),</span><br><span class="line">                    System.currentTimeMillis() - startTime,</span><br><span class="line">                    taskLocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (record.getData() <span class="keyword">instanceof</span> SchemaChangeEvent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prepareClose) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">SchemaChangeEvent</span> <span class="variable">event</span> <span class="operator">=</span> (SchemaChangeEvent) record.getData();</span><br><span class="line">            writer.applySchemaChange(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prepareClose) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write((T) record.getData());</span><br><span class="line">            sinkWriteCount.inc();</span><br><span class="line">            sinkWriteQPS.markEvent();</span><br><span class="line">            <span class="keyword">if</span> (record.getData() <span class="keyword">instanceof</span> SeaTunnelRow) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> ((SeaTunnelRow) record.getData()).getBytesSize();</span><br><span class="line">                sinkWriteBytes.inc(size);</span><br><span class="line">                sinkWriteBytesPerSeconds.markEvent(size);</span><br><span class="line">                <span class="type">String</span> <span class="variable">tableId</span> <span class="operator">=</span> ((SeaTunnelRow) record.getData()).getTableId();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(tableId)) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> getFullName(TablePath.of(tableId));</span><br><span class="line">                    <span class="type">Counter</span> <span class="variable">sinkTableCounter</span> <span class="operator">=</span> sinkWriteCountPerTable.get(tableName);</span><br><span class="line">                    <span class="keyword">if</span> (Objects.nonNull(sinkTableCounter)) &#123;</span><br><span class="line">                        sinkTableCounter.inc();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span></span><br><span class="line">                                metricsContext.counter(SINK_WRITE_COUNT + <span class="string">&quot;#&quot;</span> + tableName);</span><br><span class="line">                        counter.inc();</span><br><span class="line">                        sinkWriteCountPerTable.put(tableName, counter);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>同样，在这个类中是真正调用Sink的Writer方法，将数据写入到下游中。</p>
<p>一个简易的图大概是这样<br><img src="https://raw.githubusercontent.com/liunaijie/images/3835187ef9b6135853bd7f959ff72656acbf2688/Drawing%202024-08-23%2009.11.11.excalidraw.png"></p>
<h4 id="用图来详细拆解下物理计划的生成步骤"><a href="#用图来详细拆解下物理计划的生成步骤" class="headerlink" title="用图来详细拆解下物理计划的生成步骤:"></a>用图来详细拆解下物理计划的生成步骤:</h4><p>以这个执行计划为例<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081504700.png" alt="image.png"><br>这个执行计划在经过查找<code>findSourceAction</code>方法后, 可以得到这两个<code>source action</code><br><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081504802.png" alt="image.png"><br>后续的分析仅会分析一下<code>source1</code>的流程<br>在<code>getSourceTask</code>方法中, 首先会将<code>SourceAction</code>转化为<code>PhyscicalExecutionFlow</code><br><code>source1</code>会被转化为<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081512991.png" alt="image.png"></p>
<p>接下来会有一步, 判断是否有<code>sink action</code>, 如何存在则需要进行拆分<code>splitSinkFromFlow</code>, 而刚刚生成的<code>Flow</code>是带有<code>sink action</code>的, 经过<code>splitSinkFromFlow</code>会变成<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081514999.png" alt="image.png"><br>根据这个<code>source</code>生成的<code>PhysicalVertex</code>为<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081515868.png" alt="image.png"></p>
<h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><p>在<code>CoordinatorService</code>中通过<code>init</code>方法生成了物理计划，然后会再调用<code>run</code>来真正的将任务运行起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CoordinatorService &#123;</span><br><span class="line">    jobMaster.init(</span><br><span class="line">            runningJobInfoIMap.get(jobId).getInitializationTimestamp(), <span class="literal">false</span>);</span><br><span class="line">    ...</span><br><span class="line">    jobMaster.run();</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> JobMaster &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ... </span><br><span class="line">        physicalPlan.startJob();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>在JobMaster中启动任务，会调用PhysicalPlan的startJob方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startJob</span><span class="params">()</span> &#123;</span><br><span class="line">    isRunning = <span class="literal">true</span>;</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; state process is start&quot;</span>, getJobFullName());</span><br><span class="line">    stateProcess();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stateProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isRunning) &#123;</span><br><span class="line">        log.warn(String.format(<span class="string">&quot;%s state process is stopped&quot;</span>, jobFullName));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (getJobStatus()) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATED:</span><br><span class="line">            updateJobState(JobStatus.SCHEDULED);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SCHEDULED:</span><br><span class="line">            getPipelineList()</span><br><span class="line">                    .forEach(</span><br><span class="line">                            subPlan -&gt; &#123;</span><br><span class="line">                                <span class="keyword">if</span> (PipelineStatus.CREATED.equals(</span><br><span class="line">                                        subPlan.getCurrPipelineStatus())) &#123;</span><br><span class="line">                                    subPlan.startSubPlanStateProcess();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">            updateJobState(JobStatus.RUNNING);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> DOING_SAVEPOINT:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FAILING:</span><br><span class="line">        <span class="keyword">case</span> CANCELING:</span><br><span class="line">            jobMaster.neverNeedRestore();</span><br><span class="line">            getPipelineList().forEach(SubPlan::cancelPipeline);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FAILED:</span><br><span class="line">        <span class="keyword">case</span> CANCELED:</span><br><span class="line">        <span class="keyword">case</span> SAVEPOINT_DONE:</span><br><span class="line">        <span class="keyword">case</span> FINISHED:</span><br><span class="line">            stopJobStateProcess();</span><br><span class="line">            jobEndFuture.complete(<span class="keyword">new</span> <span class="title class_">JobResult</span>(getJobStatus(), errorBySubPlan.get()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown Job State: &quot;</span> + getJobStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在PhysicalPlan中，启动任务会将任务的状态更新为<code>SCHEDULED</code>状态，然后会继续调用SubPlan的启动方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startSubPlanStateProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    isRunning = <span class="literal">true</span>;</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; state process is start&quot;</span>, getPipelineFullName());</span><br><span class="line">    stateProcess();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stateProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isRunning) &#123;</span><br><span class="line">        log.warn(String.format(<span class="string">&quot;%s state process not start&quot;</span>, pipelineFullName));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">PipelineStatus</span> <span class="variable">state</span> <span class="operator">=</span> getCurrPipelineStatus();</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATED:</span><br><span class="line">            updatePipelineState(PipelineStatus.SCHEDULED);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SCHEDULED:</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ResourceUtils.applyResourceForPipeline(jobMaster.getResourceManager(), <span class="built_in">this</span>);</span><br><span class="line">                log.debug(</span><br><span class="line">                        <span class="string">&quot;slotProfiles: &#123;&#125;, PipelineLocation: &#123;&#125;&quot;</span>,</span><br><span class="line">                        slotProfiles,</span><br><span class="line">                        <span class="built_in">this</span>.getPipelineLocation());</span><br><span class="line">                updatePipelineState(PipelineStatus.DEPLOYING);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                makePipelineFailing(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DEPLOYING:</span><br><span class="line">            coordinatorVertexList.forEach(</span><br><span class="line">                    task -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task.getExecutionState().equals(ExecutionState.CREATED)) &#123;</span><br><span class="line">                            task.startPhysicalVertex();</span><br><span class="line">                            task.makeTaskGroupDeploy();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            physicalVertexList.forEach(</span><br><span class="line">                    task -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task.getExecutionState().equals(ExecutionState.CREATED)) &#123;</span><br><span class="line">                            task.startPhysicalVertex();</span><br><span class="line">                            task.makeTaskGroupDeploy();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            updatePipelineState(PipelineStatus.RUNNING);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FAILING:</span><br><span class="line">        <span class="keyword">case</span> CANCELING:</span><br><span class="line">            coordinatorVertexList.forEach(</span><br><span class="line">                    task -&gt; &#123;</span><br><span class="line">                        task.startPhysicalVertex();</span><br><span class="line">                        task.cancel();</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            physicalVertexList.forEach(</span><br><span class="line">                    task -&gt; &#123;</span><br><span class="line">                        task.startPhysicalVertex();</span><br><span class="line">                        task.cancel();</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FAILED:</span><br><span class="line">        <span class="keyword">case</span> CANCELED:</span><br><span class="line">            <span class="keyword">if</span> (checkNeedRestore(state) &amp;&amp; prepareRestorePipeline()) &#123;</span><br><span class="line">                jobMaster.releasePipelineResource(<span class="built_in">this</span>);</span><br><span class="line">                restorePipeline();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            subPlanDone(state);</span><br><span class="line">            stopSubPlanStateProcess();</span><br><span class="line">            pipelineFuture.complete(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">PipelineExecutionState</span>(pipelineId, state, errorByPhysicalVertex.get()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> FINISHED:</span><br><span class="line">            subPlanDone(state);</span><br><span class="line">            stopSubPlanStateProcess();</span><br><span class="line">            pipelineFuture.complete(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">PipelineExecutionState</span>(</span><br><span class="line">                            pipelineId, getPipelineState(), errorByPhysicalVertex.get()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown Pipeline State: &quot;</span> + getPipelineState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SubPlan中，当状态为<code>SCHEDULED</code>时，会进行资源的申请，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">applyResourceForPipeline</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> ResourceManager resourceManager, <span class="meta">@NonNull</span> SubPlan subPlan)</span> &#123;</span><br><span class="line">    Map&lt;TaskGroupLocation, CompletableFuture&lt;SlotProfile&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;TaskGroupLocation, SlotProfile&gt; slotProfiles = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// TODO If there is no enough resources for tasks, we need add some wait profile</span></span><br><span class="line">    subPlan.getCoordinatorVertexList()</span><br><span class="line">            .forEach(</span><br><span class="line">                    coordinator -&gt;</span><br><span class="line">                            futures.put(</span><br><span class="line">                                    coordinator.getTaskGroupLocation(),</span><br><span class="line">                                    applyResourceForTask(</span><br><span class="line">                                            resourceManager, coordinator, subPlan.getTags())));</span><br><span class="line"></span><br><span class="line">    subPlan.getPhysicalVertexList()</span><br><span class="line">            .forEach(</span><br><span class="line">                    task -&gt;</span><br><span class="line">                            futures.put(</span><br><span class="line">                                    task.getTaskGroupLocation(),</span><br><span class="line">                                    applyResourceForTask(</span><br><span class="line">                                            resourceManager, task, subPlan.getTags())));</span><br><span class="line"></span><br><span class="line">    futures.forEach(</span><br><span class="line">            (key, value) -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    slotProfiles.put(key, value == <span class="literal">null</span> ? <span class="literal">null</span> : value.join());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CompletionException e) &#123;</span><br><span class="line">                    <span class="comment">// do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// set it first, avoid can&#x27;t get it when get resource not enough exception and need release</span></span><br><span class="line">    <span class="comment">// applied resource</span></span><br><span class="line">    subPlan.getJobMaster().setOwnedSlotProfiles(subPlan.getPipelineLocation(), slotProfiles);</span><br><span class="line">    <span class="keyword">if</span> (futures.size() != slotProfiles.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoEnoughResourceException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;SlotProfile&gt; <span class="title function_">applyResourceForTask</span><span class="params">(</span></span><br><span class="line"><span class="params">        ResourceManager resourceManager, PhysicalVertex task, Map&lt;String, String&gt; tags)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO custom resource size</span></span><br><span class="line">    <span class="keyword">return</span> resourceManager.applyResource(</span><br><span class="line">            task.getTaskGroupLocation().getJobId(), <span class="keyword">new</span> <span class="title class_">ResourceProfile</span>(), tags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;List&lt;SlotProfile&gt;&gt; <span class="title function_">applyResources</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">long</span> jobId, List&lt;ResourceProfile&gt; resourceProfile, Map&lt;String, String&gt; tagFilter)</span></span><br><span class="line">        <span class="keyword">throws</span> NoEnoughResourceException &#123;</span><br><span class="line">    waitingWorkerRegister();</span><br><span class="line">    ConcurrentMap&lt;Address, WorkerProfile&gt; matchedWorker = filterWorkerByTag(tagFilter);</span><br><span class="line">    <span class="keyword">if</span> (matchedWorker.isEmpty()) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;No matched worker with tag filter &#123;&#125;.&quot;</span>, tagFilter);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoEnoughResourceException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourceRequestHandler</span>(jobId, resourceProfile, matchedWorker, <span class="built_in">this</span>)</span><br><span class="line">            .request(tagFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个SubPlan中会将所有的任务进行资源的申请，申请资源是通过<code>ResourceManager</code>进行的。申请时首先会按照用户任务中设置的tag来选择将要运行任务的节点，这样就可以将任务运行在我们指定的节点上，达到资源隔离的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;WorkerProfile&gt; <span class="title function_">preCheckWorkerResource</span><span class="params">(ResourceProfile r)</span> &#123;</span><br><span class="line">    <span class="comment">// Shuffle the order to ensure random selection of workers</span></span><br><span class="line">    List&lt;WorkerProfile&gt; workerProfiles =</span><br><span class="line">            Arrays.asList(registerWorker.values().toArray(<span class="keyword">new</span> <span class="title class_">WorkerProfile</span>[<span class="number">0</span>]));</span><br><span class="line">    Collections.shuffle(workerProfiles);</span><br><span class="line">    <span class="comment">// Check if there are still unassigned slots</span></span><br><span class="line">    Optional&lt;WorkerProfile&gt; workerProfile =</span><br><span class="line">            workerProfiles.stream()</span><br><span class="line">                    .filter(</span><br><span class="line">                            worker -&gt;</span><br><span class="line">                                    Arrays.stream(worker.getUnassignedSlots())</span><br><span class="line">                                            .anyMatch(</span><br><span class="line">                                                    slot -&gt;</span><br><span class="line">                                                            slot.getResourceProfile()</span><br><span class="line">                                                                    .enoughThan(r)))</span><br><span class="line">                    .findAny();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!workerProfile.isPresent()) &#123;</span><br><span class="line">        <span class="comment">// Check if there are still unassigned resources</span></span><br><span class="line">        workerProfile =</span><br><span class="line">                workerProfiles.stream()</span><br><span class="line">                        .filter(WorkerProfile::isDynamicSlot)</span><br><span class="line">                        .filter(worker -&gt; worker.getUnassignedResource().enoughThan(r))</span><br><span class="line">                        .findAny();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> workerProfile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CompletableFuture&lt;SlotAndWorkerProfile&gt; <span class="title function_">singleResourceRequestToMember</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> i, ResourceProfile r, WorkerProfile workerProfile)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;SlotAndWorkerProfile&gt; future =</span><br><span class="line">            resourceManager.sendToMember(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">RequestSlotOperation</span>(jobId, r), workerProfile.getAddress());</span><br><span class="line">    <span class="keyword">return</span> future.whenComplete(</span><br><span class="line">            withTryCatch(</span><br><span class="line">                    LOGGER,</span><br><span class="line">                    (slotAndWorkerProfile, error) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(error);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            resourceManager.heartbeat(slotAndWorkerProfile.getWorkerProfile());</span><br><span class="line">                            addSlotToCacheMap(i, slotAndWorkerProfile.getSlotProfile());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当拿到全部可用节点后，会将节点先打乱，然后再随机查找一个可用资源比所需资源大的节点，随即与该节点通信，发送<code>RequestSlotOperation</code>给该节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> SlotAndWorkerProfile <span class="title function_">requestSlot</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">long</span> jobId, ResourceProfile resourceProfile)</span> &#123;</span><br><span class="line">    initStatus = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">SlotProfile</span> <span class="variable">profile</span> <span class="operator">=</span> selectBestMatchSlot(resourceProfile);</span><br><span class="line">    <span class="keyword">if</span> (profile != <span class="literal">null</span>) &#123;</span><br><span class="line">        profile.assign(jobId);</span><br><span class="line">        assignedResource.accumulateAndGet(profile.getResourceProfile(), ResourceProfile::merge);</span><br><span class="line">        unassignedResource.accumulateAndGet(</span><br><span class="line">                profile.getResourceProfile(), ResourceProfile::subtract);</span><br><span class="line">        unassignedSlots.remove(profile.getSlotID());</span><br><span class="line">        assignedSlots.put(profile.getSlotID(), profile);</span><br><span class="line">        contexts.computeIfAbsent(</span><br><span class="line">                profile.getSlotID(),</span><br><span class="line">                p -&gt; <span class="keyword">new</span> <span class="title class_">SlotContext</span>(profile.getSlotID(), taskExecutionService));</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.fine(</span><br><span class="line">            String.format(</span><br><span class="line">                    <span class="string">&quot;received slot request, jobID: %d, resource profile: %s, return: %s&quot;</span>,</span><br><span class="line">                    jobId, resourceProfile, profile));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SlotAndWorkerProfile</span>(getWorkerProfile(), profile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该节点的SlotService中接收到<code>requestSlot</code>请求后，会将自身信息进行更新，然后返回给master节点信息。<br>在请求资源的过程中，如果最终请求的资源没有达到预期结果，会得到<code>NoEnoughResourceException</code>异常，任务运行失败。<br>当资源请求成功后，会开始进行任务的部署，<code>task.makeTaskGroupDeploy()</code>将任务发送到<code>worker</code>节点上来运行任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TaskDeployState</span> <span class="variable">deployState</span> <span class="operator">=</span></span><br><span class="line">        deploy(jobMaster.getOwnedSlotProfiles(taskGroupLocation));</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> TaskDeployState <span class="title function_">deploy</span><span class="params">(<span class="meta">@NonNull</span> SlotProfile slotProfile)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (slotProfile.getWorker().equals(nodeEngine.getThisAddress())) &#123;</span><br><span class="line">            <span class="keyword">return</span> deployOnLocal(slotProfile);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> deployOnRemote(slotProfile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="keyword">return</span> TaskDeployState.failed(th);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TaskDeployState <span class="title function_">deployOnRemote</span><span class="params">(<span class="meta">@NonNull</span> SlotProfile slotProfile)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> deployInternal(</span><br><span class="line">            taskGroupImmutableInformation -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> (TaskDeployState)</span><br><span class="line">                            NodeEngineUtil.sendOperationToMemberNode(</span><br><span class="line">                                            nodeEngine,</span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">DeployTaskOperation</span>(</span><br><span class="line">                                                    slotProfile,</span><br><span class="line">                                                    nodeEngine</span><br><span class="line">                                                            .getSerializationService()</span><br><span class="line">                                                            .toData(</span><br><span class="line">                                                                    taskGroupImmutableInformation)),</span><br><span class="line">                                            slotProfile.getWorker())</span><br><span class="line">                                    .get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (getExecutionState().isEndState()) &#123;</span><br><span class="line">                        log.warn(ExceptionUtils.getMessage(e));</span><br><span class="line">                        log.warn(</span><br><span class="line">                                String.format(</span><br><span class="line">                                        <span class="string">&quot;%s deploy error, but the state is already in end state %s, skip this error&quot;</span>,</span><br><span class="line">                                        getTaskFullName(), currExecutionState));</span><br><span class="line">                        <span class="keyword">return</span> TaskDeployState.success();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> TaskDeployState.failed(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>部署任务时，会将任务信息发送到刚刚在资源分配时获取到的节点上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TaskDeployState <span class="title function_">deployTask</span><span class="params">(<span class="meta">@NonNull</span> Data taskImmutableInformation)</span> &#123;</span><br><span class="line">    <span class="type">TaskGroupImmutableInformation</span> <span class="variable">taskImmutableInfo</span> <span class="operator">=</span></span><br><span class="line">            nodeEngine.getSerializationService().toObject(taskImmutableInformation);</span><br><span class="line">    <span class="keyword">return</span> deployTask(taskImmutableInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TaskDeployState <span class="title function_">deployTask</span><span class="params">(<span class="meta">@NonNull</span> TaskGroupImmutableInformation taskImmutableInfo)</span> &#123;</span><br><span class="line">    logger.info(</span><br><span class="line">            String.format(</span><br><span class="line">                    <span class="string">&quot;received deploying task executionId [%s]&quot;</span>,</span><br><span class="line">                    taskImmutableInfo.getExecutionId()));</span><br><span class="line">    <span class="type">TaskGroup</span> <span class="variable">taskGroup</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Set&lt;ConnectorJarIdentifier&gt; connectorJarIdentifiers =</span><br><span class="line">                taskImmutableInfo.getConnectorJarIdentifiers();</span><br><span class="line">        Set&lt;URL&gt; jars = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        ClassLoader classLoader;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(connectorJarIdentifiers)) &#123;</span><br><span class="line">            <span class="comment">// Prioritize obtaining the jar package file required for the current task execution</span></span><br><span class="line">            <span class="comment">// from the local, if it does not exist locally, it will be downloaded from the</span></span><br><span class="line">            <span class="comment">// master node.</span></span><br><span class="line">            jars =</span><br><span class="line">                    serverConnectorPackageClient.getConnectorJarFromLocal(</span><br><span class="line">                            connectorJarIdentifiers);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!CollectionUtils.isEmpty(taskImmutableInfo.getJars())) &#123;</span><br><span class="line">            jars = taskImmutableInfo.getJars();</span><br><span class="line">        &#125;</span><br><span class="line">        classLoader =</span><br><span class="line">                classLoaderService.getClassLoader(</span><br><span class="line">                        taskImmutableInfo.getJobId(), Lists.newArrayList(jars));</span><br><span class="line">        <span class="keyword">if</span> (jars.isEmpty()) &#123;</span><br><span class="line">            taskGroup =</span><br><span class="line">                    nodeEngine.getSerializationService().toObject(taskImmutableInfo.getGroup());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            taskGroup =</span><br><span class="line">                    CustomClassLoadedObject.deserializeWithCustomClassLoader(</span><br><span class="line">                            nodeEngine.getSerializationService(),</span><br><span class="line">                            classLoader,</span><br><span class="line">                            taskImmutableInfo.getGroup());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(</span><br><span class="line">                String.format(</span><br><span class="line">                        <span class="string">&quot;deploying task %s, executionId [%s]&quot;</span>,</span><br><span class="line">                        taskGroup.getTaskGroupLocation(), taskImmutableInfo.getExecutionId()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (executionContexts.containsKey(taskGroup.getTaskGroupLocation())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                        String.format(</span><br><span class="line">                                <span class="string">&quot;TaskGroupLocation: %s already exists&quot;</span>,</span><br><span class="line">                                taskGroup.getTaskGroupLocation()));</span><br><span class="line">            &#125;</span><br><span class="line">            deployLocalTask(taskGroup, classLoader, jars);</span><br><span class="line">            <span class="keyword">return</span> TaskDeployState.success();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.severe(</span><br><span class="line">                String.format(</span><br><span class="line">                        <span class="string">&quot;TaskGroupID : %s  deploy error with Exception: %s&quot;</span>,</span><br><span class="line">                        taskGroup != <span class="literal">null</span> &amp;&amp; taskGroup.getTaskGroupLocation() != <span class="literal">null</span></span><br><span class="line">                                ? taskGroup.getTaskGroupLocation().toString()</span><br><span class="line">                                : <span class="string">&quot;taskGroupLocation is null&quot;</span>,</span><br><span class="line">                        ExceptionUtils.getMessage(t)));</span><br><span class="line">        <span class="keyword">return</span> TaskDeployState.failed(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当worker节点接收到任务后，会调用<code>TaskExecutionService</code>的<code>deployTask</code>方法将任务提交到启动时创建的线程池中。</p>
<p>当任务提交到线程池中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BlockingWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskTracker tracker;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startedLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BlockingWorker</span><span class="params">(TaskTracker tracker, CountDownLatch startedLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tracker = tracker;</span><br><span class="line">        <span class="built_in">this</span>.startedLatch = startedLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        TaskExecutionService.<span class="type">TaskGroupExecutionTracker</span> <span class="variable">taskGroupExecutionTracker</span> <span class="operator">=</span></span><br><span class="line">                tracker.taskGroupExecutionTracker;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span></span><br><span class="line">                executionContexts</span><br><span class="line">                        .get(taskGroupExecutionTracker.taskGroup.getTaskGroupLocation())</span><br><span class="line">                        .getClassLoader();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">oldClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">t</span> <span class="operator">=</span> tracker.task;</span><br><span class="line">        <span class="type">ProgressState</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startedLatch.countDown();</span><br><span class="line">            t.init();</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                result = t.call();</span><br><span class="line">            &#125; <span class="keyword">while</span> (!result.isDone()</span><br><span class="line">                    &amp;&amp; isRunning</span><br><span class="line">                    &amp;&amp; !taskGroupExecutionTracker.executionCompletedExceptionally());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用<code>Task.call</code> 方法，从而数据同步的任务会真正的被调用起来。</p>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>在SeaTunnel中，修改了默认的ClassLoader的类，修改为子类优先，从而避免了与其他组件类冲突的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">(<span class="type">long</span> jobId, Collection&lt;URL&gt; jars)</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;Get classloader for job &#123;&#125; with jars &#123;&#125;&quot;</span>, jobId, jars);</span><br><span class="line">    <span class="keyword">if</span> (cacheMode) &#123;</span><br><span class="line">        <span class="comment">// with cache mode, all jobs share the same classloader if the jars are the same</span></span><br><span class="line">        jobId = <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!classLoaderCache.containsKey(jobId)) &#123;</span><br><span class="line">        classLoaderCache.put(jobId, <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;());</span><br><span class="line">        classLoaderReferenceCount.put(jobId, <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, ClassLoader&gt; classLoaderMap = classLoaderCache.get(jobId);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> covertJarsToKey(jars);</span><br><span class="line">    <span class="keyword">if</span> (classLoaderMap.containsKey(key)) &#123;</span><br><span class="line">        classLoaderReferenceCount.get(jobId).get(key).incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> classLoaderMap.get(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeaTunnelChildFirstClassLoader</span>(jars);</span><br><span class="line">        log.info(<span class="string">&quot;Create classloader for job &#123;&#125; with jars &#123;&#125;&quot;</span>, jobId, jars);</span><br><span class="line">        classLoaderMap.put(key, classLoader);</span><br><span class="line">        classLoaderReferenceCount.get(jobId).put(key, <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> classLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="RestAPI任务提交"><a href="#RestAPI任务提交" class="headerlink" title="RestAPI任务提交"></a>RestAPI任务提交</h1><p>SeaTunnel也支持RestAPI的提交方式，当需要此功能时，首先需要在<code>hazelcast.yaml</code>文件中添加这样一段配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">    <span class="attr">rest-api:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">endpoint-groups:</span></span><br><span class="line">        <span class="attr">CLUSTER_WRITE:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">DATA:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>当添加这样一段配置后，hazelcast节点启动后就可以接收http请求了</p>
<p>我们同样以提交任务为例，看下执行流程。</p>
<p>当我们使用RestAPI来提交任务时，客户端的就变成了我们发送http请求的节点，服务端就是seatunnel集群。</p>
<p>当服务端接收到请求后，会根据请求的链接，调用相应的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpPostCommand httpPostCommand)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> httpPostCommand.getURI();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uri.startsWith(SUBMIT_JOB_URL)) &#123;</span><br><span class="line">            handleSubmitJob(httpPostCommand, uri);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (uri.startsWith(STOP_JOB_URL)) &#123;</span><br><span class="line">            handleStopJob(httpPostCommand, uri);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (uri.startsWith(ENCRYPT_CONFIG)) &#123;</span><br><span class="line">            handleEncrypt(httpPostCommand);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            original.handle(httpPostCommand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        prepareResponse(SC_400, httpPostCommand, exceptionResponse(e));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.warning(<span class="string">&quot;An error occurred while handling request &quot;</span> + httpPostCommand, e);</span><br><span class="line">        prepareResponse(SC_500, httpPostCommand, exceptionResponse(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.textCommandService.sendResponse(httpPostCommand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会根据路径来查找相应的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleSubmitJob</span><span class="params">(HttpPostCommand httpPostCommand, String uri)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">    Map&lt;String, String&gt; requestParams = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    RestUtil.buildRequestParams(requestParams, uri);</span><br><span class="line">    <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> RestUtil.buildConfig(requestHandle(httpPostCommand), <span class="literal">false</span>);</span><br><span class="line">    <span class="type">ReadonlyConfig</span> <span class="variable">envOptions</span> <span class="operator">=</span> ReadonlyConfig.fromConfig(config.getConfig(<span class="string">&quot;env&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">jobName</span> <span class="operator">=</span> envOptions.get(EnvCommonOptions.JOB_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="type">JobConfig</span> <span class="variable">jobConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobConfig</span>();</span><br><span class="line">    jobConfig.setName(</span><br><span class="line">            StringUtils.isEmpty(requestParams.get(RestConstant.JOB_NAME))</span><br><span class="line">                    ? jobName</span><br><span class="line">                    : requestParams.get(RestConstant.JOB_NAME));</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">startWithSavePoint</span> <span class="operator">=</span></span><br><span class="line">            Boolean.parseBoolean(requestParams.get(RestConstant.IS_START_WITH_SAVE_POINT));</span><br><span class="line">    <span class="type">String</span> <span class="variable">jobIdStr</span> <span class="operator">=</span> requestParams.get(RestConstant.JOB_ID);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">finalJobId</span> <span class="operator">=</span> StringUtils.isNotBlank(jobIdStr) ? Long.parseLong(jobIdStr) : <span class="literal">null</span>;</span><br><span class="line">    <span class="type">SeaTunnelServer</span> <span class="variable">seaTunnelServer</span> <span class="operator">=</span> getSeaTunnelServer();</span><br><span class="line">    <span class="type">RestJobExecutionEnvironment</span> <span class="variable">restJobExecutionEnvironment</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RestJobExecutionEnvironment</span>(</span><br><span class="line">                    seaTunnelServer,</span><br><span class="line">                    jobConfig,</span><br><span class="line">                    config,</span><br><span class="line">                    textCommandService.getNode(),</span><br><span class="line">                    startWithSavePoint,</span><br><span class="line">                    finalJobId);</span><br><span class="line">    <span class="type">JobImmutableInformation</span> <span class="variable">jobImmutableInformation</span> <span class="operator">=</span> restJobExecutionEnvironment.build();</span><br><span class="line">    <span class="type">long</span> <span class="variable">jobId</span> <span class="operator">=</span> jobImmutableInformation.getJobId();</span><br><span class="line">    <span class="keyword">if</span> (!seaTunnelServer.isMasterNode()) &#123;</span><br><span class="line"></span><br><span class="line">        NodeEngineUtil.sendOperationToMasterNode(</span><br><span class="line">                        getNode().nodeEngine,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">SubmitJobOperation</span>(</span><br><span class="line">                                jobId,</span><br><span class="line">                                getNode().nodeEngine.toData(jobImmutableInformation),</span><br><span class="line">                                jobImmutableInformation.isStartWithSavePoint()))</span><br><span class="line">                .join();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        submitJob(seaTunnelServer, jobImmutableInformation, jobConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.prepareResponse(</span><br><span class="line">            httpPostCommand,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">JsonObject</span>()</span><br><span class="line">                    .add(RestConstant.JOB_ID, String.valueOf(jobId))</span><br><span class="line">                    .add(RestConstant.JOB_NAME, jobConfig.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑与客户端差不多，由于没有local模式，那么就不需要去创建本地服务了。</p>
<p>在客户端我们会通过<code>ClientJobExecutionEnvironment</code>这个类来进行逻辑计划解析等操作，同样这样也有一个<code>RestJobExecutionEnvironment</code>来做同样的事情。</p>
<p>最终提交任务时，如果当前节点非master节点，那么就会向master节点发送信息，master节点接收到信息后与从命令行客户端接收信息的处理逻辑就一致了。</p>
<p>如果当前节点是master节点，会直接调用<code>submitJob</code>方法，这里直接调用了<code>coordinatorService.submitJob</code>方法进行后续的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">submitJob</span><span class="params">(</span></span><br><span class="line"><span class="params">        SeaTunnelServer seaTunnelServer,</span></span><br><span class="line"><span class="params">        JobImmutableInformation jobImmutableInformation,</span></span><br><span class="line"><span class="params">        JobConfig jobConfig)</span> &#123;</span><br><span class="line">    <span class="type">CoordinatorService</span> <span class="variable">coordinatorService</span> <span class="operator">=</span> seaTunnelServer.getCoordinatorService();</span><br><span class="line">    <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span></span><br><span class="line">            textCommandService</span><br><span class="line">                    .getNode()</span><br><span class="line">                    .nodeEngine</span><br><span class="line">                    .getSerializationService()</span><br><span class="line">                    .toData(jobImmutableInformation);</span><br><span class="line">    PassiveCompletableFuture&lt;Void&gt; voidPassiveCompletableFuture =</span><br><span class="line">            coordinatorService.submitJob(</span><br><span class="line">                    Long.parseLong(jobConfig.getJobContext().getJobId()),</span><br><span class="line">                    data,</span><br><span class="line">                    jobImmutableInformation.isStartWithSavePoint());</span><br><span class="line">    voidPassiveCompletableFuture.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，两种提交方式，都是会在提交任务的一端做逻辑计划解析，然后将信息发送给master节点，再由master节点做任务的物理计划解析，分配等操作。</p>

<br>
<h2>Tags: </h2>
  <p><a class="classtest-link" href="/tags/seatunnel/" rel="tag">seatunnel</a> — 2024年11月25日</p>
  

  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>

        </div>
        <!-- <div class="row mt-2">
  <h3>Search</h3>
  <div><input id="search-text" title="search" class="search-text" type="text" placeholder="search......"></div>
  <div style="margin-top: 1.5rem;">
    <ul id="result"></ul>
  </div>
</div> -->
        <div class="row mt-2">
  
    <div class="eight columns">
      <p id="madewith">Made with ❤ and
        <a class="footer-link icon" href="https://hexo.io" target="_blank" style="text-decoration: none;" rel="noreferrer" aria-label="Hexo.io">
        <svg class="hexo svg-hov" width="14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Hexo.js</title><path d="M12 .007L1.57 6.056V18.05L12 23.995l10.43-6.049V5.952L12 .007zm4.798 17.105l-.939.521-.939-.521V12.94H9.08v4.172l-.94.521-.938-.521V6.89l.939-.521.939.521v4.172h5.84V6.89l.94-.521.938.521v10.222z"/></svg>
        </a>
        
    </div>

    <!-- Sepcial thanks to https://simpleicons.org/ for the icons -->
    <div class="four columns mb-3 posisi" >
      
      <a class="ml-0 footer-link icon" href="https://github.com/liunaijie" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="GitHub">
        <svg class="github svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      </a>
      

      

      

      

      
      
        <a class="ml-0 footer-link icon" href="mailto:jarvis@apache.org" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="Email">
          <svg class="email svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Email</title><path d="M12 12.713l11.985-7.99c-.01-.01-11.985-7.723-11.985-7.723s-11.975 7.713-11.985 7.723l11.985 7.99zm0 2.287l-12-8v14h24v-14l-12 8z"/></svg>
        </a>
        
    </div>
  
</div>

      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>

  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>