<!DOCTYPE html>
<html lang="zh-CN">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>SeaTunnel源码解析-(三)Zeta引擎执行解析</title>
  
  <link rel="canonical" href="https://www.liunaijie.top/2024/11/24/Blog-Posts/publish/SeaTunnel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-(%E4%B8%89)Zeta%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E8%A7%A3%E6%9E%90/">
  
  <meta name="description" content="这篇文章会聊些什么SeaTunnel作为一款数据集成工具, 那么它最终的目的是来做数据同步的, 可以将数据从某个存储同步到另外一个存储中.但是这篇文档并不会聊它使用层面的事情, 而是去聊一下这个工具&amp;#x2F;框架的设计, 任务的执行等.对于某个连接器(数据库)的实现不会深入的了解.基于的源码版本:">
  
  
  <meta name="keywords" content="blog">
  
  <meta name="author" content="Jarvis">
  
  
  
  <meta property="og:site_name" content="J.A.R.V.I.S" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="SeaTunnel源码解析-(三)Zeta引擎执行解析" />
  
  <meta property="og:description" content="这篇文章会聊些什么SeaTunnel作为一款数据集成工具, 那么它最终的目的是来做数据同步的, 可以将数据从某个存储同步到另外一个存储中.但是这篇文档并不会聊它使用层面的事情, 而是去聊一下这个工具&amp;#x2F;框架的设计, 任务的执行等.对于某个连接器(数据库)的实现不会深入的了解.基于的源码版本:">
  
  <meta property="og:url" content="https://www.liunaijie.top/2024/11/24/Blog-Posts/publish/SeaTunnel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-(%E4%B8%89)Zeta%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E8%A7%A3%E6%9E%90/" />

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="SeaTunnel源码解析-(三)Zeta引擎执行解析">
  
  <meta name="twitter:description" content="这篇文章会聊些什么SeaTunnel作为一款数据集成工具, 那么它最终的目的是来做数据同步的, 可以将数据从某个存储同步到另外一个存储中.但是这篇文档并不会聊它使用层面的事情, 而是去聊一下这个工具&amp;#x2F;框架的设计, 任务的执行等.对于某个连接器(数据库)的实现不会深入的了解.基于的源码版本:">
  
  
  
  
  <meta name="twitter:url" content="https://www.liunaijie.top/2024/11/24/Blog-Posts/publish/SeaTunnel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-(%E4%B8%89)Zeta%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E8%A7%A3%E6%9E%90/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="/fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/jarvis.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

  
  <script src="/js/pic.min.js" defer></script>
  

  

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="J.A.R.V.I.S" type="application/atom+xml">
</head>

<body>
  <div class="container">
    <div class="row">
      <div>

        <div class="row">
  <div class="two columns" style="max-width: 50px">
    <h1 class="mt-2 mode">
      <div onclick=setDarkMode(true) id="darkBtn"></div>
      <div onclick=setDarkMode(false) id="lightBtn" class=hidden></div>
      <script >
        if (localStorage.getItem('preferredTheme') == 'dark') {
          setDarkMode(true)
        }
        function setDarkMode(isDark) {
          var darkBtn = document.getElementById('darkBtn')
          var lightBtn = document.getElementById('lightBtn')
          if (isDark) {
            lightBtn.style.display = "block"
            darkBtn.style.display = "none"
            localStorage.setItem('preferredTheme', 'dark');
          } else {
            lightBtn.style.display = "none"
            darkBtn.style.display = "block"
            localStorage.removeItem('preferredTheme');
          }
          document.body.classList.toggle("darkmode");
        }
      </script>
    </h1>
  </div>

  <div class="six columns ml-1">
    <h1 class="mt-2">
      Jarvis&#39;s Blog
    </h1>
  </div>

  <div class="twelve columns">
    <div class="row">
      <div class="nine columns left">
        
          
          <a href="/" class="ml">Home</a>
          
        
          
          <a href="/categories/publish/" class="ml">Publish</a>
          
        
          
          <a href="/about" class="ml">About</a>
          
        
          
          <a href="/atom.xml" class="ml">Rss</a>
          
        
      </div>
    </div>
    <hr style="margin-bottom: 2.6rem">
  </div>
</div>

        <div class="trans">
            <h2>SeaTunnel源码解析-(三)Zeta引擎执行解析</h2>

  <h1 id="这篇文章会聊些什么"><a href="#这篇文章会聊些什么" class="headerlink" title="这篇文章会聊些什么"></a>这篇文章会聊些什么</h1><p>SeaTunnel作为一款数据集成工具, 那么它最终的目的是来做数据同步的, 可以将数据从某个存储同步到另外一个存储中.<br>但是这篇文档并不会聊它使用层面的事情, 而是去聊一下这个工具&#x2F;框架的设计, 任务的执行等.对于某个连接器(数据库)的实现不会深入的了解.<br>基于的源码版本: <code>2.3.6-release</code></p>
<h1 id="任务是如何被执行的"><a href="#任务是如何被执行的" class="headerlink" title="任务是如何被执行的"></a>任务是如何被执行的</h1><p>在我的另外一篇文章<a href="2.Zeta%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3.md">2.Zeta引擎源码讲解</a>中有一些关于Zeta引擎的分析, 聊了一下Zeta引擎的客户端, 服务端都会做一些什么事情, 也笼统的带了一点任务执行的内容, 想了解相关内容的朋友可以去看一下.<br>在下面的内容, 则主要是记录一下在SeaTunnel中, 一个任务是如何与连接器中的各种类进行关联的.</p>
<p>要聊任务与连接器的关联, 就要回到物理计划生成的这一部分(<code>PhysicalPlanGenerator#generate()</code>).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;SubPlan&gt; subPlanStream =  </span><br><span class="line">        pipelines.stream()  </span><br><span class="line">                .map(  </span><br><span class="line">                        pipeline -&gt; &#123;  </span><br><span class="line">                            <span class="built_in">this</span>.pipelineTasks.clear();  </span><br><span class="line">                            <span class="built_in">this</span>.startingTasks.clear();  </span><br><span class="line">                            <span class="built_in">this</span>.subtaskActions.clear();  </span><br><span class="line">                            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">pipelineId</span> <span class="operator">=</span> pipeline.getId();  </span><br><span class="line">                            <span class="keyword">final</span> List&lt;ExecutionEdge&gt; edges = pipeline.getEdges();  </span><br><span class="line">  </span><br><span class="line">                            List&lt;SourceAction&lt;?, ?, ?&gt;&gt; sources = findSourceAction(edges);  </span><br><span class="line">  </span><br><span class="line">                            List&lt;PhysicalVertex&gt; coordinatorVertexList =  </span><br><span class="line">                                    getEnumeratorTask(  </span><br><span class="line">                                            sources, pipelineId, totalPipelineNum);  </span><br><span class="line">                            coordinatorVertexList.addAll(  </span><br><span class="line">                                    getCommitterTask(edges, pipelineId, totalPipelineNum));  </span><br><span class="line">  </span><br><span class="line">                            List&lt;PhysicalVertex&gt; physicalVertexList =  </span><br><span class="line">                                    getSourceTask(  </span><br><span class="line">                                            edges, sources, pipelineId, totalPipelineNum);  </span><br><span class="line">  </span><br><span class="line">                            physicalVertexList.addAll(  </span><br><span class="line">                                    getShuffleTask(edges, pipelineId, totalPipelineNum));  </span><br><span class="line">  </span><br><span class="line">                            CompletableFuture&lt;PipelineStatus&gt; pipelineFuture =  </span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();  </span><br><span class="line">                            waitForCompleteBySubPlanList.add(  </span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">PassiveCompletableFuture</span>&lt;&gt;(pipelineFuture));  </span><br><span class="line">  </span><br><span class="line">                            checkpointPlans.put(  </span><br><span class="line">                                    pipelineId,  </span><br><span class="line">                                    CheckpointPlan.builder()  </span><br><span class="line">                                            .pipelineId(pipelineId)  </span><br><span class="line">                                            .pipelineSubtasks(pipelineTasks)  </span><br><span class="line">                                            .startingSubtasks(startingTasks)  </span><br><span class="line">                                            .pipelineActions(pipeline.getActions())  </span><br><span class="line">                                            .subtaskActions(subtaskActions)  </span><br><span class="line">                                            .build());  </span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubPlan</span>(  </span><br><span class="line">                                    pipelineId,  </span><br><span class="line">                                    totalPipelineNum,  </span><br><span class="line">                                    initializationTimestamp,  </span><br><span class="line">                                    physicalVertexList,  </span><br><span class="line">                                    coordinatorVertexList,  </span><br><span class="line">                                    jobImmutableInformation,  </span><br><span class="line">                                    executorService,  </span><br><span class="line">                                    runningJobStateIMap,  </span><br><span class="line">                                    runningJobStateTimestampsIMap,  </span><br><span class="line">                                    tagFilter);  </span><br><span class="line">                        &#125;);</span><br></pre></td></tr></table></figure>

<p>这是将执行计划转换为物理计划时的相关代码，里面有这样4行代码。<br>生成<code>EnumeratorTask</code>, <code>CommitterTask</code>将其添加到协调器任务列表中<br>生成<code>SourceTask</code>，<code>ShuffleTask</code>将其添加到物理任务列表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PhysicalVertex&gt; coordinatorVertexList =  </span><br><span class="line">        getEnumeratorTask(  </span><br><span class="line">                sources, pipelineId, totalPipelineNum);  </span><br><span class="line">coordinatorVertexList.addAll(  </span><br><span class="line">        getCommitterTask(edges, pipelineId, totalPipelineNum));  </span><br><span class="line">  </span><br><span class="line">List&lt;PhysicalVertex&gt; physicalVertexList =  </span><br><span class="line">        getSourceTask(  </span><br><span class="line">                edges, sources, pipelineId, totalPipelineNum);  </span><br><span class="line">  </span><br><span class="line">physicalVertexList.addAll(  </span><br><span class="line">        getShuffleTask(edges, pipelineId, totalPipelineNum));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成计划图的过程的大致在第二篇文章中也有记录<a href="2.Zeta%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3.md">2.Zeta引擎源码讲解</a><br>我们这篇文章看下这四行代码以及他们与上面的<code>Source</code>，<code>Transform</code>，<code>Sink</code>有什么关系。接口中定义的<code>reader</code>，<code>enumerator</code>，<code>writer</code>是如何被执行的。</p>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>在看这几个之前先看下他们实现的公共接口<code>Task</code><br>从物理计划解析的代码可以知道，一个同步任务的执行过程都会被转换为<code>Task</code>。<br><code>Task</code>是执行层面的最小单位，一个同步任务配置<code>DAG</code>，可以包括多个不相关，可以并行的<code>Pipeline</code>，一个<code>Pipeline</code>中可以包括多个类型的<code>Task</code>，<code>Task</code>之间存在依赖关系，可以认为是一个图中的一个顶点。<br>任务的容错也是基于最小粒度的Task来进行恢复的，而无需恢复整个DAG或Pipeline。可以实现最小粒度的容错。</p>
<p>一个<code>Task</code>在执行时会被<code>worker</code>上线程池里面的一个线程拿去执行，在<code>SeaTunnel</code>中对于数据同步的场景，某些Task可能暂时没有数据需要进行同步，如果一直占用某个线程资源，可能会造成浪费的情况，做了共享资源的优化。关于这部分的内容，可以参考这个<a target="_blank" rel="noopener" href="https://github.com/apache/seatunnel/issues/2279">Pull Request</a>以及<code>TaskExecutionService#BlockingWorker</code>和<code>TaskExecutionService#CooperativeTaskWorker</code>相关代码(此功能也默认没有开启，不过这部分代码的设计确实值得了解学习一下。)</p>
<p>一个<code>Task</code>被分类为<code>CoordinatorTask</code>协调任务和<code>SeaTunnelTask</code>同步任务。<br>这篇内容里面不会对<code>CoordinatorTask</code>协调任务里面的<code>checkpoint</code>进行探讨, 只会关注<code>SeaTunnelTask</code>同步任务.</p>
<h3 id="SourceSplitEnumeratorTask"><a href="#SourceSplitEnumeratorTask" class="headerlink" title="SourceSplitEnumeratorTask"></a>SourceSplitEnumeratorTask</h3><p>在生成物理计划时，会对所有的<code>source</code>进行遍历，为每个<code>source</code>都创建一个<br><code>SourceSplitEnumeratorTask</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;PhysicalVertex&gt; <span class="title function_">getEnumeratorTask</span><span class="params">(  </span></span><br><span class="line"><span class="params">        List&lt;SourceAction&lt;?, ?, ?&gt;&gt; sources, <span class="type">int</span> pipelineIndex, <span class="type">int</span> totalPipelineNum)</span> &#123;  </span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(-<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> sources.stream()  </span><br><span class="line">            .map(  </span><br><span class="line">                    sourceAction -&gt; &#123;  </span><br><span class="line">                        <span class="type">long</span> <span class="variable">taskGroupID</span> <span class="operator">=</span> idGenerator.getNextId();  </span><br><span class="line">                        <span class="type">long</span> <span class="variable">taskTypeId</span> <span class="operator">=</span> idGenerator.getNextId();  </span><br><span class="line">                        <span class="type">TaskGroupLocation</span> <span class="variable">taskGroupLocation</span> <span class="operator">=</span>  </span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">TaskGroupLocation</span>(  </span><br><span class="line">                                        jobImmutableInformation.getJobId(),  </span><br><span class="line">                                        pipelineIndex,  </span><br><span class="line">                                        taskGroupID);  </span><br><span class="line">                        <span class="type">TaskLocation</span> <span class="variable">taskLocation</span> <span class="operator">=</span>  </span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">TaskLocation</span>(taskGroupLocation, taskTypeId, <span class="number">0</span>);  </span><br><span class="line">                        SourceSplitEnumeratorTask&lt;?&gt; t =  </span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">SourceSplitEnumeratorTask</span>&lt;&gt;(  </span><br><span class="line">                                        jobImmutableInformation.getJobId(),  </span><br><span class="line">                                        taskLocation,  </span><br><span class="line">                                        sourceAction);  </span><br><span class="line">                        ...</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;)  </span><br><span class="line">            .collect(Collectors.toList());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看下这个数据源切入任务类的成员变量和构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SourceSplitEnumeratorTask</span>&lt;SplitT <span class="keyword">extends</span> <span class="title class_">SourceSplit</span>&gt; <span class="keyword">extends</span> <span class="title class_">CoordinatorTask</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3713701594297977775L</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SourceAction&lt;?, SplitT, Serializable&gt; source;  </span><br><span class="line">    <span class="keyword">private</span> SourceSplitEnumerator&lt;SplitT, Serializable&gt; enumerator;  </span><br><span class="line">    <span class="keyword">private</span> SeaTunnelSplitEnumeratorContext&lt;SplitT&gt; enumeratorContext;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Serializer&lt;Serializable&gt; enumeratorStateSerializer;  </span><br><span class="line">    <span class="keyword">private</span> Serializer&lt;SplitT&gt; splitSerializer;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxReaderSize;  </span><br><span class="line">    <span class="keyword">private</span> Set&lt;Long&gt; unfinishedReaders;  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;TaskLocation, Address&gt; taskMemberMapping;  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, TaskLocation&gt; taskIDToTaskLocationMapping;  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, TaskLocation&gt; taskIndexToTaskLocationMapping;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SeaTunnelTaskState currState;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> readerRegisterComplete;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> prepareCloseTriggered;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SourceSplitEnumeratorTask</span><span class="params">(  </span></span><br><span class="line"><span class="params">            <span class="type">long</span> jobID, TaskLocation taskID, SourceAction&lt;?, SplitT, ?&gt; source)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(jobID, taskID);  </span><br><span class="line">        <span class="built_in">this</span>.source = (SourceAction&lt;?, SplitT, Serializable&gt;) source;  </span><br><span class="line">        <span class="built_in">this</span>.currState = SeaTunnelTaskState.CREATED;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个类中持有了几个关键的成员变量，<code>SourceAction</code>，<code>SourceSplitEnumerator</code>, <code>SeaTunnelSplitEnumeratorContext</code> 这些都是与<code>enumerator</code>相关的类。<br>还有几个<code>map</code>，<code>set</code>等容器存放了任务信息，任务执行地址等等的映射关系。</p>
<p>在构造方法的最后会将当前任务的状态初始化为<code>CREATED</code></p>
<p>再来看下这个任务的其他方法：</p>
<ul>
<li>初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    currState = SeaTunnelTaskState.INIT;  </span><br><span class="line">    <span class="built_in">super</span>.init();  </span><br><span class="line">    readerRegisterComplete = <span class="literal">false</span>;  </span><br><span class="line">    log.info(  </span><br><span class="line">            <span class="string">&quot;starting seatunnel source split enumerator task, source name: &quot;</span>  </span><br><span class="line">                    + source.getName());  </span><br><span class="line">    enumeratorContext =  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SeaTunnelSplitEnumeratorContext</span>&lt;&gt;(  </span><br><span class="line">                    <span class="built_in">this</span>.source.getParallelism(),  </span><br><span class="line">                    <span class="built_in">this</span>,  </span><br><span class="line">                    getMetricsContext(),  </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">JobEventListener</span>(taskLocation, getExecutionContext()));  </span><br><span class="line">    enumeratorStateSerializer = <span class="built_in">this</span>.source.getSource().getEnumeratorStateSerializer();  </span><br><span class="line">    splitSerializer = <span class="built_in">this</span>.source.getSource().getSplitSerializer();  </span><br><span class="line">    taskMemberMapping = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">    taskIDToTaskLocationMapping = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">    taskIndexToTaskLocationMapping = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">    maxReaderSize = source.getParallelism();  </span><br><span class="line">    unfinishedReaders = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
在初始化时，会将状态修改为<code>INIT</code>，并且创建<code>enumeratorContext</code>，以及对其他几个变量进行初始化操作。<br>不知道大家有没有注意到，到执行完<code>init</code>方法，<code>enumerator</code>实例都没有被创建出来，<br>当搜索一下代码，会发现<code>enumerator</code>实例会在<code>restoreState(List&lt;ActionSubtaskState&gt; actionStateList)</code>这个方法中进行初始化。<br>当我们看完状态切换后就可以看到这个方法什么时候被调用了。</li>
<li>状态切换<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stateProcess</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">switch</span> (currState) &#123;  </span><br><span class="line">        <span class="keyword">case</span> INIT:  </span><br><span class="line">            currState = WAITING_RESTORE;  </span><br><span class="line">            reportTaskStatus(WAITING_RESTORE);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> WAITING_RESTORE:  </span><br><span class="line">            <span class="keyword">if</span> (restoreComplete.isDone()) &#123;  </span><br><span class="line">                currState = READY_START;  </span><br><span class="line">                reportTaskStatus(READY_START);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> READY_START:  </span><br><span class="line">            <span class="keyword">if</span> (startCalled &amp;&amp; readerRegisterComplete) &#123;  </span><br><span class="line">                currState = STARTING;  </span><br><span class="line">                enumerator.open();  </span><br><span class="line">                enumeratorContext.getEventListener().onEvent(<span class="keyword">new</span> <span class="title class_">EnumeratorOpenEvent</span>());  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> STARTING:  </span><br><span class="line">            currState = RUNNING;  </span><br><span class="line">            log.info(<span class="string">&quot;received enough reader, starting enumerator...&quot;</span>);  </span><br><span class="line">            enumerator.run();  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> RUNNING:  </span><br><span class="line">            <span class="comment">// The reader closes automatically after reading  </span></span><br><span class="line">            <span class="keyword">if</span> (prepareCloseStatus) &#123;  </span><br><span class="line">                <span class="built_in">this</span>.getExecutionContext()  </span><br><span class="line">                        .sendToMaster(<span class="keyword">new</span> <span class="title class_">LastCheckpointNotifyOperation</span>(jobID, taskLocation));  </span><br><span class="line">                currState = PREPARE_CLOSE;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prepareCloseTriggered) &#123;  </span><br><span class="line">                currState = PREPARE_CLOSE;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> PREPARE_CLOSE:  </span><br><span class="line">            <span class="keyword">if</span> (closeCalled) &#123;  </span><br><span class="line">                currState = CLOSED;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> CLOSED:  </span><br><span class="line">            <span class="built_in">this</span>.close();  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">            <span class="comment">// TODO support cancel by outside  </span></span><br><span class="line">        <span class="keyword">case</span> CANCELLING:  </span><br><span class="line">            <span class="built_in">this</span>.close();  </span><br><span class="line">            currState = CANCELED;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        <span class="keyword">default</span>:  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown Enumerator State: &quot;</span> + currState);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>当调用<code>init</code>方法，会将状态设置为<code>INIT</code>，进入分支判断</li>
<li>当状态为<code>INIT</code>时，将状态切换为<code>WAITING_RESTORE</code></li>
<li>当状态为<code>WAITING_RESTORE</code>时，进行<code>restoreComplete.isDone()</code>条件判断，当不满足时，睡眠100毫秒后重试。当满足时，会将状态设置为<code>READY_START</code><blockquote>
<p><code>restoreComplete</code>在执行<code>init</code>方法时，会完成初始化操作，所以这里的睡眠等待就是等待<code>init</code>方法调用完成。</p>
</blockquote>
</li>
<li>当状态为<code>READY_START</code>时，会判断是否所有的reader都注册完成，如果都注册完成则将状态修改为<code>STARTING</code>，并且调用<code>enumerator.open()</code>方法。如果没有全部注册完成，则是继续休眠等待，一直到全部注册完成为止。<blockquote>
<p><code>readerRegisterComplete</code>变量在什么时候会变成true：<br> 在初始化时，可以获取到source的并行度，也就是最终需要多少个reader，保存为maxReaderSize<br> reader在启动时，会向enumerator注册自己的地址，在SourceSplitEnumeratorTask中内部维护了一个map结构，保存了reader的信息，每当有新reader注册时就会判断是否达到maxReaderSize，当达到数量后，会将readerRegisterComplete置为true</p>
</blockquote>
</li>
<li>当状态为<code>STARTING</code>时，将状态切换为<code>RUNNING</code>，同时调用<code>enumerator.run()</code>方法。<br>当调用run方法后，enumerator会真正去执行切分任务，根据配置，实际数据等等方式来将数据读取任务切分成多个小任务。然后将任务分发到不同的reader上。</li>
<li>当状态为<code>RUNNING</code>时，会检查状态是否需要关闭，如果需要关闭则将状态修改为<code>PREPARE_CLOSE</code>, 否则休眠等待一直等到需要关闭。<blockquote>
<p>prepareCloseStatus, prepareCloseTriggered变量什么时候会变为true：<br>prepareCloseStatus变量会在所有的reader都完成读取任务时将状态置为true，也就是说enumerator任务是在所有reader任务结束之后才能结束的。<br>prepareCloseTriggered 变量则是当接收到系统任务完成或者是接收到需要做savepoint时才会将状态置为true<br>当两个变量被置为true时，表示当前任务已经结束或者需要手动结束了</p>
</blockquote>
</li>
<li>当状态为<code>PREPARE_CLOSE</code>时，会判断<code>closeCalled</code>变量是否为true，如果是则将状态修改为<code>CLOSED</code>，否则休眠等待</li>
<li>CLOSED&#x2F;CANCELLING状态时，则调用close方法对当前任务进行资源关闭清理工作。</li>
</ol>
<p>刚刚在上面有写到<code>enumerator</code>实例没有被初始化，那么当调用<code>enumerator</code>相关方法时应该会得到空指针异常，所以初始化操作也就是<code>restoreState</code>的调用肯定是在<code>READY_START</code>状态前。<br>在最开始的两个状态<code>INIT</code>,<code>WAITING_RESTORE</code>中，有两个上报更新任务状态的方法调用.</p>
<ul>
<li><code>reportTaskStatus(WAITING_RESTORE);</code></li>
<li><code>reportTaskStatus(READY_START);</code><br>这个方法里，会向集群的Master发送一条<code>TaskReportStatusOperation</code>消息，消息里包含当前任务的位置和状态信息<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reportTaskStatus</span><span class="params">(SeaTunnelTaskState status)</span> &#123;  </span><br><span class="line">    getExecutionContext()  </span><br><span class="line">            .sendToMaster(<span class="keyword">new</span> <span class="title class_">TaskReportStatusOperation</span>(taskLocation, status))  </span><br><span class="line">            .join();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>我们看下<code>TaskReportStatusOperation</code>这个类的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">CoordinatorService</span> <span class="variable">coordinatorService</span> <span class="operator">=</span>  </span><br><span class="line">            ((SeaTunnelServer) getService()).getCoordinatorService();  </span><br><span class="line">    RetryUtils.retryWithException(  </span><br><span class="line">            () -&gt; &#123;  </span><br><span class="line">                coordinatorService  </span><br><span class="line">                        .getJobMaster(location.getJobId())  </span><br><span class="line">                        .getCheckpointManager()  </span><br><span class="line">                        .reportedTask(<span class="built_in">this</span>);  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">            &#125;,  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RetryUtils</span>.RetryMaterial(  </span><br><span class="line">                    Constant.OPERATION_RETRY_TIME,  </span><br><span class="line">                    <span class="literal">true</span>,  </span><br><span class="line">                    e -&gt; <span class="literal">true</span>,  </span><br><span class="line">                    Constant.OPERATION_RETRY_SLEEP));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在这个类中，会根据当前任务的id获取到<code>JobMaster</code>，然后调用其<code>checkpointManager.reportTask()</code>方法<br>再来看下<code>checkpointManager.reportTask()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reportedTask</span><span class="params">(TaskReportStatusOperation reportStatusOperation)</span> &#123;  </span><br><span class="line">    <span class="comment">// task address may change during restore.  </span></span><br><span class="line">    log.debug(  </span><br><span class="line">            <span class="string">&quot;reported task(&#123;&#125;) status &#123;&#125;&quot;</span>,  </span><br><span class="line">            reportStatusOperation.getLocation().getTaskID(),  </span><br><span class="line">            reportStatusOperation.getStatus());  </span><br><span class="line">    getCheckpointCoordinator(reportStatusOperation.getLocation())  </span><br><span class="line">            .reportedTask(reportStatusOperation);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reportedTask</span><span class="params">(TaskReportStatusOperation operation)</span> &#123;  </span><br><span class="line">    pipelineTaskStatus.put(operation.getLocation().getTaskID(), operation.getStatus());  </span><br><span class="line">    CompletableFuture.runAsync(  </span><br><span class="line">                    () -&gt; &#123;  </span><br><span class="line">                        <span class="keyword">switch</span> (operation.getStatus()) &#123;  </span><br><span class="line">                            <span class="keyword">case</span> WAITING_RESTORE:  </span><br><span class="line">                                restoreTaskState(operation.getLocation());  </span><br><span class="line">                                <span class="keyword">break</span>;  </span><br><span class="line">                            <span class="keyword">case</span> READY_START:  </span><br><span class="line">                                allTaskReady();  </span><br><span class="line">                                <span class="keyword">break</span>;  </span><br><span class="line">                            <span class="keyword">default</span>:  </span><br><span class="line">                                <span class="keyword">break</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;,  </span><br><span class="line">                    executorService)  </span><br><span class="line">            .exceptionally(  </span><br><span class="line">                    error -&gt; &#123;  </span><br><span class="line">                        handleCoordinatorError(  </span><br><span class="line">                                <span class="string">&quot;task running failed&quot;</span>,  </span><br><span class="line">                                error,  </span><br><span class="line">                                CheckpointCloseReason.CHECKPOINT_INSIDE_ERROR);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">                    &#125;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在<code>CheckpointCoordinator</code>中，会根据状态分别调用<code>restoreTaskState()</code>和<code>allTaskReady()</code>两个方法。<br>先看下<code>restoreTaskState()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">restoreTaskState</span><span class="params">(TaskLocation taskLocation)</span> &#123;  </span><br><span class="line">    List&lt;ActionSubtaskState&gt; states = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (latestCompletedCheckpoint != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!latestCompletedCheckpoint.isRestored()) &#123;  </span><br><span class="line">            latestCompletedCheckpoint.setRestored(<span class="literal">true</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">currentParallelism</span> <span class="operator">=</span> pipelineTasks.get(taskLocation.getTaskVertexId());  </span><br><span class="line">        plan.getSubtaskActions()  </span><br><span class="line">                .get(taskLocation)  </span><br><span class="line">                .forEach(  </span><br><span class="line">                        tuple -&gt; &#123;  </span><br><span class="line">                            <span class="type">ActionState</span> <span class="variable">actionState</span> <span class="operator">=</span>  </span><br><span class="line">                                    latestCompletedCheckpoint.getTaskStates().get(tuple.f0());  </span><br><span class="line">                            <span class="keyword">if</span> (actionState == <span class="literal">null</span>) &#123;  </span><br><span class="line">                                LOG.info(  </span><br><span class="line">                                        <span class="string">&quot;Not found task(&#123;&#125;) state for key(&#123;&#125;)&quot;</span>,  </span><br><span class="line">                                        taskLocation,  </span><br><span class="line">                                        tuple.f0());  </span><br><span class="line">                                <span class="keyword">return</span>;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            <span class="keyword">if</span> (COORDINATOR_INDEX.equals(tuple.f1())) &#123;  </span><br><span class="line">                                states.add(actionState.getCoordinatorState());  </span><br><span class="line">                                <span class="keyword">return</span>;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> tuple.f1();  </span><br><span class="line">                                    i &lt; actionState.getParallelism();  </span><br><span class="line">                                    i += currentParallelism) &#123;  </span><br><span class="line">                                <span class="type">ActionSubtaskState</span> <span class="variable">subtaskState</span> <span class="operator">=</span>  </span><br><span class="line">                                        actionState.getSubtaskStates().get(i);  </span><br><span class="line">                                <span class="keyword">if</span> (subtaskState != <span class="literal">null</span>) &#123;  </span><br><span class="line">                                    states.add(subtaskState);  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    checkpointManager  </span><br><span class="line">            .sendOperationToMemberNode(<span class="keyword">new</span> <span class="title class_">NotifyTaskRestoreOperation</span>(taskLocation, states))  </span><br><span class="line">            .join();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里，首先会判断<code>latestCompletedCheckpoint</code>是否为null，那么我们在任务最开始的时候，这个状态肯定是空的，那么就会直接调用最下面的一段代码，发送一个<code>NotifyTaskRestoreOperation</code>到具体的任务节点.<br>既然看到这段代码，那么就再多想一下，如果<code>latestCompletedCheckpoint</code>不为null，那么就表示之前有过<code>checkpoint</code>记录，那么就表示了该任务是由历史状态进行恢复的，需要查询出历史状态，从历史状态进行恢复，这里的<code>List&lt;ActionSubtaskState&gt;</code>就存储了这些状态信息。</p>
<p>继续看下<code>NotifyTaskRestoreOperation</code>的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">SeaTunnelServer</span> <span class="variable">server</span> <span class="operator">=</span> getService();  </span><br><span class="line">    RetryUtils.retryWithException(  </span><br><span class="line">            () -&gt; &#123;  </span><br><span class="line">                log.debug(<span class="string">&quot;NotifyTaskRestoreOperation &quot;</span> + taskLocation);  </span><br><span class="line">                <span class="type">TaskGroupContext</span> <span class="variable">groupContext</span> <span class="operator">=</span>  </span><br><span class="line">                        server.getTaskExecutionService()  </span><br><span class="line">                                .getExecutionContext(taskLocation.getTaskGroupLocation());  </span><br><span class="line">                <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> groupContext.getTaskGroup().getTask(taskLocation.getTaskID());  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();  </span><br><span class="line">                    task.getExecutionContext()  </span><br><span class="line">                            .getTaskExecutionService()  </span><br><span class="line">                            .asyncExecuteFunction(  </span><br><span class="line">                                    taskLocation.getTaskGroupLocation(),  </span><br><span class="line">                                    () -&gt; &#123;  </span><br><span class="line">                                        Thread.currentThread()  </span><br><span class="line">                                                .setContextClassLoader(  </span><br><span class="line">                                                        groupContext.getClassLoader());  </span><br><span class="line">                                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                                            log.debug(  </span><br><span class="line">                                                    <span class="string">&quot;NotifyTaskRestoreOperation.restoreState &quot;</span>  </span><br><span class="line">                                                            + restoredState);  </span><br><span class="line">                                            task.restoreState(restoredState);  </span><br><span class="line">                                            log.debug(  </span><br><span class="line">                                                    <span class="string">&quot;NotifyTaskRestoreOperation.finished &quot;</span>  </span><br><span class="line">                                                            + restoredState);  </span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (Throwable e) &#123;  </span><br><span class="line">                                            task.getExecutionContext()  </span><br><span class="line">                                                    .sendToMaster(  </span><br><span class="line">                                                            <span class="keyword">new</span> <span class="title class_">CheckpointErrorReportOperation</span>(  </span><br><span class="line">                                                                    taskLocation, e));  </span><br><span class="line">                                        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                                            Thread.currentThread()  </span><br><span class="line">                                                    .setContextClassLoader(classLoader);  </span><br><span class="line">                                        &#125;  </span><br><span class="line">                                    &#125;);  </span><br><span class="line">  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SeaTunnelException</span>(e);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">            &#125;,  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RetryUtils</span>.RetryMaterial(  </span><br><span class="line">                    Constant.OPERATION_RETRY_TIME,  </span><br><span class="line">                    <span class="literal">true</span>,  </span><br><span class="line">                    exception -&gt;  </span><br><span class="line">                            exception <span class="keyword">instanceof</span> TaskGroupContextNotFoundException  </span><br><span class="line">                                    &amp;&amp; !server.taskIsEnded(taskLocation.getTaskGroupLocation()),  </span><br><span class="line">                    Constant.OPERATION_RETRY_SLEEP));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看出最终是调用了<code>task.restoreState(restoredState)</code>方法。在这个方法调用中，<code>enumerator</code>实例也就被初始化了。</p>
<p>在上面还有一个当状态为<code>READY_START</code>时，调用<code>allTaskReady()</code>的分支。<br>我们先回到分支切换时，看下当什么情况下会是<code>READY_START</code>的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WAITING_RESTORE:  </span><br><span class="line">    <span class="keyword">if</span> (restoreComplete.isDone()) &#123;  </span><br><span class="line">        currState = READY_START;  </span><br><span class="line">        reportTaskStatus(READY_START);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>这里会判断一个<code>restoreComplete</code>是否是完成状态，而这个变量会在<code>restoreState</code>方法内标记为完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreState</span><span class="params">(List&lt;ActionSubtaskState&gt; actionStateList)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    log.debug(<span class="string">&quot;restoreState for split enumerator [&#123;&#125;]&quot;</span>, actionStateList);  </span><br><span class="line">    Optional&lt;Serializable&gt; state =  .....;  </span><br><span class="line">    <span class="keyword">if</span> (state.isPresent()) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.enumerator =  </span><br><span class="line">                <span class="built_in">this</span>.source.getSource().restoreEnumerator(enumeratorContext, state.get());  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.enumerator = <span class="built_in">this</span>.source.getSource().createEnumerator(enumeratorContext);  </span><br><span class="line">    &#125;  </span><br><span class="line">    restoreComplete.complete(<span class="literal">null</span>);  </span><br><span class="line">    log.debug(<span class="string">&quot;restoreState split enumerator [&#123;&#125;] finished&quot;</span>, actionStateList);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是当初始化真正完成时，会标记为<code>READY_START</code>的状态。<br>看下<code>allTaskReady</code>的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">allTaskReady</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (pipelineTaskStatus.size() != plan.getPipelineSubtasks().size()) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (SeaTunnelTaskState status : pipelineTaskStatus.values()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (READY_START != status) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    isAllTaskReady = <span class="literal">true</span>;  </span><br><span class="line">    InvocationFuture&lt;?&gt;[] futures = notifyTaskStart();  </span><br><span class="line">    CompletableFuture.allOf(futures).join();  </span><br><span class="line">    notifyCompleted(latestCompletedCheckpoint);  </span><br><span class="line">    <span class="keyword">if</span> (coordinatorConfig.isCheckpointEnable()) &#123;  </span><br><span class="line">        LOG.info(<span class="string">&quot;checkpoint is enabled, start schedule trigger pending checkpoint.&quot;</span>);  </span><br><span class="line">        scheduleTriggerPendingCheckpoint(coordinatorConfig.getCheckpointInterval());  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        LOG.info(  </span><br><span class="line">                <span class="string">&quot;checkpoint is disabled, because in batch mode and &#x27;checkpoint.interval&#x27; of env is missing.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法内调用<code>notifyTaskStart()</code>方法，在此方法内会发送一个<code>NotifyTaskStartOperation</code>消息，在<code>NotifyTaskStartOperation</code>中，会获取到<code>Task</code>，调用<code>startCall</code>方法，在<code>startCall</code>中，将<code>startCalled</code>变量置为<code>true</code></p>
<p>只有这里被执行了，状态切换中的<code>READY_START</code>状态才会切换为<code>STARTING</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> READY_START:  </span><br><span class="line">    <span class="comment">// 当任务启动并且所有reader节点也都启动注册完成后  </span></span><br><span class="line">    <span class="comment">// 改为STARTING状态，并且调用enumerate的open方法  </span></span><br><span class="line">    <span class="comment">// 否则一直等待</span></span><br><span class="line">    <span class="comment">// 直到自身启动完成，以及所有reader注册完成  </span></span><br><span class="line">    <span class="keyword">if</span> (startCalled &amp;&amp; readerRegisterComplete) &#123;  </span><br><span class="line">        currState = STARTING;  </span><br><span class="line">        enumerator.open();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>其他的任务类型也都会有这样一段逻辑。</p>
<p>接着按照顺序先看下<code>committer task</code>，这是另外一个协调任务</p>
<h3 id="SinkAggregatedCommitterTask"><a href="#SinkAggregatedCommitterTask" class="headerlink" title="SinkAggregatedCommitterTask"></a>SinkAggregatedCommitterTask</h3><p>这个类的代码与enumerator的代码类似，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinkAggregatedCommitterTask</span>&lt;CommandInfoT, AggregatedCommitInfoT&gt;  </span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">CoordinatorTask</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">5906594537520393503L</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SeaTunnelTaskState currState;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SinkAction&lt;?, ?, CommandInfoT, AggregatedCommitInfoT&gt; sink;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxWriterSize;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SinkAggregatedCommitter&lt;CommandInfoT, AggregatedCommitInfoT&gt; aggregatedCommitter;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Serializer&lt;AggregatedCommitInfoT&gt; aggregatedCommitInfoSerializer;  </span><br><span class="line">    <span class="meta">@Getter</span> <span class="keyword">private</span> <span class="keyword">transient</span> Serializer&lt;CommandInfoT&gt; commitInfoSerializer;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Address&gt; writerAddressMap;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;Long, List&lt;CommandInfoT&gt;&gt; commitInfoCache;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;Long, List&lt;AggregatedCommitInfoT&gt;&gt; checkpointCommitInfoMap;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Integer&gt; checkpointBarrierCounter;  </span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;Void&gt; completableFuture;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> MultiTableResourceManager resourceManager;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> receivedSinkWriter;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SinkAggregatedCommitterTask</span><span class="params">(  </span></span><br><span class="line"><span class="params">            <span class="type">long</span> jobID,  </span></span><br><span class="line"><span class="params">            TaskLocation taskID,  </span></span><br><span class="line"><span class="params">            SinkAction&lt;?, ?, CommandInfoT, AggregatedCommitInfoT&gt; sink,  </span></span><br><span class="line"><span class="params">            SinkAggregatedCommitter&lt;CommandInfoT, AggregatedCommitInfoT&gt; aggregatedCommitter)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(jobID, taskID);  </span><br><span class="line">        <span class="built_in">this</span>.sink = sink;  </span><br><span class="line">        <span class="built_in">this</span>.aggregatedCommitter = aggregatedCommitter;  </span><br><span class="line">        <span class="built_in">this</span>.maxWriterSize = sink.getParallelism();  </span><br><span class="line">        <span class="built_in">this</span>.receivedSinkWriter = <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员变量存储了<code>sink</code>的<code>action</code>，<code>committer</code>的实例引用。<br>使用几个容器存储<code>writer</code>的地址，<code>checkpoint id</code>与<code>commit</code>信息的映射等。</p>
<p>接下来再看下初始化方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="built_in">super</span>.init();  </span><br><span class="line">    currState = INIT;  </span><br><span class="line">    <span class="built_in">this</span>.checkpointBarrierCounter = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">    <span class="built_in">this</span>.commitInfoCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">    <span class="built_in">this</span>.writerAddressMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">    <span class="built_in">this</span>.checkpointCommitInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">    <span class="built_in">this</span>.completableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();  </span><br><span class="line">    <span class="built_in">this</span>.commitInfoSerializer = sink.getSink().getCommitInfoSerializer().get();  </span><br><span class="line">    <span class="built_in">this</span>.aggregatedCommitInfoSerializer =  </span><br><span class="line">            sink.getSink().getAggregatedCommitInfoSerializer().get();  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.aggregatedCommitter <span class="keyword">instanceof</span> SupportResourceShare) &#123;  </span><br><span class="line">        resourceManager =  </span><br><span class="line">                ((SupportResourceShare) <span class="built_in">this</span>.aggregatedCommitter)  </span><br><span class="line">                        .initMultiTableResourceManager(<span class="number">1</span>, <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    aggregatedCommitter.init();  </span><br><span class="line">    <span class="keyword">if</span> (resourceManager != <span class="literal">null</span>) &#123;  </span><br><span class="line">        ((SupportResourceShare) <span class="built_in">this</span>.aggregatedCommitter)  </span><br><span class="line">                .setMultiTableResourceManager(resourceManager, <span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    log.debug(  </span><br><span class="line">            <span class="string">&quot;starting seatunnel sink aggregated committer task, sink name[&#123;&#125;] &quot;</span>,  </span><br><span class="line">            sink.getName());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化时，会对几个容器进行初始化，将状态置为<code>INIT</code>状态，对<code>aggregatedCommitter</code>进行初始化。这里会<code>source split enumerator</code>不同，<code>sink committer</code>是通过构造方法在外部初始化完成后传递进来的。</p>
<ul>
<li>状态转换的方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">stateProcess</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">switch</span> (currState) &#123;  </span><br><span class="line">        <span class="keyword">case</span> INIT:  </span><br><span class="line">            currState = WAITING_RESTORE;  </span><br><span class="line">            reportTaskStatus(WAITING_RESTORE);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> WAITING_RESTORE:  </span><br><span class="line">            <span class="keyword">if</span> (restoreComplete.isDone()) &#123;  </span><br><span class="line">                currState = READY_START;  </span><br><span class="line">                reportTaskStatus(READY_START);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> READY_START:  </span><br><span class="line">            <span class="keyword">if</span> (startCalled) &#123;  </span><br><span class="line">                currState = STARTING;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> STARTING:  </span><br><span class="line">            <span class="keyword">if</span> (receivedSinkWriter) &#123;  </span><br><span class="line">                currState = RUNNING;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> RUNNING:  </span><br><span class="line">            <span class="keyword">if</span> (prepareCloseStatus) &#123;  </span><br><span class="line">                currState = PREPARE_CLOSE;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> PREPARE_CLOSE:  </span><br><span class="line">            <span class="keyword">if</span> (closeCalled) &#123;  </span><br><span class="line">                currState = CLOSED;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> CLOSED:  </span><br><span class="line">            <span class="built_in">this</span>.close();  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">            <span class="comment">// TODO support cancel by outside  </span></span><br><span class="line">        <span class="keyword">case</span> CANCELLING:  </span><br><span class="line">            <span class="built_in">this</span>.close();  </span><br><span class="line">            currState = CANCELED;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        <span class="keyword">default</span>:  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown Enumerator State: &quot;</span> + currState);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
这里的状态转换比较简单，基本上都是直接进入下一个状态，但是这里有一点与eunmerator不太一样，在source enumerator中，需要等待全部的reader都启动完成，才会切换到running状态，这里稍有不同，这里只要有一个writer注册就会将receivedSinkWriter置为true，从而可以切换到running状态。<blockquote>
<p>source eunmerator需要等待全部的reader节点才能启动是需要避免分配时，任务分配不均匀，早启动的任务分配了全部或者较多的任务。<br>而sink committer的任务则不一样，它是二次提交时使用，所以只要有一个writer启动，就有可能会有二次提交的任务产生，所以不需要等待全部writer启动。</p>
</blockquote>
</li>
</ul>
<p>这里的<code>RUNNING</code>状态到<code>PREPARE_CLOSE</code>状态的切换，会判断<code>prepareCloseStatus</code>是否为true，而这个变量只有在接收到任务结束的信号时才会被置为true，所以这个任务会在任务全部完成时才会被关闭。</p>
<p>现在就看完了数据拆分任务<code>SourceSplitEnumerator</code>以及数据提交任务<code>SinkAggregatedCommitter</code>的相关内容<br>接下来我们看下几个数据读取，写入。即reader，writer的相关任务执行过程。</p>
<h3 id="SourceSeaTunnelTask"><a href="#SourceSeaTunnelTask" class="headerlink" title="SourceSeaTunnelTask"></a>SourceSeaTunnelTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SourceSeaTunnelTask</span>&lt;T, SplitT <span class="keyword">extends</span> <span class="title class_">SourceSplit</span>&gt; <span class="keyword">extends</span> <span class="title class_">SeaTunnelTask</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ILogger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> Logger.getLogger(SourceSeaTunnelTask.class);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> SeaTunnelSourceCollector&lt;T&gt; collector;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object checkpointLock;  </span><br><span class="line">    <span class="meta">@Getter</span> <span class="keyword">private</span> <span class="keyword">transient</span> Serializer&lt;SplitT&gt; splitSerializer;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; envOption;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PhysicalExecutionFlow&lt;SourceAction, SourceConfig&gt; sourceFlow;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SourceSeaTunnelTask</span><span class="params">(  </span></span><br><span class="line"><span class="params">            <span class="type">long</span> jobID,  </span></span><br><span class="line"><span class="params">            TaskLocation taskID,  </span></span><br><span class="line"><span class="params">            <span class="type">int</span> indexID,  </span></span><br><span class="line"><span class="params">            PhysicalExecutionFlow&lt;SourceAction, SourceConfig&gt; executionFlow,  </span></span><br><span class="line"><span class="params">            Map&lt;String, Object&gt; envOption)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(jobID, taskID, indexID, executionFlow);  </span><br><span class="line">        <span class="built_in">this</span>.sourceFlow = executionFlow;  </span><br><span class="line">        <span class="built_in">this</span>.envOption = envOption;  </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SourceSeaTunnelTask</code>与<code>TransformSeaTunnelTask</code>都继承了<code>SeaTunnelTask</code>，这里的构造方法调用了父类的构造方法，这一部分我们统一在后面在看，先看下这个类中的其他方法。</p>
<ul>
<li>一些其他方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    ((SourceFlowLifeCycle&lt;T, SplitT&gt;) startFlowLifeCycle).collect();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@NonNull</span> <span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> ProgressState <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    stateProcess();  </span><br><span class="line">    <span class="keyword">return</span> progress.toState();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receivedSourceSplit</span><span class="params">(List&lt;SplitT&gt; splits)</span> &#123;  </span><br><span class="line">    ((SourceFlowLifeCycle&lt;T, SplitT&gt;) startFlowLifeCycle).receivedSplits(splits);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerBarrier</span><span class="params">(Barrier barrier)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    SourceFlowLifeCycle&lt;T, SplitT&gt; sourceFlow =  </span><br><span class="line">            (SourceFlowLifeCycle&lt;T, SplitT&gt;) startFlowLifeCycle;  </span><br><span class="line">    sourceFlow.triggerBarrier(barrier);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这几个方法中，都是将调用转给了<code>startFlowLifeCycle</code>去进行调用。</li>
</ul>
<p>在这个类中，还重新了父类的<code>createSourceFlowLifeCycle</code>方法，会去创建一个<code>SourceFlowLifeCycle</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> SourceFlowLifeCycle&lt;?, ?&gt; createSourceFlowLifeCycle(  </span><br><span class="line">        SourceAction&lt;?, ?, ?&gt; sourceAction,  </span><br><span class="line">        SourceConfig config,  </span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture,  </span><br><span class="line">        MetricsContext metricsContext) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SourceFlowLifeCycle</span>&lt;&gt;(  </span><br><span class="line">            sourceAction,  </span><br><span class="line">            indexID,  </span><br><span class="line">            config.getEnumeratorTask(),  </span><br><span class="line">            <span class="built_in">this</span>,  </span><br><span class="line">            taskLocation,  </span><br><span class="line">            completableFuture,  </span><br><span class="line">            metricsContext);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="built_in">super</span>.init();  </span><br><span class="line">    <span class="built_in">this</span>.checkpointLock = <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line">    <span class="built_in">this</span>.splitSerializer = sourceFlow.getAction().getSource().getSplitSerializer();  </span><br><span class="line">  </span><br><span class="line">    LOGGER.info(<span class="string">&quot;starting seatunnel source task, index &quot;</span> + indexID);  </span><br><span class="line">    <span class="keyword">if</span> (!(startFlowLifeCycle <span class="keyword">instanceof</span> SourceFlowLifeCycle)) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TaskRuntimeException</span>(  </span><br><span class="line">                <span class="string">&quot;SourceSeaTunnelTask only support SourceFlowLifeCycle, but get &quot;</span>  </span><br><span class="line">                        + startFlowLifeCycle.getClass().getName());  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        SeaTunnelDataType sourceProducedType;  </span><br><span class="line">        List&lt;TablePath&gt; tablePaths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            List&lt;CatalogTable&gt; producedCatalogTables =  </span><br><span class="line">                    sourceFlow.getAction().getSource().getProducedCatalogTables();  </span><br><span class="line">            sourceProducedType = CatalogTableUtil.convertToDataType(producedCatalogTables);  </span><br><span class="line">            tablePaths =  </span><br><span class="line">                    producedCatalogTables.stream()  </span><br><span class="line">                            .map(CatalogTable::getTableId)  </span><br><span class="line">                            .map(TableIdentifier::toTablePath)  </span><br><span class="line">                            .collect(Collectors.toList());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;  </span><br><span class="line">            <span class="comment">// TODO remove it when all connector use `getProducedCatalogTables`  </span></span><br><span class="line">            sourceProducedType = sourceFlow.getAction().getSource().getProducedType();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">this</span>.collector =  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SeaTunnelSourceCollector</span>&lt;&gt;(  </span><br><span class="line">                        checkpointLock,  </span><br><span class="line">                        outputs,  </span><br><span class="line">                        <span class="built_in">this</span>.getMetricsContext(),  </span><br><span class="line">                        FlowControlStrategy.fromMap(envOption),  </span><br><span class="line">                        sourceProducedType,  </span><br><span class="line">                        tablePaths);  </span><br><span class="line">        ((SourceFlowLifeCycle&lt;T, SplitT&gt;) startFlowLifeCycle).setCollector(collector);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
初始化方法也是先调用父类的初始化方法，一并放到后面再看。<br>其他的内容则是通过调用Source的API获取到所产生数据的表结构，数据类型，表路径信息等。<br>在这里还会初始化一个<code>SeaTunnelSourceCollector</code>，并赋值给<code>startFlowLifeCycle</code>.<br>我们看下这个类的相关代码</li>
</ul>
<h4 id="SeaTunnelSourceCollector"><a href="#SeaTunnelSourceCollector" class="headerlink" title="SeaTunnelSourceCollector"></a>SeaTunnelSourceCollector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeaTunnelSourceCollector</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Collector</span>&lt;T&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object checkpointLock;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OneInputFlowLifeCycle&lt;Record&lt;?&gt;&gt;&gt; outputs;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MetricsContext metricsContext;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">schemaChangeBeforeCheckpointSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">schemaChangeAfterCheckpointSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter sourceReceivedCount;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Counter&gt; sourceReceivedCountPerTable = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Meter sourceReceivedQPS;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter sourceReceivedBytes;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Meter sourceReceivedBytesPerSeconds;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> emptyThisPollNext;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">DataTypeChangeEventHandler</span> <span class="variable">dataTypeChangeEventHandler</span> <span class="operator">=</span>  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DataTypeChangeEventDispatcher</span>();  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, SeaTunnelRowType&gt; rowTypeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">private</span> SeaTunnelDataType rowType;  </span><br><span class="line">    <span class="keyword">private</span> FlowControlGate flowControlGate;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeaTunnelSourceCollector</span><span class="params">(  </span></span><br><span class="line"><span class="params">            Object checkpointLock,  </span></span><br><span class="line"><span class="params">            List&lt;OneInputFlowLifeCycle&lt;Record&lt;?&gt;&gt;&gt; outputs,  </span></span><br><span class="line"><span class="params">            MetricsContext metricsContext,  </span></span><br><span class="line"><span class="params">            FlowControlStrategy flowControlStrategy,  </span></span><br><span class="line"><span class="params">            SeaTunnelDataType rowType,  </span></span><br><span class="line"><span class="params">            List&lt;TablePath&gt; tablePaths)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.checkpointLock = checkpointLock;  </span><br><span class="line">        <span class="built_in">this</span>.outputs = outputs;  </span><br><span class="line">        <span class="built_in">this</span>.rowType = rowType;  </span><br><span class="line">        <span class="built_in">this</span>.metricsContext = metricsContext;  </span><br><span class="line">        <span class="keyword">if</span> (rowType <span class="keyword">instanceof</span> MultipleRowType) &#123;  </span><br><span class="line">            ((MultipleRowType) rowType)  </span><br><span class="line">                    .iterator()  </span><br><span class="line">                    .forEachRemaining(type -&gt; <span class="built_in">this</span>.rowTypeMap.put(type.getKey(), type.getValue()));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(tablePaths)) &#123;  </span><br><span class="line">            tablePaths.forEach(  </span><br><span class="line">                    tablePath -&gt;  </span><br><span class="line">                            sourceReceivedCountPerTable.put(  </span><br><span class="line">                                    getFullName(tablePath),  </span><br><span class="line">                                    metricsContext.counter(  </span><br><span class="line">                                            SOURCE_RECEIVED_COUNT + <span class="string">&quot;#&quot;</span> + getFullName(tablePath))));  </span><br><span class="line">        &#125;  </span><br><span class="line">        sourceReceivedCount = metricsContext.counter(SOURCE_RECEIVED_COUNT);  </span><br><span class="line">        sourceReceivedQPS = metricsContext.meter(SOURCE_RECEIVED_QPS);  </span><br><span class="line">        sourceReceivedBytes = metricsContext.counter(SOURCE_RECEIVED_BYTES);  </span><br><span class="line">        sourceReceivedBytesPerSeconds = metricsContext.meter(SOURCE_RECEIVED_BYTES_PER_SECONDS);  </span><br><span class="line">        flowControlGate = FlowControlGate.create(flowControlStrategy);  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>
<p>从变量可以看到这个类里面是实现了指标的统计，从<code>source</code>读到了多少数据，平均每秒读取的速度等都是在这个类中维护计算的。<br>还有记录了该任务下游的任务列表<code>List&lt;OneInputFlowLifeCycle&lt;Record&lt;?&gt;&gt;&gt; outputs</code></p>
<p>在构造方法中，则是一些指标的初始化。</p>
<p>再看下这个类中的关键方法: <code>collect</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(T row)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (row <span class="keyword">instanceof</span> SeaTunnelRow) &#123;  </span><br><span class="line">                <span class="type">String</span> <span class="variable">tableId</span> <span class="operator">=</span> ((SeaTunnelRow) row).getTableId();  </span><br><span class="line">                <span class="type">int</span> size;  </span><br><span class="line">                <span class="keyword">if</span> (rowType <span class="keyword">instanceof</span> SeaTunnelRowType) &#123;  </span><br><span class="line">                    size = ((SeaTunnelRow) row).getBytesSize((SeaTunnelRowType) rowType);  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowType <span class="keyword">instanceof</span> MultipleRowType) &#123;  </span><br><span class="line">                    size = ((SeaTunnelRow) row).getBytesSize(rowTypeMap.get(tableId));  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SeaTunnelEngineException</span>(  </span><br><span class="line">                            <span class="string">&quot;Unsupported row type: &quot;</span> + rowType.getClass().getName());  </span><br><span class="line">                &#125;  </span><br><span class="line">                sourceReceivedBytes.inc(size);  </span><br><span class="line">                sourceReceivedBytesPerSeconds.markEvent(size);  </span><br><span class="line">                flowControlGate.audit((SeaTunnelRow) row);  </span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotEmpty(tableId)) &#123;  </span><br><span class="line">                    <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> getFullName(TablePath.of(tableId));  </span><br><span class="line">                    <span class="type">Counter</span> <span class="variable">sourceTableCounter</span> <span class="operator">=</span> sourceReceivedCountPerTable.get(tableName);  </span><br><span class="line">                    <span class="keyword">if</span> (Objects.nonNull(sourceTableCounter)) &#123;  </span><br><span class="line">                        sourceTableCounter.inc();  </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span>  </span><br><span class="line">                                metricsContext.counter(SOURCE_RECEIVED_COUNT + <span class="string">&quot;#&quot;</span> + tableName);  </span><br><span class="line">                        counter.inc();  </span><br><span class="line">                        sourceReceivedCountPerTable.put(tableName, counter);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sendRecordToNext(<span class="keyword">new</span> <span class="title class_">Record</span>&lt;&gt;(row));  </span><br><span class="line">            emptyThisPollNext = <span class="literal">false</span>;  </span><br><span class="line">            sourceReceivedCount.inc();  </span><br><span class="line">            sourceReceivedQPS.markEvent();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(SchemaChangeEvent event)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (rowType <span class="keyword">instanceof</span> SeaTunnelRowType) &#123;  </span><br><span class="line">                rowType = dataTypeChangeEventHandler.reset((SeaTunnelRowType) rowType).apply(event);  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowType <span class="keyword">instanceof</span> MultipleRowType) &#123;  </span><br><span class="line">                <span class="type">String</span> <span class="variable">tableId</span> <span class="operator">=</span> event.tablePath().toString();  </span><br><span class="line">                rowTypeMap.put(  </span><br><span class="line">                        tableId,  </span><br><span class="line">                        dataTypeChangeEventHandler.reset(rowTypeMap.get(tableId)).apply(event));  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SeaTunnelEngineException</span>(  </span><br><span class="line">                        <span class="string">&quot;Unsupported row type: &quot;</span> + rowType.getClass().getName());  </span><br><span class="line">            &#125;  </span><br><span class="line">            sendRecordToNext(<span class="keyword">new</span> <span class="title class_">Record</span>&lt;&gt;(event));  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个类中有两个<code>collect</code>方法，一个是接收数据，一个是接收表结构变更事件。<br>对于接收数据方法，当数据是读取到的数据<code>SeaTunnelRow</code>时，则会进行一些指标计算，更新。然后调用<code>sendRecordToNext</code>方法，将数据封装为Record发送给下游。</p>
<p>对于表结构变更方法，则是先将内部存储的表结构信息进行更新，然后再同样是调用<code>sendRecordToNext</code>方法发送给下游.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRecordToNext</span><span class="params">(Record&lt;?&gt; record)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (checkpointLock) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (OneInputFlowLifeCycle&lt;Record&lt;?&gt;&gt; output : outputs) &#123;  </span><br><span class="line">            output.received(record);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，则是将数据发送给全部的下游任务。这里如何获取的下游任务是在父类中获取的，这一部分后面在<code>SeaTunnelTask</code>中再继续介绍。</p>
<p>可以看出这个<code>SeaTunnelSourceCollector</code>会被传递给<code>reader</code>实例，reader读取到数据转换完成之后，再由这个类进行指标统计后发送给所有的下游任务。</p>
<h3 id="TransformSeaTunnelTask"><a href="#TransformSeaTunnelTask" class="headerlink" title="TransformSeaTunnelTask"></a>TransformSeaTunnelTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformSeaTunnelTask</span> <span class="keyword">extends</span> <span class="title class_">SeaTunnelTask</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ILogger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> Logger.getLogger(TransformSeaTunnelTask.class);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TransformSeaTunnelTask</span><span class="params">(  </span></span><br><span class="line"><span class="params">            <span class="type">long</span> jobID, TaskLocation taskID, <span class="type">int</span> indexID, Flow executionFlow)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(jobID, taskID, indexID, executionFlow);  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Collector&lt;Record&lt;?&gt;&gt; collector;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="built_in">super</span>.init();  </span><br><span class="line">        LOGGER.info(<span class="string">&quot;starting seatunnel transform task, index &quot;</span> + indexID);  </span><br><span class="line">        collector = <span class="keyword">new</span> <span class="title class_">SeaTunnelTransformCollector</span>(outputs);  </span><br><span class="line">        <span class="keyword">if</span> (!(startFlowLifeCycle <span class="keyword">instanceof</span> OneOutputFlowLifeCycle)) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TaskRuntimeException</span>(  </span><br><span class="line">                    <span class="string">&quot;TransformSeaTunnelTask only support OneOutputFlowLifeCycle, but get &quot;</span>  </span><br><span class="line">                            + startFlowLifeCycle.getClass().getName());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> SourceFlowLifeCycle&lt;?, ?&gt; createSourceFlowLifeCycle(  </span><br><span class="line">            SourceAction&lt;?, ?, ?&gt; sourceAction,  </span><br><span class="line">            SourceConfig config,  </span><br><span class="line">            CompletableFuture&lt;Void&gt; completableFuture,  </span><br><span class="line">            MetricsContext metricsContext) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(  </span><br><span class="line">                <span class="string">&quot;TransformSeaTunnelTask can&#x27;t create SourceFlowLifeCycle&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        ((OneOutputFlowLifeCycle&lt;Record&lt;?&gt;&gt;) startFlowLifeCycle).collect(collector);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@NonNull</span> <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> ProgressState <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        stateProcess();  </span><br><span class="line">        <span class="keyword">return</span> progress.toState();  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类相比较于<code>SourceSeaTunnelTask</code>则比较简单，在初始化时会创建一个<code>SeaTunnelTransformCollector</code>，当调用<code>collect</code>方法时也是转交给<code>startFlowLifeCycle</code>执行</p>
<h4 id="SeaTunnelTransformCollector"><a href="#SeaTunnelTransformCollector" class="headerlink" title="SeaTunnelTransformCollector"></a>SeaTunnelTransformCollector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeaTunnelTransformCollector</span> <span class="keyword">implements</span> <span class="title class_">Collector</span>&lt;Record&lt;?&gt;&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OneInputFlowLifeCycle&lt;Record&lt;?&gt;&gt;&gt; outputs;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeaTunnelTransformCollector</span><span class="params">(List&lt;OneInputFlowLifeCycle&lt;Record&lt;?&gt;&gt;&gt; outputs)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.outputs = outputs;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(Record&lt;?&gt; record)</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (OneInputFlowLifeCycle&lt;Record&lt;?&gt;&gt; output : outputs) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                output.received(record);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TaskRuntimeException</span>(e);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SeaTunnelTransformCollector</code>的内容也很简单，收到数据后将数据转发给所有的下游任务。</p>
<p>好了，接下来我们看下<code>SeaTunnelTask</code>的相关内容</p>
<h3 id="SeaTunnelTask"><a href="#SeaTunnelTask" class="headerlink" title="SeaTunnelTask"></a>SeaTunnelTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SeaTunnelTask</span> <span class="keyword">extends</span> <span class="title class_">AbstractTask</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2604309561613784425L</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> SeaTunnelTaskState currState;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Flow executionFlow;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> FlowLifeCycle startFlowLifeCycle;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> List&lt;FlowLifeCycle&gt; allCycles;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> List&lt;OneInputFlowLifeCycle&lt;Record&lt;?&gt;&gt;&gt; outputs;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> List&lt;CompletableFuture&lt;Void&gt;&gt; flowFutures;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;Long, List&lt;ActionSubtaskState&gt;&gt; checkpointStates =  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, Integer&gt; cycleAcks = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> indexID;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> TaskGroup taskBelongGroup;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> SeaTunnelMetricsContext metricsContext;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeaTunnelTask</span><span class="params">(<span class="type">long</span> jobID, TaskLocation taskID, <span class="type">int</span> indexID, Flow executionFlow)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(jobID, taskID);  </span><br><span class="line">        <span class="built_in">this</span>.indexID = indexID;  </span><br><span class="line">        <span class="built_in">this</span>.executionFlow = executionFlow;  </span><br><span class="line">        <span class="built_in">this</span>.currState = SeaTunnelTaskState.CREATED;  </span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>SeaTunnelTask</code>中，<code>executionFlow</code>就表示一个物理执行节点，是在<code>PhysicalPlanGenerator</code>中产生传递过来的。这里需要与执行计划图一起对比看下。<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081515868.png" alt="image.png"></p>
<p>在构造方法中没有做太多的事情，仅仅是将变量赋值，将状态初始化为<code>CREATED</code>状态。<br>看下其他的方法</p>
<ul>
<li>init<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="built_in">super</span>.init();  </span><br><span class="line">    metricsContext = getExecutionContext().getOrCreateMetricsContext(taskLocation);  </span><br><span class="line">    <span class="built_in">this</span>.currState = SeaTunnelTaskState.INIT;  </span><br><span class="line">    flowFutures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    allCycles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    startFlowLifeCycle = convertFlowToActionLifeCycle(executionFlow);  </span><br><span class="line">    <span class="keyword">for</span> (FlowLifeCycle cycle : allCycles) &#123;  </span><br><span class="line">        cycle.init();  </span><br><span class="line">    &#125;  </span><br><span class="line">    CompletableFuture.allOf(flowFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]))  </span><br><span class="line">            .whenComplete((s, e) -&gt; closeCalled = <span class="literal">true</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
初始化方法内，调用了<code>convertFlowToActionLifeCycle</code>方法来获取当前任务的开始任务的lifecycle对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> FlowLifeCycle <span class="title function_">convertFlowToActionLifeCycle</span><span class="params">(<span class="meta">@NonNull</span> Flow flow)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">    FlowLifeCycle lifeCycle;  </span><br><span class="line">    <span class="comment">// 局部变量存储当前节点的所有下游节点的lifecycle对象</span></span><br><span class="line">    List&lt;OneInputFlowLifeCycle&lt;Record&lt;?&gt;&gt;&gt; flowLifeCycles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (!flow.getNext().isEmpty()) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (Flow f : flow.getNext()) &#123;  </span><br><span class="line">            flowLifeCycles.add(  </span><br><span class="line">            <span class="comment">// 递归调用 将所有节点都进行转换</span></span><br><span class="line">                    (OneInputFlowLifeCycle&lt;Record&lt;?&gt;&gt;) convertFlowToActionLifeCycle(f));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 加到全部变量中  </span></span><br><span class="line">    flowFutures.add(completableFuture);  </span><br><span class="line">    <span class="keyword">if</span> (flow <span class="keyword">instanceof</span> PhysicalExecutionFlow) &#123;  </span><br><span class="line">        <span class="type">PhysicalExecutionFlow</span> <span class="variable">f</span> <span class="operator">=</span> (PhysicalExecutionFlow) flow; </span><br><span class="line">        <span class="comment">// 根据不同的action类型创建不同的 FlowLifecycle </span></span><br><span class="line">        <span class="keyword">if</span> (f.getAction() <span class="keyword">instanceof</span> SourceAction) &#123;  </span><br><span class="line">            lifeCycle =  </span><br><span class="line">                    createSourceFlowLifeCycle(  </span><br><span class="line">                            (SourceAction&lt;?, ?, ?&gt;) f.getAction(),  </span><br><span class="line">                            (SourceConfig) f.getConfig(),  </span><br><span class="line">                            completableFuture,  </span><br><span class="line">                            <span class="built_in">this</span>.getMetricsContext());  </span><br><span class="line">            <span class="comment">// 当前节点的下游输出已经存储在 flowLifeCycles中了，赋值</span></span><br><span class="line">            outputs = flowLifeCycles;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.getAction() <span class="keyword">instanceof</span> SinkAction) &#123;  </span><br><span class="line">            lifeCycle =  </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">SinkFlowLifeCycle</span>&lt;&gt;(  </span><br><span class="line">                            (SinkAction) f.getAction(),  </span><br><span class="line">                            taskLocation,  </span><br><span class="line">                            indexID,  </span><br><span class="line">                            <span class="built_in">this</span>,  </span><br><span class="line">                            ((SinkConfig) f.getConfig()).getCommitterTask(),  </span><br><span class="line">                            ((SinkConfig) f.getConfig()).isContainCommitter(),  </span><br><span class="line">                            completableFuture,  </span><br><span class="line">                            <span class="built_in">this</span>.getMetricsContext());  </span><br><span class="line">			<span class="comment">// sink已经是最后的节点，所以不需要设置outputs                            </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.getAction() <span class="keyword">instanceof</span> TransformChainAction) &#123;  </span><br><span class="line">	        <span class="comment">// 对于transform，outputs通过在构造`SeaTunnelTransformCollector`时通过参数传递进入</span></span><br><span class="line">            lifeCycle =  </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">TransformFlowLifeCycle</span>&lt;SeaTunnelRow&gt;(  </span><br><span class="line">                            (TransformChainAction) f.getAction(),  </span><br><span class="line">                            <span class="built_in">this</span>,  </span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">SeaTunnelTransformCollector</span>(flowLifeCycles),  </span><br><span class="line">                            completableFuture);  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.getAction() <span class="keyword">instanceof</span> ShuffleAction) &#123;  </span><br><span class="line">            <span class="type">ShuffleAction</span> <span class="variable">shuffleAction</span> <span class="operator">=</span> (ShuffleAction) f.getAction();  </span><br><span class="line">            <span class="type">HazelcastInstance</span> <span class="variable">hazelcastInstance</span> <span class="operator">=</span> getExecutionContext().getInstance();  </span><br><span class="line">            <span class="keyword">if</span> (flow.getNext().isEmpty()) &#123;  </span><br><span class="line">                lifeCycle =  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ShuffleSinkFlowLifeCycle</span>(  </span><br><span class="line">                                <span class="built_in">this</span>,  </span><br><span class="line">                                indexID,  </span><br><span class="line">                                shuffleAction,  </span><br><span class="line">                                hazelcastInstance,  </span><br><span class="line">                                completableFuture);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                lifeCycle =  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ShuffleSourceFlowLifeCycle</span>(  </span><br><span class="line">                                <span class="built_in">this</span>,  </span><br><span class="line">                                indexID,  </span><br><span class="line">                                shuffleAction,  </span><br><span class="line">                                hazelcastInstance,  </span><br><span class="line">                                completableFuture);  </span><br><span class="line">            &#125;  </span><br><span class="line">            outputs = flowLifeCycles;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownActionException</span>(f.getAction());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flow <span class="keyword">instanceof</span> IntermediateExecutionFlow) &#123;  </span><br><span class="line">        <span class="type">IntermediateQueueConfig</span> <span class="variable">config</span> <span class="operator">=</span>  </span><br><span class="line">                ((IntermediateExecutionFlow&lt;IntermediateQueueConfig&gt;) flow).getConfig();  </span><br><span class="line">        lifeCycle =  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">IntermediateQueueFlowLifeCycle</span>(  </span><br><span class="line">                        <span class="built_in">this</span>,  </span><br><span class="line">                        completableFuture,  </span><br><span class="line">                        ((AbstractTaskGroupWithIntermediateQueue) taskBelongGroup)  </span><br><span class="line">                                .getQueueCache(config.getQueueID()));  </span><br><span class="line">        outputs = flowLifeCycles;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownFlowException</span>(flow);  </span><br><span class="line">    &#125;  </span><br><span class="line">    allCycles.add(lifeCycle);  </span><br><span class="line">    <span class="keyword">return</span> lifeCycle;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在这个方法中，对一个物理执行节点进行遍历，对每一个下游任务都进行转换，转换为对于的<code>FlowLifecycle</code>，然后将其添加到全部变量<code>allCycles</code>中。<br>在转换<code>FlowLifecycle</code> 时，会根据不同的类型进行相应的转换。并且在每次转换时，都可以获取到当前节点的下游所有节点的LifeCycle，可以将其设置到output中，从而在<code>Collector</code>中发送的时候可以知道下游的信息。<br>这里的<code>PhysicalExecutionFlow</code>与<code>IntermediateExecutionFlow</code>区别我们先不关心，我们先认为都只有<code>PhysicalExecutionFlow</code>。</li>
</ul>
<p>回到<code>init</code>方法，当全部转换完成后，会对所有的<code>FlowLifecycle</code>调用初始化方法进行初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="built_in">super</span>.init();  </span><br><span class="line">    metricsContext = getExecutionContext().getOrCreateMetricsContext(taskLocation);  </span><br><span class="line">    <span class="built_in">this</span>.currState = SeaTunnelTaskState.INIT;  </span><br><span class="line">    flowFutures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    allCycles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    startFlowLifeCycle = convertFlowToActionLifeCycle(executionFlow);  </span><br><span class="line">    <span class="keyword">for</span> (FlowLifeCycle cycle : allCycles) &#123;  </span><br><span class="line">        cycle.init();  </span><br><span class="line">    &#125;  </span><br><span class="line">    CompletableFuture.allOf(flowFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]))  </span><br><span class="line">            .whenComplete((s, e) -&gt; closeCalled = <span class="literal">true</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对其中提到的几个<code>FlowLifyCycle</code>看下源码</p>
<h4 id="SourceFlowLifeCycle"><a href="#SourceFlowLifeCycle" class="headerlink" title="SourceFlowLifeCycle"></a>SourceFlowLifeCycle</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SourceFlowLifeCycle</span>&lt;T, SplitT <span class="keyword">extends</span> <span class="title class_">SourceSplit</span>&gt; <span class="keyword">extends</span> <span class="title class_">ActionFlowLifeCycle</span>  </span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">InternalCheckpointListener</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SourceAction&lt;T, SplitT, ?&gt; sourceAction;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskLocation enumeratorTaskLocation;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Address enumeratorTaskAddress;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> SourceReader&lt;T, SplitT&gt; reader;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Serializer&lt;SplitT&gt; splitSerializer;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> indexID;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskLocation currentTaskLocation;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> SeaTunnelSourceCollector&lt;T&gt; collector;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MetricsContext metricsContext;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener eventListener;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;SchemaChangePhase&gt; schemaChangePhase = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SourceFlowLifeCycle</span><span class="params">(  </span></span><br><span class="line"><span class="params">            SourceAction&lt;T, SplitT, ?&gt; sourceAction,  </span></span><br><span class="line"><span class="params">            <span class="type">int</span> indexID,  </span></span><br><span class="line"><span class="params">            TaskLocation enumeratorTaskLocation,  </span></span><br><span class="line"><span class="params">            SeaTunnelTask runningTask,  </span></span><br><span class="line"><span class="params">            TaskLocation currentTaskLocation,  </span></span><br><span class="line"><span class="params">            CompletableFuture&lt;Void&gt; completableFuture,  </span></span><br><span class="line"><span class="params">            MetricsContext metricsContext)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(sourceAction, runningTask, completableFuture);  </span><br><span class="line">        <span class="built_in">this</span>.sourceAction = sourceAction;  </span><br><span class="line">        <span class="built_in">this</span>.indexID = indexID;  </span><br><span class="line">        <span class="built_in">this</span>.enumeratorTaskLocation = enumeratorTaskLocation;  </span><br><span class="line">        <span class="built_in">this</span>.currentTaskLocation = currentTaskLocation;  </span><br><span class="line">        <span class="built_in">this</span>.metricsContext = metricsContext;  </span><br><span class="line">        <span class="built_in">this</span>.eventListener =  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">JobEventListener</span>(currentTaskLocation, runningTask.getExecutionContext());  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个类的几个成员变量有<code>source enumerator</code>的地址，用来<code>reader</code>与<code>enumerator</code>进行通信交互，还有<code>SourceReader</code>的实例，在这个类里去创建<code>reader</code>并进行实际的读取。</p>
<p>再来看下其他的方法：</p>
<ul>
<li><p>初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="built_in">this</span>.splitSerializer = sourceAction.getSource().getSplitSerializer();  </span><br><span class="line">    <span class="built_in">this</span>.reader =  </span><br><span class="line">            sourceAction  </span><br><span class="line">                    .getSource()  </span><br><span class="line">                    .createReader(  </span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">SourceReaderContext</span>(  </span><br><span class="line">                                    indexID,  </span><br><span class="line">                                    sourceAction.getSource().getBoundedness(),  </span><br><span class="line">                                    <span class="built_in">this</span>,  </span><br><span class="line">                                    metricsContext,  </span><br><span class="line">                                    eventListener));  </span><br><span class="line">    <span class="built_in">this</span>.enumeratorTaskAddress = getEnumeratorTaskAddress();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>初始化时会去创建<code>reader</code>实例，创建时会将自身作为参数设置到<code>context</code>中。还要去获取切分任务的地址，后续的通信需要这个地址。</p>
</li>
<li><p>collect方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!prepareClose) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (schemaChanging()) &#123;  </span><br><span class="line">            log.debug(<span class="string">&quot;schema is changing, stop reader collect records&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">            Thread.sleep(<span class="number">200</span>);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        reader.pollNext(collector);  </span><br><span class="line">        <span class="keyword">if</span> (collector.isEmptyThisPollNext()) &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            collector.resetEmptyThisPollNext();            </span><br><span class="line">             Thread.sleep(<span class="number">0L</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (collector.captureSchemaChangeBeforeCheckpointSignal()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (schemaChangePhase.get() != <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(  </span><br><span class="line">                        <span class="string">&quot;previous schema changes in progress, schemaChangePhase: &quot;</span>  </span><br><span class="line">                                + schemaChangePhase.get());  </span><br><span class="line">            &#125;  </span><br><span class="line">            schemaChangePhase.set(SchemaChangePhase.createBeforePhase());  </span><br><span class="line">            runningTask.triggerSchemaChangeBeforeCheckpoint().get();  </span><br><span class="line">            log.info(<span class="string">&quot;triggered schema-change-before checkpoint, stopping collect data&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collector.captureSchemaChangeAfterCheckpointSignal()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (schemaChangePhase.get() != <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(  </span><br><span class="line">                        <span class="string">&quot;previous schema changes in progress, schemaChangePhase: &quot;</span>  </span><br><span class="line">                                + schemaChangePhase.get());  </span><br><span class="line">            &#125;  </span><br><span class="line">            schemaChangePhase.set(SchemaChangePhase.createAfterPhase());  </span><br><span class="line">            runningTask.triggerSchemaChangeAfterCheckpoint().get();  </span><br><span class="line">            log.info(<span class="string">&quot;triggered schema-change-after checkpoint, stopping collect data&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用collect方法时，会调用reader的<code>pollNext</code>方法来进行真正的数据读取。<br>当reader的pollNext方法被调用时，reader会真正的从数据源进行读取数据，转换成内部的<code>SeaTunnelRow</code>数据类型，放到<code>collector</code>中。<br>而这个<code>collector</code>就是我们上面刚刚看的<code>SeaTunnelSourceCollector</code>， 当它接收到一条数据后，又会将数据发送给所有的下游任务。</p>
</li>
<li><p>一些其他方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    reader.open();  </span><br><span class="line">    <span class="comment">// 在open方法里，会将自己向enumerator进行注册</span></span><br><span class="line">    register();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        runningTask  </span><br><span class="line">                .getExecutionContext()  </span><br><span class="line">                .sendToMember(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">SourceRegisterOperation</span>(  </span><br><span class="line">                                currentTaskLocation, enumeratorTaskLocation),  </span><br><span class="line">                        enumeratorTaskAddress)  </span><br><span class="line">                .get();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;  </span><br><span class="line">        log.warn(<span class="string">&quot;source register failed.&quot;</span>, e);  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    reader.close();  </span><br><span class="line">    <span class="built_in">super</span>.close();  </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当reader读取完全部数据后，会调用此方法</span></span><br><span class="line"><span class="comment">// 此方法会向enumerator发送消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signalNoMoreElement</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="comment">// ready close this reader  </span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.prepareClose = <span class="literal">true</span>;  </span><br><span class="line">        runningTask  </span><br><span class="line">                .getExecutionContext()  </span><br><span class="line">                .sendToMember(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">SourceNoMoreElementOperation</span>(  </span><br><span class="line">                                currentTaskLocation, enumeratorTaskLocation),  </span><br><span class="line">                        enumeratorTaskAddress)  </span><br><span class="line">                .get();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        log.warn(<span class="string">&quot;source close failed &#123;&#125;&quot;</span>, e);  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestSplit</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        runningTask  </span><br><span class="line">                .getExecutionContext()  </span><br><span class="line">                .sendToMember(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">RequestSplitOperation</span>(currentTaskLocation, enumeratorTaskLocation),  </span><br><span class="line">                        enumeratorTaskAddress)  </span><br><span class="line">                .get();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;  </span><br><span class="line">        log.warn(<span class="string">&quot;source request split failed.&quot;</span>, e);  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSourceEventToEnumerator</span><span class="params">(SourceEvent sourceEvent)</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        runningTask  </span><br><span class="line">                .getExecutionContext()  </span><br><span class="line">                .sendToMember(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">SourceReaderEventOperation</span>(  </span><br><span class="line">                                enumeratorTaskLocation, currentTaskLocation, sourceEvent),  </span><br><span class="line">                        enumeratorTaskAddress)  </span><br><span class="line">                .get();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;  </span><br><span class="line">        log.warn(<span class="string">&quot;source request split failed.&quot;</span>, e);  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receivedSplits</span><span class="params">(List&lt;SplitT&gt; splits)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (splits.isEmpty()) &#123;  </span><br><span class="line">        reader.handleNoMoreSplits();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        reader.addSplits(splits);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="TransformFlowLifeCycle"><a href="#TransformFlowLifeCycle" class="headerlink" title="TransformFlowLifeCycle"></a>TransformFlowLifeCycle</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformFlowLifeCycle</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ActionFlowLifeCycle</span>  </span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">OneInputFlowLifeCycle</span>&lt;Record&lt;?&gt;&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransformChainAction&lt;T&gt; action;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SeaTunnelTransform&lt;T&gt;&gt; transform;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collector&lt;Record&lt;?&gt;&gt; collector;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TransformFlowLifeCycle</span><span class="params">(  </span></span><br><span class="line"><span class="params">            TransformChainAction&lt;T&gt; action,  </span></span><br><span class="line"><span class="params">            SeaTunnelTask runningTask,  </span></span><br><span class="line"><span class="params">            Collector&lt;Record&lt;?&gt;&gt; collector,  </span></span><br><span class="line"><span class="params">            CompletableFuture&lt;Void&gt; completableFuture)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(action, runningTask, completableFuture);  </span><br><span class="line">        <span class="built_in">this</span>.action = action;  </span><br><span class="line">        <span class="built_in">this</span>.transform = action.getTransforms();  </span><br><span class="line">        <span class="built_in">this</span>.collector = collector;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="built_in">super</span>.open();  </span><br><span class="line">        <span class="keyword">for</span> (SeaTunnelTransform&lt;T&gt; t : transform) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                t.open();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                log.error(  </span><br><span class="line">                        <span class="string">&quot;Open transform: &#123;&#125; failed, cause: &#123;&#125;&quot;</span>,  </span><br><span class="line">                        t.getPluginName(),  </span><br><span class="line">                        e.getMessage(),  </span><br><span class="line">                        e);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">received</span><span class="params">(Record&lt;?&gt; record)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (record.getData() <span class="keyword">instanceof</span> Barrier) &#123;  </span><br><span class="line">            <span class="type">CheckpointBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> (CheckpointBarrier) record.getData();  </span><br><span class="line">            <span class="keyword">if</span> (barrier.prepareClose(<span class="built_in">this</span>.runningTask.getTaskLocation())) &#123;  </span><br><span class="line">                prepareClose = <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (barrier.snapshot()) &#123;  </span><br><span class="line">                runningTask.addState(barrier, ActionStateKey.of(action), Collections.emptyList());  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// ack after #addState  </span></span><br><span class="line">            runningTask.ack(barrier);  </span><br><span class="line">            collector.collect(record);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (prepareClose) &#123;  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="type">T</span> <span class="variable">inputData</span> <span class="operator">=</span> (T) record.getData();  </span><br><span class="line">            <span class="type">T</span> <span class="variable">outputData</span> <span class="operator">=</span> inputData;  </span><br><span class="line">            <span class="keyword">for</span> (SeaTunnelTransform&lt;T&gt; t : transform) &#123;  </span><br><span class="line">                outputData = t.map(inputData);  </span><br><span class="line">                log.debug(<span class="string">&quot;Transform[&#123;&#125;] input row &#123;&#125; and output row &#123;&#125;&quot;</span>, t, inputData, outputData);  </span><br><span class="line">                <span class="keyword">if</span> (outputData == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    log.trace(<span class="string">&quot;Transform[&#123;&#125;] filtered data row &#123;&#125;&quot;</span>, t, inputData);  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                inputData = outputData;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (outputData != <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// todo log metrics  </span></span><br><span class="line">                collector.collect(<span class="keyword">new</span> <span class="title class_">Record</span>&lt;&gt;(outputData));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>TransformFlowLifeCycle</code>中，存储了所需要用到的<code>SeaTunnelTransform</code>，当被调用<code>open</code>方法时，会调用具体使用到的<code>transform</code>实现的<code>open</code>方法，由该实现进行相关的一些初始化操作。<br>当接收到数据后，会调用<code>Transform</code>接口的<code>map</code>方法，对数据进行处理，处理完成后，会判断是否会被过滤掉，如果没有被过滤（数据不为null）则会发送给下游。</p>
<h4 id="SinkFlowLifeCycle"><a href="#SinkFlowLifeCycle" class="headerlink" title="SinkFlowLifeCycle"></a>SinkFlowLifeCycle</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinkFlowLifeCycle</span>&lt;T, CommitInfoT <span class="keyword">extends</span> <span class="title class_">Serializable</span>, AggregatedCommitInfoT, StateT&gt;  </span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">ActionFlowLifeCycle</span>  </span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">OneInputFlowLifeCycle</span>&lt;Record&lt;?&gt;&gt;, InternalCheckpointListener &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SinkAction&lt;T, StateT, CommitInfoT, AggregatedCommitInfoT&gt; sinkAction;  </span><br><span class="line">    <span class="keyword">private</span> SinkWriter&lt;T, CommitInfoT, StateT&gt; writer;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Optional&lt;Serializer&lt;CommitInfoT&gt;&gt; commitInfoSerializer;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Optional&lt;Serializer&lt;StateT&gt;&gt; writerStateSerializer;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> indexID;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskLocation taskLocation;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Address committerTaskAddress;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskLocation committerTaskLocation;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Optional&lt;SinkCommitter&lt;CommitInfoT&gt;&gt; committer;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Optional&lt;CommitInfoT&gt; lastCommitInfo;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> MetricsContext metricsContext;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Counter sinkWriteCount;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Counter&gt; sinkWriteCountPerTable = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Meter sinkWriteQPS;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Counter sinkWriteBytes;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Meter sinkWriteBytesPerSeconds;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> containAggCommitter;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> MultiTableResourceManager resourceManager;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> EventListener eventListener;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SinkFlowLifeCycle</span><span class="params">(  </span></span><br><span class="line"><span class="params">            SinkAction&lt;T, StateT, CommitInfoT, AggregatedCommitInfoT&gt; sinkAction,  </span></span><br><span class="line"><span class="params">            TaskLocation taskLocation,  </span></span><br><span class="line"><span class="params">            <span class="type">int</span> indexID,  </span></span><br><span class="line"><span class="params">            SeaTunnelTask runningTask,  </span></span><br><span class="line"><span class="params">            TaskLocation committerTaskLocation,  </span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> containAggCommitter,  </span></span><br><span class="line"><span class="params">            CompletableFuture&lt;Void&gt; completableFuture,  </span></span><br><span class="line"><span class="params">            MetricsContext metricsContext)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(sinkAction, runningTask, completableFuture);  </span><br><span class="line">        <span class="built_in">this</span>.sinkAction = sinkAction;  </span><br><span class="line">        <span class="built_in">this</span>.indexID = indexID;  </span><br><span class="line">        <span class="built_in">this</span>.taskLocation = taskLocation;  </span><br><span class="line">        <span class="built_in">this</span>.committerTaskLocation = committerTaskLocation;  </span><br><span class="line">        <span class="built_in">this</span>.containAggCommitter = containAggCommitter;  </span><br><span class="line">        <span class="built_in">this</span>.metricsContext = metricsContext;  </span><br><span class="line">        <span class="built_in">this</span>.eventListener = <span class="keyword">new</span> <span class="title class_">JobEventListener</span>(taskLocation, runningTask.getExecutionContext());  </span><br><span class="line">        sinkWriteCount = metricsContext.counter(SINK_WRITE_COUNT);  </span><br><span class="line">        sinkWriteQPS = metricsContext.meter(SINK_WRITE_QPS);  </span><br><span class="line">        sinkWriteBytes = metricsContext.counter(SINK_WRITE_BYTES);  </span><br><span class="line">        sinkWriteBytesPerSeconds = metricsContext.meter(SINK_WRITE_BYTES_PER_SECONDS);  </span><br><span class="line">        <span class="keyword">if</span> (sinkAction.getSink() <span class="keyword">instanceof</span> MultiTableSink) &#123;  </span><br><span class="line">            List&lt;TablePath&gt; sinkTables = ((MultiTableSink) sinkAction.getSink()).getSinkTables();  </span><br><span class="line">            sinkTables.forEach(  </span><br><span class="line">                    tablePath -&gt;  </span><br><span class="line">                            sinkWriteCountPerTable.put(  </span><br><span class="line">                                    getFullName(tablePath),  </span><br><span class="line">                                    metricsContext.counter(  </span><br><span class="line">                                            SINK_WRITE_COUNT + <span class="string">&quot;#&quot;</span> + getFullName(tablePath))));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>SourceFlowLifeCycle</code>类似，这个<code>SinkFlowLifeCycle</code>中维护了<code>SinkWriter</code>的实例，当接收到一条数据后，会交给<code>writer</code>的具体实现来进行真正的数据写入。<br>同时在这个类中维护了一些指标数据，会进行写入数据，每个表写入数据等指标的统计。</p>
<p>接下来看下其他的一些方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="built_in">this</span>.commitInfoSerializer = sinkAction.getSink().getCommitInfoSerializer();  </span><br><span class="line">    <span class="built_in">this</span>.writerStateSerializer = sinkAction.getSink().getWriterStateSerializer();  </span><br><span class="line">    <span class="built_in">this</span>.committer = sinkAction.getSink().createCommitter();  </span><br><span class="line">    <span class="built_in">this</span>.lastCommitInfo = Optional.empty();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="built_in">super</span>.open();  </span><br><span class="line">    <span class="keyword">if</span> (containAggCommitter) &#123;  </span><br><span class="line">        committerTaskAddress = getCommitterTaskAddress();  </span><br><span class="line">    &#125;  </span><br><span class="line">    registerCommitter();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerCommitter</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (containAggCommitter) &#123;  </span><br><span class="line">        runningTask  </span><br><span class="line">                .getExecutionContext()  </span><br><span class="line">                .sendToMember(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">SinkRegisterOperation</span>(taskLocation, committerTaskLocation),  </span><br><span class="line">                        committerTaskAddress)  </span><br><span class="line">                .join();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化方法中，会创建<code>committer</code>，通过API可以知道，<code>committer</code>并不是一定需要的，所以这里的值也有可能为空，在open方法中当存在committer时，会获取地址然后进行注册。</p>
<p>这里有一点与<code>SourceFlowLifeCycle</code>不同的点是, <code>SourceReader</code>的创建是在<code>init</code>方法中去创建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="built_in">this</span>.splitSerializer = sourceAction.getSource().getSplitSerializer();  </span><br><span class="line">    <span class="built_in">this</span>.reader =  </span><br><span class="line">            sourceAction  </span><br><span class="line">                    .getSource()  </span><br><span class="line">                    .createReader(  </span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">SourceReaderContext</span>(  </span><br><span class="line">                                    indexID,  </span><br><span class="line">                                    sourceAction.getSource().getBoundedness(),  </span><br><span class="line">                                    <span class="built_in">this</span>,  </span><br><span class="line">                                    metricsContext,  </span><br><span class="line">                                    eventListener));  </span><br><span class="line">    <span class="built_in">this</span>.enumeratorTaskAddress = getEnumeratorTaskAddress();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在这里<code>SinkWriter</code>的创建并没有在这里去创建。查看代码之后发现是在<code>restoreState</code>这个方法中进行创建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreState</span><span class="params">(List&lt;ActionSubtaskState&gt; actionStateList)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    List&lt;StateT&gt; states = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (writerStateSerializer.isPresent()) &#123;  </span><br><span class="line">        states =  </span><br><span class="line">                actionStateList.stream()  </span><br><span class="line">                        .map(ActionSubtaskState::getState)  </span><br><span class="line">                        .flatMap(Collection::stream)  </span><br><span class="line">                        .filter(Objects::nonNull)  </span><br><span class="line">                        .map(  </span><br><span class="line">                                bytes -&gt;  </span><br><span class="line">                                        sneaky(  </span><br><span class="line">                                                () -&gt;  </span><br><span class="line">                                                        writerStateSerializer  </span><br><span class="line">                                                                .get()  </span><br><span class="line">                                                                .deserialize(bytes)))  </span><br><span class="line">                        .collect(Collectors.toList());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (states.isEmpty()) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.writer =  </span><br><span class="line">                sinkAction  </span><br><span class="line">                        .getSink()  </span><br><span class="line">                        .createWriter(  </span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">SinkWriterContext</span>(indexID, metricsContext, eventListener));  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.writer =  </span><br><span class="line">                sinkAction  </span><br><span class="line">                        .getSink()  </span><br><span class="line">                        .restoreWriter(  </span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">SinkWriterContext</span>(indexID, metricsContext, eventListener),  </span><br><span class="line">                                states);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.writer <span class="keyword">instanceof</span> SupportResourceShare) &#123;  </span><br><span class="line">        resourceManager =  </span><br><span class="line">                ((SupportResourceShare) <span class="built_in">this</span>.writer).initMultiTableResourceManager(<span class="number">1</span>, <span class="number">1</span>);  </span><br><span class="line">        ((SupportResourceShare) <span class="built_in">this</span>.writer).setMultiTableResourceManager(resourceManager, <span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于这个方法什么时候会被调用，会在下面任务状态转换的时候在介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">received</span><span class="params">(Record&lt;?&gt; record)</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (record.getData() <span class="keyword">instanceof</span> Barrier) &#123;  </span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">  </span><br><span class="line">            <span class="type">Barrier</span> <span class="variable">barrier</span> <span class="operator">=</span> (Barrier) record.getData();  </span><br><span class="line">            <span class="keyword">if</span> (barrier.prepareClose(<span class="built_in">this</span>.taskLocation)) &#123;  </span><br><span class="line">                prepareClose = <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (barrier.snapshot()) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    lastCommitInfo = writer.prepareCommit();  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                    writer.abortPrepare();  </span><br><span class="line">                    <span class="keyword">throw</span> e;  </span><br><span class="line">                &#125;  </span><br><span class="line">                List&lt;StateT&gt; states = writer.snapshotState(barrier.getId());  </span><br><span class="line">                <span class="keyword">if</span> (!writerStateSerializer.isPresent()) &#123;  </span><br><span class="line">                    runningTask.addState(  </span><br><span class="line">                            barrier, ActionStateKey.of(sinkAction), Collections.emptyList());  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    runningTask.addState(  </span><br><span class="line">                            barrier,  </span><br><span class="line">                            ActionStateKey.of(sinkAction),  </span><br><span class="line">                            serializeStates(writerStateSerializer.get(), states));  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (containAggCommitter) &#123;  </span><br><span class="line">                    <span class="type">CommitInfoT</span> <span class="variable">commitInfoT</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">                    <span class="keyword">if</span> (lastCommitInfo.isPresent()) &#123;  </span><br><span class="line">                        commitInfoT = lastCommitInfo.get();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    runningTask  </span><br><span class="line">                            .getExecutionContext()  </span><br><span class="line">                            .sendToMember(  </span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">SinkPrepareCommitOperation</span>&lt;CommitInfoT&gt;(  </span><br><span class="line">                                            barrier,  </span><br><span class="line">                                            committerTaskLocation,  </span><br><span class="line">                                            commitInfoSerializer.isPresent()  </span><br><span class="line">                                                    ? commitInfoSerializer  </span><br><span class="line">                                                            .get()  </span><br><span class="line">                                                            .serialize(commitInfoT)  </span><br><span class="line">                                                    : <span class="literal">null</span>),  </span><br><span class="line">                                    committerTaskAddress)  </span><br><span class="line">                            .join();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (containAggCommitter) &#123;  </span><br><span class="line">                    runningTask  </span><br><span class="line">                            .getExecutionContext()  </span><br><span class="line">                            .sendToMember(  </span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">BarrierFlowOperation</span>(barrier, committerTaskLocation),  </span><br><span class="line">                                    committerTaskAddress)  </span><br><span class="line">                            .join();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            runningTask.ack(barrier);  </span><br><span class="line">  </span><br><span class="line">            log.debug(  </span><br><span class="line">                    <span class="string">&quot;trigger barrier [&#123;&#125;] finished, cost &#123;&#125;ms. taskLocation [&#123;&#125;]&quot;</span>,  </span><br><span class="line">                    barrier.getId(),  </span><br><span class="line">                    System.currentTimeMillis() - startTime,  </span><br><span class="line">                    taskLocation);  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (record.getData() <span class="keyword">instanceof</span> SchemaChangeEvent) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (prepareClose) &#123;  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="type">SchemaChangeEvent</span> <span class="variable">event</span> <span class="operator">=</span> (SchemaChangeEvent) record.getData();  </span><br><span class="line">            writer.applySchemaChange(event);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (prepareClose) &#123;  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            writer.write((T) record.getData());  </span><br><span class="line">            sinkWriteCount.inc();  </span><br><span class="line">            sinkWriteQPS.markEvent();  </span><br><span class="line">            <span class="keyword">if</span> (record.getData() <span class="keyword">instanceof</span> SeaTunnelRow) &#123;  </span><br><span class="line">                <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> ((SeaTunnelRow) record.getData()).getBytesSize();  </span><br><span class="line">                sinkWriteBytes.inc(size);  </span><br><span class="line">                sinkWriteBytesPerSeconds.markEvent(size);  </span><br><span class="line">                <span class="type">String</span> <span class="variable">tableId</span> <span class="operator">=</span> ((SeaTunnelRow) record.getData()).getTableId();  </span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(tableId)) &#123;  </span><br><span class="line">                    <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> getFullName(TablePath.of(tableId));  </span><br><span class="line">                    <span class="type">Counter</span> <span class="variable">sinkTableCounter</span> <span class="operator">=</span> sinkWriteCountPerTable.get(tableName);  </span><br><span class="line">                    <span class="keyword">if</span> (Objects.nonNull(sinkTableCounter)) &#123;  </span><br><span class="line">                        sinkTableCounter.inc();  </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span>  </span><br><span class="line">                                metricsContext.counter(SINK_WRITE_COUNT + <span class="string">&quot;#&quot;</span> + tableName);  </span><br><span class="line">                        counter.inc();  </span><br><span class="line">                        sinkWriteCountPerTable.put(tableName, counter);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接收数据的方法中，会对数据进行一些判断，会进行这几种类型的判断</p>
<ul>
<li>是否是snapshot<br>当触发snapshot时，会产生预提交信息，这个信息后面会在提交时使用<br>以及调用writer的snapshot方法，将现在的状态进行存储，从而在后面恢复时可以根据当前状态进行恢复。<br>然后再判断是否有committer的存在，如果有，则向其发送消息，让其根据刚刚产生的commit信息进行预提交。</li>
<li>是否是表结构变更的事件<br>当接收到表结构变更事件，也直接调用writer的相关方法，交由writer去实现</li>
<li>其他情况下<br>调用<code>writer.writer()</code>方法，进行真正的数据写入。并进行一些数据统计。</li>
</ul>
<p>这个地方只是将数据交给了具体的<code>writer</code>实现，至于<code>writer</code>有没有实时的将数据写入到具体的存储里面，也是根据连接器的实现来决定，有些连接器可能为了性能考虑会将数据进行攒批或者其他策略来进行发送写入，那么这里的调用与真正的数据写入还是会有一定的延迟的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyCheckpointComplete</span><span class="params">(<span class="type">long</span> checkpointId)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">if</span> (committer.isPresent() &amp;&amp; lastCommitInfo.isPresent()) &#123;  </span><br><span class="line">        committer.get().commit(Collections.singletonList(lastCommitInfo.get()));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyCheckpointAborted</span><span class="params">(<span class="type">long</span> checkpointId)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">if</span> (committer.isPresent() &amp;&amp; lastCommitInfo.isPresent()) &#123;  </span><br><span class="line">        committer.get().abort(Collections.singletonList(lastCommitInfo.get()));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法是checkpoint的成功与失败的方法，当成功时，如果<code>committer</code>存在，则进行真正的提交操作。否则则回滚这次提交。</p>
<h4 id="IntermediateQueueFlowLifeCycle"><a href="#IntermediateQueueFlowLifeCycle" class="headerlink" title="IntermediateQueueFlowLifeCycle"></a>IntermediateQueueFlowLifeCycle</h4><p><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081514999.png" alt="image.png"><br>在生成任务时, 会在任务之间添加<code>IntermediateExecutionFlow</code>来进行切分.<br>一个<code>IntermediateExecutionFlow</code>的<code>Flow</code>, 在生成<code>lifeCycle</code>阶段, 会生成一个<code>IntermediateQueueFlowLifeCycle</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flow <span class="keyword">instanceof</span> IntermediateExecutionFlow) &#123;  </span><br><span class="line">        <span class="type">IntermediateQueueConfig</span> <span class="variable">config</span> <span class="operator">=</span>  </span><br><span class="line">                ((IntermediateExecutionFlow&lt;IntermediateQueueConfig&gt;) flow).getConfig();  </span><br><span class="line">        lifeCycle =  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">IntermediateQueueFlowLifeCycle</span>(  </span><br><span class="line">                        <span class="built_in">this</span>,  </span><br><span class="line">                        completableFuture,  </span><br><span class="line">                        ((AbstractTaskGroupWithIntermediateQueue) taskBelongGroup)  </span><br><span class="line">                                .getQueueCache(config.getQueueID()));  </span><br><span class="line">        outputs = flowLifeCycles;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>来看一下<code>IntermediateQueueFlowLifeCycle</code>的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntermediateQueueFlowLifeCycle</span>&lt;T <span class="keyword">extends</span> <span class="title class_">AbstractIntermediateQueue</span>&lt;?&gt;&gt;  </span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractFlowLifeCycle</span>  </span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">OneInputFlowLifeCycle</span>&lt;Record&lt;?&gt;&gt;, OneOutputFlowLifeCycle&lt;Record&lt;?&gt;&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractIntermediateQueue&lt;?&gt; queue;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntermediateQueueFlowLifeCycle</span><span class="params">(  </span></span><br><span class="line"><span class="params">            SeaTunnelTask runningTask,  </span></span><br><span class="line"><span class="params">            CompletableFuture&lt;Void&gt; completableFuture,  </span></span><br><span class="line"><span class="params">            AbstractIntermediateQueue&lt;?&gt; queue)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(runningTask, completableFuture);  </span><br><span class="line">        <span class="built_in">this</span>.queue = queue;  </span><br><span class="line">        queue.setIntermediateQueueFlowLifeCycle(<span class="built_in">this</span>);  </span><br><span class="line">        queue.setRunningTask(runningTask);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">received</span><span class="params">(Record&lt;?&gt; record)</span> &#123;  </span><br><span class="line">        queue.received(record);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(Collector&lt;Record&lt;?&gt;&gt; collector)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        queue.collect(collector);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        queue.close();  </span><br><span class="line">        <span class="built_in">super</span>.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个里面有一个成员变量<code>AbstractIntermediateQueue</code>, 在初始化时会传递过来, 当被调用<code>received</code>或<code>collect</code>时, 都会调用<code>AbstractIntermediateQueue</code>的相应方法.</p>
<h4 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">stateProcess</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">switch</span> (currState) &#123;</span><br><span class="line">	    <span class="comment">// 当调用init方法时，都会将任务的状态置为INIT  </span></span><br><span class="line">        <span class="keyword">case</span> INIT:  </span><br><span class="line">	        <span class="comment">// 切换为WAITING_RESTORE</span></span><br><span class="line">            currState = WAITING_RESTORE;  </span><br><span class="line">            <span class="comment">// 报告任务的状态为WAITING_RESTORE</span></span><br><span class="line">            reportTaskStatus(WAITING_RESTORE);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> WAITING_RESTORE:  </span><br><span class="line">	        <span class="comment">// 当init方法执行结束后，会对所有的下游任务调用open方法</span></span><br><span class="line">            <span class="keyword">if</span> (restoreComplete.isDone()) &#123;  </span><br><span class="line">                <span class="keyword">for</span> (FlowLifeCycle cycle : allCycles) &#123;  </span><br><span class="line">                    cycle.open();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// 切换为READY_START,并且上报更新状态</span></span><br><span class="line">                currState = READY_START;  </span><br><span class="line">                reportTaskStatus(READY_START);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> READY_START:  </span><br><span class="line">            <span class="keyword">if</span> (startCalled) &#123;  </span><br><span class="line">                currState = STARTING;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> STARTING:  </span><br><span class="line">            currState = RUNNING;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> RUNNING:  </span><br><span class="line">	        <span class="comment">// 在RUNNING状态会调用collect方法</span></span><br><span class="line">	        <span class="comment">// 这个方法在SourceTask中会调用reader.pollNext方法，从而开始真正的数据读取，读取完成后会发送到SeaTunnelSourceCollector中，在SeaTunnelSourceCollector中接收到一条数据后，又会将数据发送给所有的下游任务</span></span><br><span class="line">	        <span class="comment">// 在TransformTask中，会调用transform的map方法，进行数据转换，转换完成后，将数据发送给SeaTunnelTransformCollector，同样在SeaTunnelTransformCollector中也会将数据发送给所有的下游</span></span><br><span class="line">            collect();  </span><br><span class="line">            <span class="keyword">if</span> (prepareCloseStatus) &#123;  </span><br><span class="line">                currState = PREPARE_CLOSE;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> PREPARE_CLOSE:  </span><br><span class="line">            <span class="keyword">if</span> (closeCalled) &#123;  </span><br><span class="line">                currState = CLOSED;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> CLOSED:  </span><br><span class="line">            <span class="built_in">this</span>.close();  </span><br><span class="line">            progress.done();  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">            <span class="comment">// TODO support cancel by outside  </span></span><br><span class="line">        <span class="keyword">case</span> CANCELLING:  </span><br><span class="line">            <span class="built_in">this</span>.close();  </span><br><span class="line">            currState = CANCELED;  </span><br><span class="line">            progress.done();  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        <span class="keyword">default</span>:  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown Enumerator State: &quot;</span> + currState);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h3><p>在<code>API</code>的章节, 有描述<code>Collector</code>的功能, 是在单进程内多个线程间的数据管道.<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081514999.png" alt="image.png"></p>
<p>在任务拆分阶段, 会将<code>sink</code>单独拆离出来, 通过<code>IntermediateExecutionFlow</code>进行关联.<br>而<code>source</code>和<code>transform</code>则是放到了一起.<br>也就是说这里涉及到的数据传递涉及到的节点是<code>sink</code>和它的上游任务.<br>在<code>IntermediateQueueFlowLifeCycle</code>中, 有一个<code>AbstractIntermediateQueue</code>队列变量, 多个线程之间通过这个队列来实现生产者&#x2F;消费者的消费模型来进行数据传递.<br><code>AbstractIntermediateQueue</code>有两个实现类:</p>
<ul>
<li><code>IntermediateBlockingQueue</code></li>
<li><code>IntermediateDisruptor</code><br>它们两个的区别是消息队列的实现有所不同, <code>IntermediateBlockingQueue</code>是默认的实现, 是通过<code>ArrayBlockingQueue</code>来实现的.<br>而<code>IntermediateDisruptor</code>则是通过<code>Disruptor</code>来实现的, 如果需要开启此功能, 需要在<code>seatunnel.yaml</code>中修改配置项<code>engine.queue-type=DISRUPTOR</code>来开启.</li>
</ul>
<p>其实在代码中也有一些关于<code>Shuffle</code>的实现, 它实现的数据传递是基于<code>hazelcast</code>的<code>IQueue</code>队列来实现的, 可以实现跨进程的数据传递, 但是这一部分请教了社区的大佬之后, 说这一部分后续也废弃了.</p>
<h2 id="TaskExecution"><a href="#TaskExecution" class="headerlink" title="TaskExecution"></a>TaskExecution</h2><p>在上面分析了一个任务的执行过程，这个章节会记录一下，一个具体的任务&#x2F;Task&#x2F;Class，是如何被运行起来的。</p>
<h2 id="TaskExecutionService"><a href="#TaskExecutionService" class="headerlink" title="TaskExecutionService"></a>TaskExecutionService</h2><p>在Zeta引擎启动后，在服务端会启动一个<code>TaskExecutionService</code>服务，这个服务内会有一个缓存线程池来执行任务。<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081457994.png"></p>
<p>在<code>PhysicalVertex</code>的状态切换中，当状态为<code>DEPLOYING</code>时，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> DEPLOYING:  </span><br><span class="line">    <span class="type">TaskDeployState</span> <span class="variable">deployState</span> <span class="operator">=</span>  </span><br><span class="line">            deploy(jobMaster.getOwnedSlotProfiles(taskGroupLocation));  </span><br><span class="line">    <span class="keyword">if</span> (!deployState.isSuccess()) &#123;  </span><br><span class="line">        makeTaskGroupFailing(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TaskGroupDeployException</span>(deployState.getThrowableMsg()));  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        updateTaskState(ExecutionState.RUNNING);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>会将作业进行部署，部署到之前所申请到的worker节点上。<br>这个类里有这样一个方法来生成<code>TaskGroupImmutableInformation</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TaskGroupImmutableInformation <span class="title function_">getTaskGroupImmutableInformation</span><span class="params">()</span> &#123;  </span><br><span class="line">    List&lt;Data&gt; tasksData =  </span><br><span class="line">            <span class="built_in">this</span>.taskGroup.getTasks().stream()  </span><br><span class="line">                    .map(task -&gt; (Data) nodeEngine.getSerializationService().toData(task))  </span><br><span class="line">                    .collect(Collectors.toList());  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TaskGroupImmutableInformation</span>(  </span><br><span class="line">            <span class="built_in">this</span>.taskGroup.getTaskGroupLocation().getJobId(),  </span><br><span class="line">            flakeIdGenerator.newId(),  </span><br><span class="line">            <span class="built_in">this</span>.taskGroup.getTaskGroupType(),  </span><br><span class="line">            <span class="built_in">this</span>.taskGroup.getTaskGroupLocation(),  </span><br><span class="line">            <span class="built_in">this</span>.taskGroup.getTaskGroupName(),  </span><br><span class="line">            tasksData,  </span><br><span class="line">            <span class="built_in">this</span>.pluginJarsUrls,  </span><br><span class="line">            <span class="built_in">this</span>.connectorJarIdentifiers);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看出，会将当前节点上的所有任务进行序列化，然后设置相应的字段值。<br>生成这个信息后，会进行网络调用，将这个信息发送给具体的Worker上。<br><strong>从这个地方也可以得知，一个<code>TaskGroup</code>内的所有任务都会被分发到同一个节点上运行.</strong></p>
<p>而<code>Worker</code>接收到这个信息后，会调用<code>TaskExecutionService</code>的<code>deployTask(@NonNull Data taskImmutableInformation)</code>方法。这个方法内会进行网络传输数据的反序列化，之后再调用<code>TaskDeployState deployTask(@NonNull TaskGroupImmutableInformation taskImmutableInfo)</code></p>
<p>我们来具体看下这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TaskDeployState <span class="title function_">deployTask</span><span class="params">(<span class="meta">@NonNull</span> TaskGroupImmutableInformation taskImmutableInfo)</span> &#123;  </span><br><span class="line">    logger.info(  </span><br><span class="line">            String.format(  </span><br><span class="line">                    <span class="string">&quot;received deploying task executionId [%s]&quot;</span>,  </span><br><span class="line">                    taskImmutableInfo.getExecutionId()));  </span><br><span class="line">    <span class="type">TaskGroup</span> <span class="variable">taskGroup</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        List&lt;Set&lt;ConnectorJarIdentifier&gt;&gt; connectorJarIdentifiersList =  </span><br><span class="line">                taskImmutableInfo.getConnectorJarIdentifiers();  </span><br><span class="line">        List&lt;Data&gt; taskData = taskImmutableInfo.getTasksData();  </span><br><span class="line">        ConcurrentHashMap&lt;Long, ClassLoader&gt; classLoaders = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">        List&lt;Task&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        ConcurrentHashMap&lt;Long, Collection&lt;URL&gt;&gt; taskJars = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; taskData.size(); i++) &#123;  </span><br><span class="line">            Set&lt;URL&gt; jars = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  </span><br><span class="line">            Set&lt;ConnectorJarIdentifier&gt; connectorJarIdentifiers =  </span><br><span class="line">                    connectorJarIdentifiersList.get(i);  </span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(connectorJarIdentifiers)) &#123;  </span><br><span class="line">                jars = serverConnectorPackageClient.getConnectorJarFromLocal(  </span><br><span class="line">                                connectorJarIdentifiers);  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!CollectionUtils.isEmpty(taskImmutableInfo.getJars().get(i))) &#123;  </span><br><span class="line">                jars = taskImmutableInfo.getJars().get(i);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span>  </span><br><span class="line">                    classLoaderService.getClassLoader(  </span><br><span class="line">                            taskImmutableInfo.getJobId(), Lists.newArrayList(jars));  </span><br><span class="line">            Task task;  </span><br><span class="line">            <span class="keyword">if</span> (jars.isEmpty()) &#123;  </span><br><span class="line">                task = nodeEngine.getSerializationService().toObject(taskData.get(i));  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                task =  </span><br><span class="line">                        CustomClassLoadedObject.deserializeWithCustomClassLoader(  </span><br><span class="line">                                nodeEngine.getSerializationService(),  </span><br><span class="line">                                classLoader,  </span><br><span class="line">                                taskData.get(i));  </span><br><span class="line">            &#125;  </span><br><span class="line">            tasks.add(task);  </span><br><span class="line">            classLoaders.put(task.getTaskID(), classLoader);  </span><br><span class="line">            taskJars.put(task.getTaskID(), jars);  </span><br><span class="line">        &#125;  </span><br><span class="line">        taskGroup =  </span><br><span class="line">                TaskGroupUtils.createTaskGroup(  </span><br><span class="line">                        taskImmutableInfo.getTaskGroupType(),  </span><br><span class="line">                        taskImmutableInfo.getTaskGroupLocation(),  </span><br><span class="line">                        taskImmutableInfo.getTaskGroupName(),  </span><br><span class="line">                        tasks);  </span><br><span class="line">  </span><br><span class="line">        logger.info(  </span><br><span class="line">                String.format(  </span><br><span class="line">                        <span class="string">&quot;deploying task %s, executionId [%s]&quot;</span>,  </span><br><span class="line">                        taskGroup.getTaskGroupLocation(), taskImmutableInfo.getExecutionId()));  </span><br><span class="line">		<span class="comment">// 上面获取一些信息后重新构建taskGroup</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; </span><br><span class="line">			<span class="comment">// 首先会判断当前是否已经运行了该任务，如果已经运行过则不再提交任务</span></span><br><span class="line">			<span class="comment">// 同时这里也对当前实例添加了全局锁，避免同时调用的问题</span></span><br><span class="line">            <span class="keyword">if</span> (executionContexts.containsKey(taskGroup.getTaskGroupLocation())) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(  </span><br><span class="line">                        String.format(  </span><br><span class="line">                                <span class="string">&quot;TaskGroupLocation: %s already exists&quot;</span>,  </span><br><span class="line">                                taskGroup.getTaskGroupLocation()));  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有运行过当前任务则进行提交  </span></span><br><span class="line">            deployLocalTask(taskGroup, classLoaders, taskJars);  </span><br><span class="line">            <span class="keyword">return</span> TaskDeployState.success();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">		... </span><br><span class="line">        <span class="keyword">return</span> TaskDeployState.failed(t);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法内会根据<code>TaskGroupImmutableInformation</code>信息来重新构建<code>TaskGroup</code>，然后调用<code>deployLocalTask()</code>进行部署任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PassiveCompletableFuture&lt;TaskExecutionState&gt; <span class="title function_">deployLocalTask</span><span class="params">(  </span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> TaskGroup taskGroup,  </span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> ConcurrentHashMap&lt;Long, ClassLoader&gt; classLoaders,  </span></span><br><span class="line"><span class="params">        ConcurrentHashMap&lt;Long, Collection&lt;URL&gt;&gt; jars)</span> &#123;  </span><br><span class="line">    CompletableFuture&lt;TaskExecutionState&gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 初始化操作  </span></span><br><span class="line">        taskGroup.init();  </span><br><span class="line">        logger.info(  </span><br><span class="line">                String.format(  </span><br><span class="line">                        <span class="string">&quot;deploying TaskGroup %s init success&quot;</span>,  </span><br><span class="line">                        taskGroup.getTaskGroupLocation()));  </span><br><span class="line">        <span class="comment">// 获取到当前任务组中的所有任务</span></span><br><span class="line">        Collection&lt;Task&gt; tasks = taskGroup.getTasks();  </span><br><span class="line">        CompletableFuture&lt;Void&gt; cancellationFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">TaskGroupExecutionTracker</span> <span class="variable">executionTracker</span> <span class="operator">=</span>  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TaskGroupExecutionTracker</span>(cancellationFuture, taskGroup, resultFuture);  </span><br><span class="line">        ConcurrentMap&lt;Long, TaskExecutionContext&gt; taskExecutionContextMap =  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">final</span> Map&lt;Boolean, List&lt;Task&gt;&gt; byCooperation =  </span><br><span class="line">                tasks.stream()  </span><br><span class="line">                        .peek(</span><br><span class="line">                        <span class="comment">// 设置context信息  </span></span><br><span class="line">                                task -&gt; &#123;  </span><br><span class="line">                                    <span class="type">TaskExecutionContext</span> <span class="variable">taskExecutionContext</span> <span class="operator">=</span>  </span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">TaskExecutionContext</span>(task, nodeEngine, <span class="built_in">this</span>);  </span><br><span class="line">                                    task.setTaskExecutionContext(taskExecutionContext);  </span><br><span class="line">                                    taskExecutionContextMap.put(  </span><br><span class="line">                                            task.getTaskID(), taskExecutionContext);  </span><br><span class="line">                                &#125;)  </span><br><span class="line">                        .collect(</span><br><span class="line">                        <span class="comment">// 会根据是否需要线程共享来进行分组</span></span><br><span class="line">                        <span class="comment">// 目前默认是不共享的，也就是全部都会是false  </span></span><br><span class="line">                                partitioningBy(  </span><br><span class="line">                                        t -&gt; &#123;  </span><br><span class="line">                                            <span class="type">ThreadShareMode</span> <span class="variable">mode</span> <span class="operator">=</span>  </span><br><span class="line">                                                    seaTunnelConfig  </span><br><span class="line">                                                            .getEngineConfig()  </span><br><span class="line">                                                            .getTaskExecutionThreadShareMode();  </span><br><span class="line">                                            <span class="keyword">if</span> (mode.equals(ThreadShareMode.ALL)) &#123;  </span><br><span class="line">                                                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">                                            &#125;  </span><br><span class="line">                                            <span class="keyword">if</span> (mode.equals(ThreadShareMode.OFF)) &#123;  </span><br><span class="line">                                                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">                                            &#125;  </span><br><span class="line">                                            <span class="keyword">if</span> (mode.equals(ThreadShareMode.PART)) &#123;  </span><br><span class="line">                                                <span class="keyword">return</span> t.isThreadsShare();  </span><br><span class="line">                                            &#125;  </span><br><span class="line">                                            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">                                        &#125;));  </span><br><span class="line">        executionContexts.put(  </span><br><span class="line">                taskGroup.getTaskGroupLocation(),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TaskGroupContext</span>(taskGroup, classLoaders, jars));  </span><br><span class="line">        cancellationFutures.put(taskGroup.getTaskGroupLocation(), cancellationFuture);  </span><br><span class="line">        <span class="comment">// 这里全部是空，如果用户修改了，这里会找出来需要线程共享的任务</span></span><br><span class="line">        submitThreadShareTask(executionTracker, byCooperation.get(<span class="literal">true</span>)); </span><br><span class="line">        <span class="comment">// 提交任务 </span></span><br><span class="line">        submitBlockingTask(executionTracker, byCooperation.get(<span class="literal">false</span>));  </span><br><span class="line">        taskGroup.setTasksContext(taskExecutionContextMap);  </span><br><span class="line">        <span class="comment">// 打印成功的日志</span></span><br><span class="line">        logger.info(  </span><br><span class="line">                String.format(  </span><br><span class="line">                        <span class="string">&quot;deploying TaskGroup %s success&quot;</span>, taskGroup.getTaskGroupLocation()));  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">        logger.severe(ExceptionUtils.getMessage(t));  </span><br><span class="line">        resultFuture.completeExceptionally(t);  </span><br><span class="line">    &#125;  </span><br><span class="line">    resultFuture.whenCompleteAsync(  </span><br><span class="line">            withTryCatch(  </span><br><span class="line">                    logger,  </span><br><span class="line">                    (r, s) -&gt; &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;  </span><br><span class="line">                            logger.severe(  </span><br><span class="line">                                    String.format(  </span><br><span class="line">                                            <span class="string">&quot;Task %s complete with error %s&quot;</span>,  </span><br><span class="line">                                            taskGroup.getTaskGroupLocation(),  </span><br><span class="line">                                            ExceptionUtils.getMessage(s)));  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;  </span><br><span class="line">                            r =  </span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">TaskExecutionState</span>(  </span><br><span class="line">                                            taskGroup.getTaskGroupLocation(),  </span><br><span class="line">                                            ExecutionState.FAILED,  </span><br><span class="line">                                            s);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        logger.info(  </span><br><span class="line">                                String.format(  </span><br><span class="line">                                        <span class="string">&quot;Task %s complete with state %s&quot;</span>,  </span><br><span class="line">                                        r.getTaskGroupLocation(), r.getExecutionState()));  </span><br><span class="line">         <span class="comment">// 报告部署的状态给master               notifyTaskStatusToMaster(taskGroup.getTaskGroupLocation(), r);  </span></span><br><span class="line">                    &#125;),  </span><br><span class="line">            MDCTracer.tracing(executorService));  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PassiveCompletableFuture</span>&lt;&gt;(resultFuture);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>submitBlockingTask<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">submitBlockingTask</span><span class="params">(  </span></span><br><span class="line"><span class="params">        TaskGroupExecutionTracker taskGroupExecutionTracker, List&lt;Task&gt; tasks)</span> &#123;  </span><br><span class="line">    <span class="type">MDCExecutorService</span> <span class="variable">mdcExecutorService</span> <span class="operator">=</span> MDCTracer.tracing(executorService);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">startedLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(tasks.size());  </span><br><span class="line">    taskGroupExecutionTracker.blockingFutures =  </span><br><span class="line">            tasks.stream()  </span><br><span class="line">                    .map(  </span><br><span class="line">                            t -&gt;  </span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">BlockingWorker</span>(  </span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">TaskTracker</span>(t, taskGroupExecutionTracker),  </span><br><span class="line">                                            startedLatch))  </span><br><span class="line">                    .map(  </span><br><span class="line">                            r -&gt;  </span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">NamedTaskWrapper</span>(  </span><br><span class="line">                                            r,  </span><br><span class="line">                                            <span class="string">&quot;BlockingWorker-&quot;</span>  </span><br><span class="line">                                                    + taskGroupExecutionTracker.taskGroup  </span><br><span class="line">                                                            .getTaskGroupLocation()))  </span><br><span class="line">                    .map(mdcExecutorService::submit)  </span><br><span class="line">                    .collect(toList());  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Do not return from this method until all workers have started. Otherwise,  </span></span><br><span class="line">    <span class="comment">// on cancellation there is a race where the executor might not have started    // the worker yet. This would result in taskletDone() never being called for    // a worker.    uncheckRun(startedLatch::await);  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里的<code>MDCExecutorService</code>是<code>ExecutorService</code>实现，<code>BlockWorking</code>是<code>Runnable</code>的实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BlockingWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskTracker tracker;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startedLatch;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BlockingWorker</span><span class="params">(TaskTracker tracker, CountDownLatch startedLatch)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.tracker = tracker;  </span><br><span class="line">        <span class="built_in">this</span>.startedLatch = startedLatch;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        TaskExecutionService.<span class="type">TaskGroupExecutionTracker</span> <span class="variable">taskGroupExecutionTracker</span> <span class="operator">=</span>  </span><br><span class="line">                tracker.taskGroupExecutionTracker;  </span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span>  </span><br><span class="line">                executionContexts  </span><br><span class="line">                        .get(taskGroupExecutionTracker.taskGroup.getTaskGroupLocation())  </span><br><span class="line">                        .getClassLoaders()  </span><br><span class="line">                        .get(tracker.task.getTaskID());  </span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">oldClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();  </span><br><span class="line">        Thread.currentThread().setContextClassLoader(classLoader);  </span><br><span class="line">        <span class="comment">// 获取到SeaTunnel的Task</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">t</span> <span class="operator">=</span> tracker.task;  </span><br><span class="line">        <span class="type">ProgressState</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            startedLatch.countDown();  </span><br><span class="line">            <span class="comment">// 调用Task的init方法</span></span><br><span class="line">            t.init();  </span><br><span class="line">            <span class="keyword">do</span> &#123; </span><br><span class="line">	            <span class="comment">// 循环调用 call()方法 </span></span><br><span class="line">                result = t.call();  </span><br><span class="line">            &#125; <span class="keyword">while</span> (!result.isDone()  </span><br><span class="line">                    &amp;&amp; isRunning  </span><br><span class="line">                    &amp;&amp; !taskGroupExecutionTracker.executionCompletedExceptionally());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            logger.warning(String.format(<span class="string">&quot;Interrupted task %d - %s&quot;</span>, t.getTaskID(), t));  </span><br><span class="line">            <span class="keyword">if</span> (taskGroupExecutionTracker.executionException.get() == <span class="literal">null</span>  </span><br><span class="line">                    &amp;&amp; !taskGroupExecutionTracker.isCancel.get()) &#123;  </span><br><span class="line">                taskGroupExecutionTracker.exception(e);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;  </span><br><span class="line">            logger.warning(<span class="string">&quot;Exception in &quot;</span> + t, e);  </span><br><span class="line">            taskGroupExecutionTracker.exception(e);  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            taskGroupExecutionTracker.taskDone(t);  </span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span> || !result.isDone()) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    tracker.task.close();  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                    logger.severe(<span class="string">&quot;Close task error&quot;</span>, e);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Thread.currentThread().setContextClassLoader(oldClassLoader);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这几部分代码可以看出，每一个Task都会作为一个单独的线程任务，被放到<code>Worker</code>的<code>newCachedThreadPool</code>线程池中来进行运行。</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081500558.png" alt="image.png"></p>
<p>我们如果将上面的任务放大来看，将每个线程所做的任务以及任务之间的通信也画出来，大致是这样<br><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081500210.png" alt="image.png"></p>
<p>如果将上面的图缩小看一下，仅关注数据的传输过程，大致是这样</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/202411081532399.png" alt="image.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/seatunnel/issues/2272">https://github.com/apache/seatunnel/issues/2272</a><br>本文是对SeaTunnel Zeta引擎的解析，这个pr中记录了当时Zeta引擎的一些设计文档，强烈推荐阅读下相关的pr及设计文档</li>
</ul>

<br>
<h2>Tags: </h2>
  <p><a class="classtest-link" href="/tags/seatunnel/" rel="tag">seatunnel</a> — 2024年11月25日</p>
  

  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>

        </div>
        <!-- <div class="row mt-2">
  <h3>Search</h3>
  <div><input id="search-text" title="search" class="search-text" type="text" placeholder="search......"></div>
  <div style="margin-top: 1.5rem;">
    <ul id="result"></ul>
  </div>
</div> -->
        <div class="row mt-2">
  
    <div class="eight columns">
      <p id="madewith">Made with ❤ and
        <a class="footer-link icon" href="https://hexo.io" target="_blank" style="text-decoration: none;" rel="noreferrer" aria-label="Hexo.io">
        <svg class="hexo svg-hov" width="14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Hexo.js</title><path d="M12 .007L1.57 6.056V18.05L12 23.995l10.43-6.049V5.952L12 .007zm4.798 17.105l-.939.521-.939-.521V12.94H9.08v4.172l-.94.521-.938-.521V6.89l.939-.521.939.521v4.172h5.84V6.89l.94-.521.938.521v10.222z"/></svg>
        </a>
        
    </div>

    <!-- Sepcial thanks to https://simpleicons.org/ for the icons -->
    <div class="four columns mb-3 posisi" >
      
      <a class="ml-0 footer-link icon" href="https://github.com/liunaijie" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="GitHub">
        <svg class="github svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      </a>
      

      

      

      

      
      
        <a class="ml-0 footer-link icon" href="mailto:jarvis@apache.org" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="Email">
          <svg class="email svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Email</title><path d="M12 12.713l11.985-7.99c-.01-.01-11.985-7.723-11.985-7.723s-11.975 7.713-11.985 7.723l11.985 7.99zm0 2.287l-12-8v14h24v-14l-12 8z"/></svg>
        </a>
        
    </div>
  
</div>

      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>

  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>