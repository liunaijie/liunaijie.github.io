<!DOCTYPE html>
<html lang="zh-CN">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>Spring笔记</title>
  
  <link rel="canonical" href="https://www.liunaijie.top/2019/09/03/Blog-Posts/coding/spring/Spring%E7%AC%94%E8%AE%B0/">
  
  <meta name="description" content="最近在阅读《Spring in action》这本书，也以此篇文章记录一下spring框架的相关内容。 那么既然聊spring了，一定会聊到的两个点就是ioc和aop。那就先来聊一下这两个东西。以下都是个人理解，如果有不对的地方，欢迎探讨指正。 ioc 和 aop 是编程思想，di 和 aspect">
  
  
  <meta name="keywords" content="blog">
  
  <meta name="author" content="Jarvis">
  
  
  
  <meta property="og:site_name" content="J.A.R.V.I.S" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Spring笔记" />
  
  <meta property="og:description" content="最近在阅读《Spring in action》这本书，也以此篇文章记录一下spring框架的相关内容。 那么既然聊spring了，一定会聊到的两个点就是ioc和aop。那就先来聊一下这两个东西。以下都是个人理解，如果有不对的地方，欢迎探讨指正。 ioc 和 aop 是编程思想，di 和 aspect">
  
  <meta property="og:url" content="https://www.liunaijie.top/2019/09/03/Blog-Posts/coding/spring/Spring%E7%AC%94%E8%AE%B0/" />

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Spring笔记">
  
  <meta name="twitter:description" content="最近在阅读《Spring in action》这本书，也以此篇文章记录一下spring框架的相关内容。 那么既然聊spring了，一定会聊到的两个点就是ioc和aop。那就先来聊一下这两个东西。以下都是个人理解，如果有不对的地方，欢迎探讨指正。 ioc 和 aop 是编程思想，di 和 aspect">
  
  
  
  
  <meta name="twitter:url" content="https://www.liunaijie.top/2019/09/03/Blog-Posts/coding/spring/Spring%E7%AC%94%E8%AE%B0/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="/fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/jarvis.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

  
  <script src="/js/pic.min.js" defer></script>
  

  

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="J.A.R.V.I.S" type="application/atom+xml">
</head>

<body>
  <div class="container">
    <div class="row">
      <div>

        <div class="row">
  <div class="two columns" style="max-width: 50px">
    <h1 class="mt-2 mode">
      <div onclick=setDarkMode(true) id="darkBtn"></div>
      <div onclick=setDarkMode(false) id="lightBtn" class=hidden></div>
      <script >
        if (localStorage.getItem('preferredTheme') == 'dark') {
          setDarkMode(true)
        }
        function setDarkMode(isDark) {
          var darkBtn = document.getElementById('darkBtn')
          var lightBtn = document.getElementById('lightBtn')
          if (isDark) {
            lightBtn.style.display = "block"
            darkBtn.style.display = "none"
            localStorage.setItem('preferredTheme', 'dark');
          } else {
            lightBtn.style.display = "none"
            darkBtn.style.display = "block"
            localStorage.removeItem('preferredTheme');
          }
          document.body.classList.toggle("darkmode");
        }
      </script>
    </h1>
  </div>

  <div class="six columns ml-1">
    <h1 class="mt-2">
      Jarvis&#39;s Blog
    </h1>
  </div>

  <div class="twelve columns">
    <div class="row">
      <div class="nine columns left">
        
          
          <a href="/" class="ml">Home</a>
          
        
          
          <a href="/categories/publish/" class="ml">Publish</a>
          
        
          
          <a href="/about" class="ml">About</a>
          
        
          
          <a href="/atom.xml" class="ml">Rss</a>
          
        
      </div>
    </div>
    <hr style="margin-bottom: 2.6rem">
  </div>
</div>

        <div class="trans">
            <h2>Spring笔记</h2>

  <p>最近在阅读《Spring in action》这本书，也以此篇文章记录一下<code>spring</code>框架的相关内容。</p>
<p>那么既然聊<code>spring</code>了，一定会聊到的两个点就是<code>ioc</code>和<code>aop</code>。那就先来聊一下这两个东西。以下都是个人理解，如果有不对的地方，欢迎探讨指正。</p>
<p>ioc 和 aop 是编程思想，di 和 aspect 是他们的具体实现。</p>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>IOC:控制反转，DI：依赖注入。</p>
<h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p>在传统的 Java SE 程序中，我们在对象内部通过 new 的方法来创建对象实例，在这里是程序主动创建的依赖对象。而在 spring 中，它使用了专门的容器去控制对象。</p>
<p>控制的是对象的<strong>创建、初始化、销毁</strong>过程</p>
<p>在传统的 Java SE中，我们使用 new 进行创建。在构造器或者 setter 方法中给依赖对象赋值。给对象赋值 null 来销毁对象。</p>
<p>而在spring中一个bean的生命周期如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/spring%E7%9A%84bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="bean的生命周期"></p>
<h2 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h2><p>控制反转。我们之前是主动方，主动去控制对象的生命周期。现在变成了由 spring 去进行控制。我们由对象的控制者变成了被动控制者。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>ioc 思想落实到代码上的具体实现。</p>
<p>在spring中，我们一般使用注解<code>Component</code>，<code>Service</code>，<code>Repository</code>，<code>Controller</code>，<code>Autowired</code>或<code>Resource</code>来进行注入。这个实例化出来的bean生命周期交给了spring来进行管理。我们将他们放在不同的类上表达不同的含义。</p>
<p>如果不进行主动声明，则默认的bean的名称为类名首字母小写，比如我对一个<code>UserServiceImpl</code>上添加<code>@Service</code>注解，spring则将这个类声明为<code>userServiceImpl</code>的bean。也可以这样进行主动声明<code>@Service(&quot;beanName&quot;)</code>。</p>
<p>如果我们对一个接口进入注入，这个接口下有多个实现类，这是spring就不知道我们要使用哪个实现类了，启动时会报错。</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/20190919083201.png"></p>
<p>这时候有两种解决办法：</p>
<ul>
<li><p>继续使用<code>@Autowired</code>注解</p>
<p>  这个注解下也有两种解决方式：</p>
<ul>
<li><p>对实现类进行修改，添加<code>@Primary</code>首选项注解</p>
<p>  我们对其中一个实现类添加这个注解，那么在注入时会首先注入这个实现类</p>
</li>
<li><p>对引入类添加<code>@Qualifier</code>限定符注解</p>
<p>  我们在<code>@Autowired</code>下添加这个注解，注解里面的内容为我们要注入实现类bean的id。这时候如果实现类的类名修改了也就是bean的id修改了，就又有问题了。这种情况下可以自定义限定符来实现。</p>
</li>
</ul>
</li>
<li><p>使用<code>@Resource</code>注解</p>
<p>  使用这个注解，即可在里面直接加参数，指定要注入实现类bean的id。</p>
</li>
</ul>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>面向切面编程：</p>
<blockquote>
<p>在软件开发中，散布于应用中多处的功能被称为横切关注点。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把这些横切关注点与业务逻辑相分离正是面向切面（AOP）所要解决的问题。</p>
</blockquote>
<p>比如说我们现在有一个业务系统，有学生，教师，课程几个业务模块，我们现在需要一些功能，比如说日志，事务等功能，这些功能实际上并不是我们的业务模块，但是又需要在系统中添加，这就可以利用面向切面来解决这个问题。</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/a4.1.png"></p>
<blockquote>
<p>在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称作切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（业务功能）的代码，而次要关注点的代码被转移到切面中了。</p>
</blockquote>
<h2 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h2><p>描述切面的常用术语有通知(advice)，切点(pointcut)和连接点(joinpoint)。</p>
<h3 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h3><p>通知定义了切面是什么以及何时使用。  </p>
<p>spring切面可以应用5种类型的通知</p>
<ul>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ul>
<h3 id="连接点-JoinPoint"><a href="#连接点-JoinPoint" class="headerlink" title="连接点(JoinPoint)"></a>连接点(JoinPoint)</h3><p>连接点是在应用执行过程中能够插入切面的一个点。（被切入的地方）</p>
<h3 id="切点-PointCut"><a href="#切点-PointCut" class="headerlink" title="切点(PointCut)"></a>切点(PointCut)</h3><p>切点定义了”何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来制定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。（定义的包，类，方法，注解等）</p>
<h3 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面(Aspect)"></a>切面(Aspect)</h3><p>切面是通知和切点的结合，通知和切点共同定义了切面的全部内容–它是什么，在何时和何处完成其功能。</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>引入允许我们向现有的类添加新方法或属性。</p>
<h3 id="织入"><a href="#织入" class="headerlink" title="织入"></a>织入</h3><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p>
<ul>
<li>编译期：切面在目标类编译时被织入，这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader)，它可以在目标被引入应用之前增强该目标类的字节码，AspectJ5的加载时织入就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 @Aspect注解声明这是一个切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="comment">// 添加 @Component注解声明这是一个javabean，不然spring扫描不到这个类，我们在这里写的东西就没有用</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAspect</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用@Pointcut注解定义可重用的切点，这样在下面就可以直接调用这个切点的方法名即可</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.test..*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPointcut</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;testPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After(&quot;testPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>我先声明了利用<code>@Pointcut</code>声明了一个切点，里面使用了<code>execution</code>关键字，这个关键字里面的内容就描述了我要对哪个地方进行切入。</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/execution%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90.png" alt="execution表达式解析"></p>
<p>在我刚才写的代码里面我是对<code>com.test</code>包下的所有的类，所有的方法，不管其参数类型，返回结果类型都进行切入，当<code>com.test</code>包下的方法被调用时，调用前会打印<code>doBefore()</code>方法中的内容，调用完成后会打印<code>doAfter()</code>方法中的内容。</p>
<p>我们只需要调整表达式里面的内容就可以自定义实现要切入的点。</p>
<p>然后再说一下对<strong>注解</strong>的切入  </p>
<p>如果我们自定义了一个注解，然后需要对这个注解实现切入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAspect</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(testAnnotation)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before method proceed...&quot;</span>);</span><br><span class="line">            proceedingJoinPoint.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;after method proceed...&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;method error...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对添加了<code>testAnnotation</code>注解的方法会执行这个切入，并且我使用了环绕通知。这里多了一个<code>ProceedingJoinPoint</code>参数，这个对象是必须要有的，需要调用<code>proceed()</code>方法才会实际调用被切入点执行的方法，而有意思的地方是<strong>这个方法我们可以不调用(不会执行被切入点的逻辑)，也可调用一至多次</strong>。</p>
<p>之前说的通知也有相应的注解</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>通知</th>
</tr>
</thead>
<tbody><tr>
<td>@Before</td>
<td>通知方法会在目标方法调用之前执行</td>
</tr>
<tr>
<td>@After</td>
<td>通知方法会在目标方法返回或抛出异常后调用</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>通知方法会在目标方法返回后调用</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>通知方法会在目标方法抛出异常后调用</td>
</tr>
<tr>
<td>@Around</td>
<td>通知方法会将目标方法封装起来</td>
</tr>
</tbody></table>
<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><ol>
<li><p>多个切面时执行顺序</p>
<p> 当一个类被多个切面切入时，如何控制多个切面的顺序呢？这时需要使用<code>@Order()</code>注解。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span>  <span class="comment">//数值越小，优先级越高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAspect</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>设置在特定环境中使用 aop</p>
<p> 有一些通过 aop 实现的功能我们可能只想在开发、测试环境中进行使用。在生成环境中进行关闭。这时我们可以添加<code>@Profile</code>注解即可</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span>  <span class="comment">//添加这个注解即可在开发，测试环境中使用这个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAspect</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 添加这个注解后，需要在配置文件的<code>spring.profiles.active</code>属性设置为<code>dev</code>或<code>test</code>并添加相应的配置文件即可。</p>
</li>
</ol>
<p>通过一张图来说明 aop 的执行顺序。</p>
<p>![aop流程](<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/liunaijie/images/master/aop">https://raw.githubusercontent.com/liunaijie/images/master/aop</a> 流程.png)</p>
<h4 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h4><p>我们知道，切面只是实现了它们所包装的bean相同接口的代理。所以我们可以让接口暴露新的接口来实现添加新功能，比如现在我们需要对源码中的方法进行增强，需要添加一个方法，那么这个方式就很好的实现。</p>
<p><img src="https://raw.githubusercontent.com/liunaijie/images/master/aop%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%8A%9F%E8%83%BD.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddMethodAspect</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@DeclareParents(value=&quot;com.test.ClassA+&quot;,defaultImpl=DefaultEncoreable.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Encoreable encoreable;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增加的接口，对切面新增加了一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Encoreable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">performEncore</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultEncoreable</span> <span class="keyword">implements</span> <span class="title class_">Encoreable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">performEncore</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is a new method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也是定义了一个切面，但是这个切面有之前定义的有所不同，它并没有定义切点，通知方法。而是通过<code>@DeclareParents</code>注解，将<code>Encoreable</code>接口引入到<code>ClassA</code><strong>bean</strong>中。</p>
<p><code>@DeclareParents</code>注解主要由三部分组成</p>
<ul>
<li>value属性指定了哪种类型的bean要引入该接口，在本例中，也就是所有实现<code> ClassA</code>的类型。（标记符后面的加号表示所有子类型，而不是本身）</li>
<li>defaultImpl属性指定了为引入功能提供实现的类，这里指定了<code>DefaultEncoreable</code>提供实现</li>
<li><code>@DeclareParents</code>注解所标记的静态属性指明了要引入的接口。</li>
</ul>
<p>这样在调用所有实现<code>ClassA</code>类型的bean时，都可以进行调用<code>performEncore</code>方法。</p>
<p><strong>spring会创建一个代理，然后将调用委托给被代理的bean或被引入的实现，这取决于调用的方法属于被代理的bean还是属于被引入的接口。</strong></p>
<h2 id="AOP-使用场景"><a href="#AOP-使用场景" class="headerlink" title="AOP 使用场景"></a>AOP 使用场景</h2><ul>
<li>权限控制</li>
<li>日志存储</li>
<li>统一异常处理</li>
<li>缓存处理</li>
<li>事务处理</li>
<li>……</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>在spring中，事务的隔离级别有五种，分别为</p>
<ul>
<li><p>DEFAULT(默认)</p>
<p>  使用数据库的隔离级别</p>
</li>
<li><p>READ_UNCOMMITTED(读未提交)</p>
</li>
<li><p>READ_COMMITTED(读已提交)</p>
</li>
<li><p>SERIALIZABLE(串行化)</p>
</li>
</ul>
<p>就是数据库的四种事务隔离级别再加上一个<code>default</code>，其他四种事务隔离级别在[MySQL知识整理这篇文章中进行了记录</p>
<h2 id="事务传播级别"><a href="#事务传播级别" class="headerlink" title="事务传播级别"></a>事务传播级别</h2><p>一共有7种</p>
<ul>
<li><p>Required</p>
<p>  当前方法必须运行在事务中，如果当前事务存在，方法就在该事务中运行，否则会启动一个新的事务</p>
</li>
<li><p>Supports</p>
<p>  不需要事务，但是如果存在事务就在事务中运行</p>
</li>
<li><p>Mandatory</p>
<p>  方法必须在事务中运行，如果不存在事务就抛出一个异常</p>
</li>
<li><p>REQUIRES_NEW</p>
<p>  当前方法必须运行在自己的事务中，新启动一个事务，如果当时有事务则将当前事务挂起</p>
</li>
<li><p>Not_Supported</p>
<p>  当前方法不运行在事务中，如果存在事务，则在方法运行期间将事务挂起</p>
</li>
<li><p>Never</p>
<p>  当前方法不应该运行在事务中，如果有事务，就抛出异常</p>
</li>
<li><p>Nested</p>
<p>  如果当前存在事务，则会嵌套事务运行，嵌套的事务可以独立的提交和回滚，不会对嵌套外部的事务有影响。如果当前不存在事务，则和Required一样</p>
</li>
</ul>
<h2 id="Spring-中事务无效的情况（-Transactional）"><a href="#Spring-中事务无效的情况（-Transactional）" class="headerlink" title="Spring 中事务无效的情况（@Transactional）"></a>Spring 中事务无效的情况（@Transactional）</h2><ol>
<li><p>数据库是否支持事务</p>
</li>
<li><p>注解添加在私有方法上<code>private</code>无效</p>
</li>
<li><p>拦截的异常小于抛出的异常，注解里面的参数<code>rollbackFor</code>执行回滚的异常类型，如果这个异常类型比抛出的异常类型小就无法回滚。</p>
</li>
<li><p>加入在未加入接口的public 方法，再通过普通接口方法调用，无效</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">implementsMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 实现的接口方法</span></span><br><span class="line">        <span class="comment">// 此时事务无效</span></span><br><span class="line">        selfMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selfMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//自己新增的方法</span></span><br><span class="line">        <span class="comment">//数据库操作</span></span><br><span class="line">		userDao.insert(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">		<span class="comment">// 我们知道 0 不能作为除数，所以会报错，然后通过异常拦截回滚</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>在没有事务的方法中调用有事务的方法，如果在有事务的方法中抛出异常事务也是无效的。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">noTransactional</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 此时事务无效</span></span><br><span class="line">		hasTransactional();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hasTransactional</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//数据库操作</span></span><br><span class="line">		userDao.insert(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">		<span class="comment">// 我们知道 0 不能作为除数，所以会报错，然后通过异常拦截回滚</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果要对这种情况进行改进，可以使用两种方式</p>
<ol>
<li><p>对调用方法添加事务注解</p>
</li>
<li><p>调用时通过实例调用</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">noTransactional</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 此时事务有效</span></span><br><span class="line">		userService.hasTransactional();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hasTransactional</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//数据库操作</span></span><br><span class="line">		userDao.insert(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">		<span class="comment">// 我们知道 0 不能作为除数，所以会报错，然后通过异常拦截回滚</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h1><p>几个常用的方式顺序，优先级高的会覆盖优先级低的。</p>
<ol>
<li>命令行参数</li>
<li>jar包同级的目录中的配置文件</li>
<li>源码resources中的配置文件</li>
</ol>
<p>我们用几个例子来说明，一个项目的结构如下：</p>
<ol>
<li><blockquote>
<p>– application.properties</p>
<p>|– demo.jar</p>
<p>​		|– application.properties</p>
</blockquote>
</li>
</ol>
<p>那么这个在目录外的配置文件会比源码里面的配置文件优先级高</p>
<ol start="2">
<li>当我们设置了<code>spring.profile.active</code>这个属性后，会根据不同环境选择不同的配置文件</li>
</ol>
<blockquote>
<p>– applitaion.properties</p>
<p>​	|– spring.profile.active&#x3D;dev</p>
<p>​	|– server.port&#x3D;8080</p>
<p>– applicaton-dev.properties</p>
<p>​	|– server.port&#x3D;8081</p>
</blockquote>
<p>当在主配置文件中设置<code>spring.profile.active</code>属性为<code>dev</code>时，<code>-dev</code>的配置文件就会生效，像上面的配置则会以8081端口启动，即带<code>&#123;profile&#125;</code>的配置文件优先级高</p>
<ol start="3">
<li>在上面的情况下在进行扩展，当jar包外部也有一个<code>-dev</code>的配置文件时，在外部的优先级会更高。</li>
</ol>

<br>
<h2>Tags: </h2>
  <p><a class="classtest-link" href="/tags/Spring/" rel="tag">Spring</a> — 2019年9月4日</p>
  

  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>

        </div>
        <!-- <div class="row mt-2">
  <h3>Search</h3>
  <div><input id="search-text" title="search" class="search-text" type="text" placeholder="search......"></div>
  <div style="margin-top: 1.5rem;">
    <ul id="result"></ul>
  </div>
</div> -->
        <div class="row mt-2">
  
    <div class="eight columns">
      <p id="madewith">Made with ❤ and
        <a class="footer-link icon" href="https://hexo.io" target="_blank" style="text-decoration: none;" rel="noreferrer" aria-label="Hexo.io">
        <svg class="hexo svg-hov" width="14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Hexo.js</title><path d="M12 .007L1.57 6.056V18.05L12 23.995l10.43-6.049V5.952L12 .007zm4.798 17.105l-.939.521-.939-.521V12.94H9.08v4.172l-.94.521-.938-.521V6.89l.939-.521.939.521v4.172h5.84V6.89l.94-.521.938.521v10.222z"/></svg>
        </a>
        
    </div>

    <!-- Sepcial thanks to https://simpleicons.org/ for the icons -->
    <div class="four columns mb-3 posisi" >
      
      <a class="ml-0 footer-link icon" href="https://github.com/liunaijie" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="GitHub">
        <svg class="github svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      </a>
      

      

      

      

      
      
        <a class="ml-0 footer-link icon" href="mailto:jarvis@apache.org" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="Email">
          <svg class="email svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Email</title><path d="M12 12.713l11.985-7.99c-.01-.01-11.985-7.723-11.985-7.723s-11.975 7.713-11.985 7.723l11.985 7.99zm0 2.287l-12-8v14h24v-14l-12 8z"/></svg>
        </a>
        
    </div>
  
</div>

      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>

  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>