# 题目
给定一个有序数组arr，代表坐落在x轴上的点
给定一个正数k 表示绳子的长度
返回绳子最多压中几个点？即使绳子边缘压住也算盖住
# 思路
## 遍历+二分查找
从前向后遍历，i位置的点减去绳子的长度得到t。
求t在数组中所在位置，如果不存在则返回第一个比他大的元素的位置
由此可计算出在i位置的绳子的覆盖点数
全部遍历后求最大值
复杂度O（N\*logN）
### 代码实现
```java
private static int process1(int[] array, int k) {  
   if (array == null || array.length == 0) {  
      return 0;  
   }  
   int res = 1;  
   for (int i = 0; i < array.length; i++) {  
      // array[i]-k,得到以当前位置为结束，绳子可以到x轴的什么位置  
      // 由于数组有序，在数组中查找绳子开始的位置，如果找不到，则返回离这个值最近的一个元素（后一个）      // 得到元素下标后，即可得到在当前位置可以覆盖的点数      // 全部遍历完成后，取最大值      int nearest = findTheNearestIndex(array, i, array[i] - k);  
      res = Math.max(res, i - nearest + 1);  
   }  
   return res;  
}  
  
private static int findTheNearestIndex(int[] array, int end, int value) {  
   int left = 0;  
   int index = end;  
   while (left <= end) {  
      int mid = left + ((end - left) >> 1);  
      if (array[mid] >= value) {  
         index = mid;  
         end = mid - 1;  
      } else {  
         left = mid + 1;  
      }  
   }  
   return index;  
}
```


## 滑动数组 双指针
left right指针 当两者之间距离小于k right移动 大于k left移动
复杂度O（N）
### 代码实现
```java
private static int process(int[] array, int k) {  
   if (array == null || array.length == 0) {  
      return 0;  
   }  
   int res = 0;  
   int left = 0, right = 0;  
   int l = array.length;  
   while (right < l) {  
      // 当两个指针之间的距离比K小时，右指针向右移动  
      while (right < l && array[right] - array[left] <= k) {  
         right++;  
      }  
      // 每次计算当前窗口的长度，与历史最大值做比较  
      res = Math.max(res, right - left);  
      // 当前窗口已经超过k的长度，则左指针向右移动  
      left++;  
   }  
   return res;  
}
```


