# 题目
给定一个数组arr 你可以在每个数值之前决定使用+或者-
但是必须所有数字参与
再给定一个target 求算出target的方法有多少种

# 解答
## 递归
在i位置时, 要求rest时, 对于i有两种情况, 一个是使用+号, 一个是使用-号.
让使用+号时, 对于i+1的位置, 所求的值是rest-array\[i].
递归的终止条件为: 当数组全部遍历完成时, 如果rest为0. 即当前可以有一种计算方式. 否则这种计算方式不成立.
### 代码实现
```java
private static int process1(int[] array, int index, int rest) {  
   if (index == array.length) {  
      // 当index越界后，即数组内所有数字都使用完毕  
      // 如果rest为0，则有一种方法，否则没有解法      return rest == 0 ? 1 : 0;  
   }  
   // 由于可以自由使用+ -，所有计算出它们两者之和  
   return process1(array, index + 1, rest - array[index]) + process1(array, index + 1, rest + array[index]);  
}

private static int findTargetSumWay(int[] array, int target) {  
   return process1(array, 0, target);  
}
```

## 记忆化搜索
由于递归中可能再次计算之前已经计算过的值, 添加缓冲对结果进行存储
```java
private static int process2(int[] array, int index, int rest, Map<Integer, Map<Integer, Integer>> cache) {  
   if (cache.containsKey(index) && cache.get(index).containsKey(rest)) {  
      return cache.get(index).get(rest);  
   }  
   int ans = 0;  
   if (index == array.length) {  
      ans = rest == 0 ? 1 : 0;  
   } else {  
      ans = process2(array, index + 1, rest - array[index], cache)  
            + process2(array, index + 1, rest + array[index], cache);  
   }  
   if (!cache.containsKey(index)) {  
      cache.put(index, new HashMap<>());  
   }  
   cache.get(index).put(rest, ans);  
   return rest;  
}
```

## 
由于可以自由使用+,-号, 所以数组中的数字正负对于结果没有影响. 也就是说我们可以将其转换为全部都是正数的数组.
当我们对数组中所有元素相加,得到SUM, 如果SUM\<target. 则不可能存在一种方式得到target. 返回0.同理如果-SUM>target. 也可以直接返回0.

由于可以自由使用+,-号. 我们将其划分为两组, 使用+号的一组为P, 使用-号的一组为N. 我们知道P+N=SUM. 而要想得到target, 我们就需要P-N=target, 当我们对公式两边同时加上`P+N`时, 可以得到P=(SUM+target)/2. 而SUM, target都是已知或可求的.  
所以这个问题我们可以转换为求在数组(正数数组)中求任意个元素相加等于P的组合数.
```java
private static int findTargetSumWay3(int[] array, int target) {  
   int sum = Arrays.stream(array).sum();  
   if (sum < target) {  
      return 0;  
   }  
   return subset(array, (target + sum) / 2);  
}  
  
private static int subset(int[] nums, int s) {  
   int[] dp = new int[s + 1];  
   dp[0] = 1;  
   for (int num : nums) {  
      for (int i = s; i >= num; i--) {  
         dp[i] += dp[i - num];  
      }  
   }  
   return dp[s];  
}
```

