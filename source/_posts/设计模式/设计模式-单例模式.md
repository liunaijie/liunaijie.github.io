---
title: 设计模式-单例模式
categories: 
	- [code,design]
tags:
  - 设计模式
toc: true
date: 2019-10-14 09:08:39
---

# 单例模式

## 概念

一个类只允许创建一个对象（或者实例），那这个类就是一个单例类

## 为什么要使用单例

有些数据在系统中只应该保存一份，当使用多个对象时会造成一些错误。有一些资源访问冲突时也可以使用单例模式来解决。

# 实现方式

由于对象只能有一个，所以构造函数的权限必须是`private`私有的，这样外部就无法通过`new`来创建实例

还有一些需要关注的点

- 创建对象的线程安全问题
- 是否支持延迟加载
- 获取实例方法的性能是否高

<!--more-->

## 饿汉式

优点：写法简单。在类装载时就完成了实例化。线程安全

缺点：由于在类装载时就完成了实例化，如果从始至终都没有用到这个实例，会造成内存浪费

```java
class Single {
	/**
	 * 设置成私有的，保证无法在其它类中使用 new 关键字进行实例化
	 */
	private Single() {}

	private final static Single INSTANCE = new Single();

    /**
	 * 从外界获取实例的唯一方法，从这个方法拿到的实例肯定是全局唯一的
	 * @return
	 */
	public static Single getInstance() {
		return INSTANCE;
	}

}

/**
 * 与上面的类似，用了静态代码块，不同的代码写法其他完全一样
 */
class SingleTest2 {

	private SingleTest2() {}

	private static SingleTest2 SINGLE_TEST_2;

	static {
		SINGLE_TEST_2 = new SingleTest2();
	}
    
	public static SingleTest2 getInstance() {
		return SINGLE_TEST_2;
	}
}
```

## 懒汉式

在需要用到实例时才进行初始化，所以不会造成内存浪费，但多线程情况下会出现多个实例的情况

```java
/**
 * 懒汉式的单例模式
 * 线程不安全
 */
class UnSafeSingle {

	private UnSafeSingle() {
	}

	private static UnSafeSingle INSTANCE;

	public static UnSafeSingle getInstance() {
		if (INSTANCE == null) {
      //这个地方，当多个线程同时进入判断后会造成多个实例
			INSTANCE = new UnSafeSingle();
		}
		return INSTANCE;
	}

}

/**
 * 通过加锁的方式实现线程安全的懒汉式单例
 * 由于获取单例的方法每次都需要进行同步，所以效率不高
 */
class SynchronizedSingle {
	private SynchronizedSingle() {
	}

	private static SynchronizedSingle INSTANCE;

	public static synchronized SynchronizedSingle getInstance() {
		if (INSTANCE == null) {
     //由于方法加锁，所以每次只能一个线程访问，不会造成多个实例的情况，但是效率不高
			INSTANCE = new SynchronizedSingle();
		}
		return INSTANCE;
	}
}

/**
 * 双重检查
 * 当使用getInstance()方法时不会进行同步，先进行判断。
 * 由于使用了 volatile 关键字，即便有两个线程同时执行了这个方法，只要有一个线程对变量进行了修改，另外一个线程也能接收到更改的信号
 */
class SafeSingle{

	private SafeSingle(){}

	private static volatile SafeSingle INSTANCE;

	public static SafeSingle getInstance(){
		if(INSTANCE==null){
       //使用了双重检查
			synchronized (SafeSingle.class){
				if(INSTANCE==null){
					INSTANCE = new SafeSingle();
				}
			}
		}
		return INSTANCE;
	}

}
```



## 静态内部类

```java
/**
 * 线程安全，实现了懒加载
 */
class Single {

	private Single() {
	}

	/**
	 * 内部类在getInstance()方法被调用时才会被加载
	 */
	private static class InSingle {
		private static final Single INSTANCE = new Single();
	}

	public static Single getInstance() {
		return InSingle.INSTANCE;
	}

}
```

使用了静态内部类，在外部类方法调用时才会进行初始化也就实现了懒加载，并且在类加载过程中也是线程安全的，不会出现多个实例的情况

## 枚举

```java
enum Single {

	INSTANCE;


	public void sayHello(String name) {
		System.out.println("hello," + name);
	}

}
```

枚举能避免多线程产生多个实例的问题，还能防止反序列化重新创建新的对象

**所以单例模式推荐使用枚举，静态内部类的方法，或者饿汉式的方法**